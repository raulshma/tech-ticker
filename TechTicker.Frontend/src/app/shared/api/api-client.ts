//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.4.0.0 (NJsonSchema v11.3.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable({
    providedIn: 'root'
})
export class TechTickerApiClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return OK
     */
    getAllUsers(page: number | undefined, pageSize: number | undefined): Observable<UserDtoPagedResponse> {
        let url_ = this.baseUrl + "/api/Admin/users?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUsers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDtoPagedResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDtoPagedResponse>;
        }));
    }

    protected processGetAllUsers(response: HttpResponseBase): Observable<UserDtoPagedResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDtoPagedResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createUser(body: CreateUserDto | undefined): Observable<UserDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Admin/users";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDtoApiResponse>;
        }));
    }

    protected processCreateUser(response: HttpResponseBase): Observable<UserDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getUserById(userId: string): Observable<UserDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Admin/users/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDtoApiResponse>;
        }));
    }

    protected processGetUserById(response: HttpResponseBase): Observable<UserDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    updateUser(userId: string, body: UpdateUserDto | undefined): Observable<UserDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Admin/users/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDtoApiResponse>;
        }));
    }

    protected processUpdateUser(response: HttpResponseBase): Observable<UserDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    deleteUser(userId: string): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/api/Admin/users/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processDeleteUser(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param userId (optional) 
     * @param productId (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return OK
     */
    getAllAlerts(userId: string | undefined, productId: string | undefined, page: number | undefined, pageSize: number | undefined): Observable<AlertRuleDtoPagedResponse> {
        let url_ = this.baseUrl + "/api/Admin/alerts?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (productId === null)
            throw new Error("The parameter 'productId' cannot be null.");
        else if (productId !== undefined)
            url_ += "productId=" + encodeURIComponent("" + productId) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAlerts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAlerts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AlertRuleDtoPagedResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AlertRuleDtoPagedResponse>;
        }));
    }

    protected processGetAllAlerts(response: HttpResponseBase): Observable<AlertRuleDtoPagedResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AlertRuleDtoPagedResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createAlert(body: CreateAlertRuleDto | undefined): Observable<AlertRuleDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Alerts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateAlert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateAlert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AlertRuleDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AlertRuleDtoApiResponse>;
        }));
    }

    protected processCreateAlert(response: HttpResponseBase): Observable<AlertRuleDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AlertRuleDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getUserAlerts(): Observable<AlertRuleDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Alerts";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserAlerts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserAlerts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AlertRuleDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AlertRuleDtoIEnumerableApiResponse>;
        }));
    }

    protected processGetUserAlerts(response: HttpResponseBase): Observable<AlertRuleDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AlertRuleDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getProductAlerts(productId: string): Observable<AlertRuleDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Alerts/product/{productId}";
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductAlerts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductAlerts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AlertRuleDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AlertRuleDtoIEnumerableApiResponse>;
        }));
    }

    protected processGetProductAlerts(response: HttpResponseBase): Observable<AlertRuleDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AlertRuleDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    updateAlert(alertRuleId: string, body: UpdateAlertRuleDto | undefined): Observable<AlertRuleDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Alerts/{alertRuleId}";
        if (alertRuleId === undefined || alertRuleId === null)
            throw new Error("The parameter 'alertRuleId' must be defined.");
        url_ = url_.replace("{alertRuleId}", encodeURIComponent("" + alertRuleId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAlert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAlert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AlertRuleDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AlertRuleDtoApiResponse>;
        }));
    }

    protected processUpdateAlert(response: HttpResponseBase): Observable<AlertRuleDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AlertRuleDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    deleteAlert(alertRuleId: string): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/api/Alerts/{alertRuleId}";
        if (alertRuleId === undefined || alertRuleId === null)
            throw new Error("The parameter 'alertRuleId' must be defined.");
        url_ = url_.replace("{alertRuleId}", encodeURIComponent("" + alertRuleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAlert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAlert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processDeleteAlert(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    register(body: RegisterUserDto | undefined): Observable<UserDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Auth/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDtoApiResponse>;
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<UserDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    login(body: LoginUserDto | undefined): Observable<LoginResponseDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Auth/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LoginResponseDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LoginResponseDtoApiResponse>;
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<LoginResponseDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoginResponseDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getCurrentUser(): Observable<UserDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Auth/me";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDtoApiResponse>;
        }));
    }

    protected processGetCurrentUser(response: HttpResponseBase): Observable<UserDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createCategory(body: CreateCategoryDto | undefined): Observable<CategoryDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Categories";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateCategory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CategoryDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CategoryDtoApiResponse>;
        }));
    }

    protected processCreateCategory(response: HttpResponseBase): Observable<CategoryDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CategoryDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getCategories(): Observable<CategoryDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Categories";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCategories(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CategoryDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CategoryDtoIEnumerableApiResponse>;
        }));
    }

    protected processGetCategories(response: HttpResponseBase): Observable<CategoryDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CategoryDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getCategoryByIdOrSlug(categoryIdOrSlug: string): Observable<CategoryDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Categories/{categoryIdOrSlug}";
        if (categoryIdOrSlug === undefined || categoryIdOrSlug === null)
            throw new Error("The parameter 'categoryIdOrSlug' must be defined.");
        url_ = url_.replace("{categoryIdOrSlug}", encodeURIComponent("" + categoryIdOrSlug));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCategoryByIdOrSlug(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCategoryByIdOrSlug(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CategoryDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CategoryDtoApiResponse>;
        }));
    }

    protected processGetCategoryByIdOrSlug(response: HttpResponseBase): Observable<CategoryDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CategoryDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    updateCategory(categoryId: string, body: UpdateCategoryDto | undefined): Observable<CategoryDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Categories/{categoryId}";
        if (categoryId === undefined || categoryId === null)
            throw new Error("The parameter 'categoryId' must be defined.");
        url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCategory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CategoryDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CategoryDtoApiResponse>;
        }));
    }

    protected processUpdateCategory(response: HttpResponseBase): Observable<CategoryDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CategoryDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    deleteCategory(categoryId: string): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/api/Categories/{categoryId}";
        if (categoryId === undefined || categoryId === null)
            throw new Error("The parameter 'categoryId' must be defined.");
        url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCategory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processDeleteCategory(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getDashboardStats(): Observable<DashboardStatsDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Dashboard/stats";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDashboardStats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDashboardStats(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DashboardStatsDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DashboardStatsDtoApiResponse>;
        }));
    }

    protected processGetDashboardStats(response: HttpResponseBase): Observable<DashboardStatsDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DashboardStatsDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getSuccessExample(): Observable<ObjectApiResponse> {
        let url_ = this.baseUrl + "/api/Example/success";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSuccessExample(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSuccessExample(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResponse>;
        }));
    }

    protected processGetSuccessExample(response: HttpResponseBase): Observable<ObjectApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param skip (optional) 
     * @param take (optional) 
     * @return OK
     */
    getPaginatedExample(pageNumber: number | undefined, pageSize: number | undefined, skip: number | undefined, take: number | undefined): Observable<ObjectPagedResponse> {
        let url_ = this.baseUrl + "/api/Example/paginated?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaginatedExample(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaginatedExample(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectPagedResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectPagedResponse>;
        }));
    }

    protected processGetPaginatedExample(response: HttpResponseBase): Observable<ObjectPagedResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectPagedResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getResultExample(id: number): Observable<ObjectApiResponse> {
        let url_ = this.baseUrl + "/api/Example/result/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetResultExample(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetResultExample(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResponse>;
        }));
    }

    protected processGetResultExample(response: HttpResponseBase): Observable<ObjectApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getErrorExample(type: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Example/error/{type}";
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined.");
        url_ = url_.replace("{type}", encodeURIComponent("" + type));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetErrorExample(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetErrorExample(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetErrorExample(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    validateExample(body: ValidationExampleRequest | undefined): Observable<StringApiResponse> {
        let url_ = this.baseUrl + "/api/Example/validate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidateExample(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidateExample(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StringApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StringApiResponse>;
        }));
    }

    protected processValidateExample(response: HttpResponseBase): Observable<StringApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    utilitiesExample(body: UtilitiesExampleRequest | undefined): Observable<ObjectApiResponse> {
        let url_ = this.baseUrl + "/api/Example/utilities";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUtilitiesExample(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUtilitiesExample(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResponse>;
        }));
    }

    protected processUtilitiesExample(response: HttpResponseBase): Observable<ObjectApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createMapping(body: CreateProductSellerMappingDto | undefined): Observable<ProductSellerMappingDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Mappings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateMapping(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateMapping(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductSellerMappingDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductSellerMappingDtoApiResponse>;
        }));
    }

    protected processCreateMapping(response: HttpResponseBase): Observable<ProductSellerMappingDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductSellerMappingDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param canonicalProductId (optional) 
     * @return OK
     */
    getMappings(canonicalProductId: string | undefined): Observable<ProductSellerMappingDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Mappings?";
        if (canonicalProductId === null)
            throw new Error("The parameter 'canonicalProductId' cannot be null.");
        else if (canonicalProductId !== undefined)
            url_ += "canonicalProductId=" + encodeURIComponent("" + canonicalProductId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMappings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMappings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductSellerMappingDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductSellerMappingDtoIEnumerableApiResponse>;
        }));
    }

    protected processGetMappings(response: HttpResponseBase): Observable<ProductSellerMappingDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductSellerMappingDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getActiveMappings(): Observable<ProductSellerMappingDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Mappings/active";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActiveMappings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActiveMappings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductSellerMappingDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductSellerMappingDtoIEnumerableApiResponse>;
        }));
    }

    protected processGetActiveMappings(response: HttpResponseBase): Observable<ProductSellerMappingDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductSellerMappingDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    updateMapping(mappingId: string, body: UpdateProductSellerMappingDto | undefined): Observable<ProductSellerMappingDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Mappings/{mappingId}";
        if (mappingId === undefined || mappingId === null)
            throw new Error("The parameter 'mappingId' must be defined.");
        url_ = url_.replace("{mappingId}", encodeURIComponent("" + mappingId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateMapping(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMapping(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductSellerMappingDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductSellerMappingDtoApiResponse>;
        }));
    }

    protected processUpdateMapping(response: HttpResponseBase): Observable<ProductSellerMappingDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductSellerMappingDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    deleteMapping(mappingId: string): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/api/Mappings/{mappingId}";
        if (mappingId === undefined || mappingId === null)
            throw new Error("The parameter 'mappingId' must be defined.");
        url_ = url_.replace("{mappingId}", encodeURIComponent("" + mappingId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteMapping(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMapping(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processDeleteMapping(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    triggerManualScraping(mappingId: string): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/api/Mappings/{mappingId}/scrape-now";
        if (mappingId === undefined || mappingId === null)
            throw new Error("The parameter 'mappingId' must be defined.");
        url_ = url_.replace("{mappingId}", encodeURIComponent("" + mappingId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTriggerManualScraping(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTriggerManualScraping(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processTriggerManualScraping(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getAllPermissions(): Observable<PermissionDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Permission";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPermissions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PermissionDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PermissionDtoIEnumerableApiResponse>;
        }));
    }

    protected processGetAllPermissions(response: HttpResponseBase): Observable<PermissionDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermissionDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createPermission(body: CreatePermissionDto | undefined): Observable<PermissionDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Permission";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePermission(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePermission(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PermissionDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PermissionDtoApiResponse>;
        }));
    }

    protected processCreatePermission(response: HttpResponseBase): Observable<PermissionDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermissionDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getPermissionsByCategory(category: string): Observable<PermissionDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Permission/category/{category}";
        if (category === undefined || category === null)
            throw new Error("The parameter 'category' must be defined.");
        url_ = url_.replace("{category}", encodeURIComponent("" + category));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPermissionsByCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPermissionsByCategory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PermissionDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PermissionDtoIEnumerableApiResponse>;
        }));
    }

    protected processGetPermissionsByCategory(response: HttpResponseBase): Observable<PermissionDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermissionDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getPermissionById(id: string): Observable<PermissionDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Permission/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPermissionById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPermissionById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PermissionDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PermissionDtoApiResponse>;
        }));
    }

    protected processGetPermissionById(response: HttpResponseBase): Observable<PermissionDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermissionDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    updatePermission(id: string, body: UpdatePermissionDto | undefined): Observable<PermissionDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Permission/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePermission(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePermission(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PermissionDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PermissionDtoApiResponse>;
        }));
    }

    protected processUpdatePermission(response: HttpResponseBase): Observable<PermissionDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermissionDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    deletePermission(id: string): Observable<BooleanApiResponse> {
        let url_ = this.baseUrl + "/api/Permission/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePermission(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePermission(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponse>;
        }));
    }

    protected processDeletePermission(response: HttpResponseBase): Observable<BooleanApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getRolePermissions(roleId: string): Observable<PermissionDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Permission/role/{roleId}";
        if (roleId === undefined || roleId === null)
            throw new Error("The parameter 'roleId' must be defined.");
        url_ = url_.replace("{roleId}", encodeURIComponent("" + roleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRolePermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRolePermissions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PermissionDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PermissionDtoIEnumerableApiResponse>;
        }));
    }

    protected processGetRolePermissions(response: HttpResponseBase): Observable<PermissionDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermissionDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getRolePermissionsByName(roleName: string): Observable<PermissionDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Permission/role/name/{roleName}";
        if (roleName === undefined || roleName === null)
            throw new Error("The parameter 'roleName' must be defined.");
        url_ = url_.replace("{roleName}", encodeURIComponent("" + roleName));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRolePermissionsByName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRolePermissionsByName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PermissionDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PermissionDtoIEnumerableApiResponse>;
        }));
    }

    protected processGetRolePermissionsByName(response: HttpResponseBase): Observable<PermissionDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermissionDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    assignPermissionToRole(roleId: string, permissionId: string): Observable<BooleanApiResponse> {
        let url_ = this.baseUrl + "/api/Permission/role/{roleId}/permission/{permissionId}";
        if (roleId === undefined || roleId === null)
            throw new Error("The parameter 'roleId' must be defined.");
        url_ = url_.replace("{roleId}", encodeURIComponent("" + roleId));
        if (permissionId === undefined || permissionId === null)
            throw new Error("The parameter 'permissionId' must be defined.");
        url_ = url_.replace("{permissionId}", encodeURIComponent("" + permissionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssignPermissionToRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssignPermissionToRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponse>;
        }));
    }

    protected processAssignPermissionToRole(response: HttpResponseBase): Observable<BooleanApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    removePermissionFromRole(roleId: string, permissionId: string): Observable<BooleanApiResponse> {
        let url_ = this.baseUrl + "/api/Permission/role/{roleId}/permission/{permissionId}";
        if (roleId === undefined || roleId === null)
            throw new Error("The parameter 'roleId' must be defined.");
        url_ = url_.replace("{roleId}", encodeURIComponent("" + roleId));
        if (permissionId === undefined || permissionId === null)
            throw new Error("The parameter 'permissionId' must be defined.");
        url_ = url_.replace("{permissionId}", encodeURIComponent("" + permissionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemovePermissionFromRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemovePermissionFromRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponse>;
        }));
    }

    protected processRemovePermissionFromRole(response: HttpResponseBase): Observable<BooleanApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getUserPermissions(userId: string): Observable<PermissionDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Permission/user/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserPermissions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PermissionDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PermissionDtoIEnumerableApiResponse>;
        }));
    }

    protected processGetUserPermissions(response: HttpResponseBase): Observable<PermissionDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermissionDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    checkUserPermission(userId: string, permissionName: string): Observable<BooleanApiResponse> {
        let url_ = this.baseUrl + "/api/Permission/user/{userId}/check/{permissionName}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (permissionName === undefined || permissionName === null)
            throw new Error("The parameter 'permissionName' must be defined.");
        url_ = url_.replace("{permissionName}", encodeURIComponent("" + permissionName));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckUserPermission(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckUserPermission(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponse>;
        }));
    }

    protected processCheckUserPermission(response: HttpResponseBase): Observable<BooleanApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    bulkAssignPermissionsToRole(roleId: string, body: string[] | undefined): Observable<BooleanApiResponse> {
        let url_ = this.baseUrl + "/api/Permission/role/{roleId}/permissions/bulk";
        if (roleId === undefined || roleId === null)
            throw new Error("The parameter 'roleId' must be defined.");
        url_ = url_.replace("{roleId}", encodeURIComponent("" + roleId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBulkAssignPermissionsToRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBulkAssignPermissionsToRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponse>;
        }));
    }

    protected processBulkAssignPermissionsToRole(response: HttpResponseBase): Observable<BooleanApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getPermissionCategories(): Observable<StringStringArrayDictionaryApiResponse> {
        let url_ = this.baseUrl + "/api/Permission/categories";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPermissionCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPermissionCategories(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StringStringArrayDictionaryApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StringStringArrayDictionaryApiResponse>;
        }));
    }

    protected processGetPermissionCategories(response: HttpResponseBase): Observable<StringStringArrayDictionaryApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringStringArrayDictionaryApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createProduct(body: CreateProductDto | undefined): Observable<ProductDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Products";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateProduct(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductDtoApiResponse>;
        }));
    }

    protected processCreateProduct(response: HttpResponseBase): Observable<ProductDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param categoryId (optional) 
     * @param search (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return OK
     */
    getProducts(categoryId: string | undefined, search: string | undefined, page: number | undefined, pageSize: number | undefined): Observable<ProductDtoPagedResponse> {
        let url_ = this.baseUrl + "/api/Products?";
        if (categoryId === null)
            throw new Error("The parameter 'categoryId' cannot be null.");
        else if (categoryId !== undefined)
            url_ += "categoryId=" + encodeURIComponent("" + categoryId) + "&";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProducts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProducts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductDtoPagedResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductDtoPagedResponse>;
        }));
    }

    protected processGetProducts(response: HttpResponseBase): Observable<ProductDtoPagedResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductDtoPagedResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getProductById(productId: string): Observable<ProductDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Products/{productId}";
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductDtoApiResponse>;
        }));
    }

    protected processGetProductById(response: HttpResponseBase): Observable<ProductDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    updateProduct(productId: string, body: UpdateProductDto | undefined): Observable<ProductDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Products/{productId}";
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateProduct(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductDtoApiResponse>;
        }));
    }

    protected processUpdateProduct(response: HttpResponseBase): Observable<ProductDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    deleteProduct(productId: string): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/api/Products/{productId}";
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteProduct(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processDeleteProduct(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param sellerName (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param limit (optional) 
     * @return OK
     */
    getPriceHistory(productId: string, sellerName: string | undefined, startDate: Date | undefined, endDate: Date | undefined, limit: number | undefined): Observable<PriceHistoryDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Products/{productId}/price-history?";
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        if (sellerName === null)
            throw new Error("The parameter 'sellerName' cannot be null.");
        else if (sellerName !== undefined)
            url_ += "sellerName=" + encodeURIComponent("" + sellerName) + "&";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPriceHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPriceHistory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PriceHistoryDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PriceHistoryDtoIEnumerableApiResponse>;
        }));
    }

    protected processGetPriceHistory(response: HttpResponseBase): Observable<PriceHistoryDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PriceHistoryDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getCurrentPrices(productId: string): Observable<CurrentPriceDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Products/{productId}/current-prices";
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentPrices(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentPrices(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CurrentPriceDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CurrentPriceDtoIEnumerableApiResponse>;
        }));
    }

    protected processGetCurrentPrices(response: HttpResponseBase): Observable<CurrentPriceDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CurrentPriceDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param categoryId (optional) 
     * @param search (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return OK
     */
    getProductsCatalog(categoryId: string | undefined, search: string | undefined, page: number | undefined, pageSize: number | undefined): Observable<ProductWithCurrentPricesDtoPagedResponse> {
        let url_ = this.baseUrl + "/api/Products/catalog?";
        if (categoryId === null)
            throw new Error("The parameter 'categoryId' cannot be null.");
        else if (categoryId !== undefined)
            url_ += "categoryId=" + encodeURIComponent("" + categoryId) + "&";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductsCatalog(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductsCatalog(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductWithCurrentPricesDtoPagedResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductWithCurrentPricesDtoPagedResponse>;
        }));
    }

    protected processGetProductsCatalog(response: HttpResponseBase): Observable<ProductWithCurrentPricesDtoPagedResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductWithCurrentPricesDtoPagedResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getProductCatalogDetail(productId: string): Observable<ProductWithCurrentPricesDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Products/catalog/{productId}";
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductCatalogDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductCatalogDetail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductWithCurrentPricesDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductWithCurrentPricesDtoApiResponse>;
        }));
    }

    protected processGetProductCatalogDetail(response: HttpResponseBase): Observable<ProductWithCurrentPricesDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductWithCurrentPricesDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getAllRoles(): Observable<RoleInfoDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Roles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleInfoDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleInfoDtoIEnumerableApiResponse>;
        }));
    }

    protected processGetAllRoles(response: HttpResponseBase): Observable<RoleInfoDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleInfoDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createRole(body: CreateRoleDto | undefined): Observable<RoleInfoDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Roles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleInfoDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleInfoDtoApiResponse>;
        }));
    }

    protected processCreateRole(response: HttpResponseBase): Observable<RoleInfoDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleInfoDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getRoleById(roleId: string): Observable<RoleInfoDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Roles/{roleId}";
        if (roleId === undefined || roleId === null)
            throw new Error("The parameter 'roleId' must be defined.");
        url_ = url_.replace("{roleId}", encodeURIComponent("" + roleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoleById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoleById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleInfoDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleInfoDtoApiResponse>;
        }));
    }

    protected processGetRoleById(response: HttpResponseBase): Observable<RoleInfoDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleInfoDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    deleteRole(roleId: string): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/api/Roles/{roleId}";
        if (roleId === undefined || roleId === null)
            throw new Error("The parameter 'roleId' must be defined.");
        url_ = url_.replace("{roleId}", encodeURIComponent("" + roleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processDeleteRole(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getUsersInRole(roleName: string): Observable<UserRoleInfoDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Roles/{roleName}/users";
        if (roleName === undefined || roleName === null)
            throw new Error("The parameter 'roleName' must be defined.");
        url_ = url_.replace("{roleName}", encodeURIComponent("" + roleName));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsersInRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsersInRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserRoleInfoDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserRoleInfoDtoIEnumerableApiResponse>;
        }));
    }

    protected processGetUsersInRole(response: HttpResponseBase): Observable<UserRoleInfoDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserRoleInfoDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getPublicData(): Observable<ObjectApiResponse> {
        let url_ = this.baseUrl + "/api/Sample/public";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPublicData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPublicData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResponse>;
        }));
    }

    protected processGetPublicData(response: HttpResponseBase): Observable<ObjectApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getData(): Observable<ObjectApiResponse> {
        let url_ = this.baseUrl + "/api/Sample/data";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResponse>;
        }));
    }

    protected processGetData(response: HttpResponseBase): Observable<ObjectApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createData(body: any | undefined): Observable<ObjectApiResponse> {
        let url_ = this.baseUrl + "/api/Sample/data";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResponse>;
        }));
    }

    protected processCreateData(response: HttpResponseBase): Observable<ObjectApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getAdminData(): Observable<ObjectApiResponse> {
        let url_ = this.baseUrl + "/api/Sample/admin";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAdminData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAdminData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResponse>;
        }));
    }

    protected processGetAdminData(response: HttpResponseBase): Observable<ObjectApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getUserData(userId: string): Observable<ObjectApiResponse> {
        let url_ = this.baseUrl + "/api/Sample/users/{userId}/data";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResponse>;
        }));
    }

    protected processGetUserData(response: HttpResponseBase): Observable<ObjectApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getInternalData(): Observable<ObjectApiResponse> {
        let url_ = this.baseUrl + "/api/Sample/internal";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInternalData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInternalData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResponse>;
        }));
    }

    protected processGetInternalData(response: HttpResponseBase): Observable<ObjectApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getCustomData(): Observable<ObjectApiResponse> {
        let url_ = this.baseUrl + "/api/Sample/custom";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResponse>;
        }));
    }

    protected processGetCustomData(response: HttpResponseBase): Observable<ObjectApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getDataWithManualAuth(): Observable<ObjectApiResponse> {
        let url_ = this.baseUrl + "/api/Sample/manual-auth";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDataWithManualAuth(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDataWithManualAuth(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResponse>;
        }));
    }

    protected processGetDataWithManualAuth(response: HttpResponseBase): Observable<ObjectApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @param mappingId (optional) 
     * @param status (optional) 
     * @param errorCategory (optional) 
     * @param dateFrom (optional) 
     * @param dateTo (optional) 
     * @param sellerName (optional) 
     * @return OK
     */
    getScraperLogs(page: number | undefined, pageSize: number | undefined, mappingId: string | undefined, status: string | undefined, errorCategory: string | undefined, dateFrom: Date | undefined, dateTo: Date | undefined, sellerName: string | undefined): Observable<ScraperRunLogSummaryDtoPagedResultDtoApiResponse> {
        let url_ = this.baseUrl + "/api/scraper-logs?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (mappingId === null)
            throw new Error("The parameter 'mappingId' cannot be null.");
        else if (mappingId !== undefined)
            url_ += "mappingId=" + encodeURIComponent("" + mappingId) + "&";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        if (errorCategory === null)
            throw new Error("The parameter 'errorCategory' cannot be null.");
        else if (errorCategory !== undefined)
            url_ += "errorCategory=" + encodeURIComponent("" + errorCategory) + "&";
        if (dateFrom === null)
            throw new Error("The parameter 'dateFrom' cannot be null.");
        else if (dateFrom !== undefined)
            url_ += "dateFrom=" + encodeURIComponent(dateFrom ? "" + dateFrom.toISOString() : "") + "&";
        if (dateTo === null)
            throw new Error("The parameter 'dateTo' cannot be null.");
        else if (dateTo !== undefined)
            url_ += "dateTo=" + encodeURIComponent(dateTo ? "" + dateTo.toISOString() : "") + "&";
        if (sellerName === null)
            throw new Error("The parameter 'sellerName' cannot be null.");
        else if (sellerName !== undefined)
            url_ += "sellerName=" + encodeURIComponent("" + sellerName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetScraperLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetScraperLogs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ScraperRunLogSummaryDtoPagedResultDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ScraperRunLogSummaryDtoPagedResultDtoApiResponse>;
        }));
    }

    protected processGetScraperLogs(response: HttpResponseBase): Observable<ScraperRunLogSummaryDtoPagedResultDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ScraperRunLogSummaryDtoPagedResultDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getScraperRunById(runId: string): Observable<ScraperRunLogDtoApiResponse> {
        let url_ = this.baseUrl + "/api/scraper-logs/{runId}";
        if (runId === undefined || runId === null)
            throw new Error("The parameter 'runId' must be defined.");
        url_ = url_.replace("{runId}", encodeURIComponent("" + runId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetScraperRunById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetScraperRunById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ScraperRunLogDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ScraperRunLogDtoApiResponse>;
        }));
    }

    protected processGetScraperRunById(response: HttpResponseBase): Observable<ScraperRunLogDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ScraperRunLogDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return OK
     */
    getScraperLogsByMapping(mappingId: string, page: number | undefined, pageSize: number | undefined): Observable<ScraperRunLogSummaryDtoPagedResultDtoApiResponse> {
        let url_ = this.baseUrl + "/api/scraper-logs/mapping/{mappingId}?";
        if (mappingId === undefined || mappingId === null)
            throw new Error("The parameter 'mappingId' must be defined.");
        url_ = url_.replace("{mappingId}", encodeURIComponent("" + mappingId));
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetScraperLogsByMapping(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetScraperLogsByMapping(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ScraperRunLogSummaryDtoPagedResultDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ScraperRunLogSummaryDtoPagedResultDtoApiResponse>;
        }));
    }

    protected processGetScraperLogsByMapping(response: HttpResponseBase): Observable<ScraperRunLogSummaryDtoPagedResultDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ScraperRunLogSummaryDtoPagedResultDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param count (optional) 
     * @return OK
     */
    getRecentFailures(count: number | undefined): Observable<ScraperRunLogSummaryDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/scraper-logs/recent-failures?";
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecentFailures(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecentFailures(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ScraperRunLogSummaryDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ScraperRunLogSummaryDtoIEnumerableApiResponse>;
        }));
    }

    protected processGetRecentFailures(response: HttpResponseBase): Observable<ScraperRunLogSummaryDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ScraperRunLogSummaryDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param count (optional) 
     * @return OK
     */
    getRecentRunsForMapping(mappingId: string, count: number | undefined): Observable<ScraperRunLogSummaryDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/scraper-logs/mapping/{mappingId}/recent?";
        if (mappingId === undefined || mappingId === null)
            throw new Error("The parameter 'mappingId' must be defined.");
        url_ = url_.replace("{mappingId}", encodeURIComponent("" + mappingId));
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecentRunsForMapping(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecentRunsForMapping(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ScraperRunLogSummaryDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ScraperRunLogSummaryDtoIEnumerableApiResponse>;
        }));
    }

    protected processGetRecentRunsForMapping(response: HttpResponseBase): Observable<ScraperRunLogSummaryDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ScraperRunLogSummaryDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param dateFrom (optional) 
     * @param dateTo (optional) 
     * @param mappingId (optional) 
     * @return OK
     */
    getStatistics(dateFrom: Date | undefined, dateTo: Date | undefined, mappingId: string | undefined): Observable<ScraperRunStatisticsDtoApiResponse> {
        let url_ = this.baseUrl + "/api/scraper-logs/statistics?";
        if (dateFrom === null)
            throw new Error("The parameter 'dateFrom' cannot be null.");
        else if (dateFrom !== undefined)
            url_ += "dateFrom=" + encodeURIComponent(dateFrom ? "" + dateFrom.toISOString() : "") + "&";
        if (dateTo === null)
            throw new Error("The parameter 'dateTo' cannot be null.");
        else if (dateTo !== undefined)
            url_ += "dateTo=" + encodeURIComponent(dateTo ? "" + dateTo.toISOString() : "") + "&";
        if (mappingId === null)
            throw new Error("The parameter 'mappingId' cannot be null.");
        else if (mappingId !== undefined)
            url_ += "mappingId=" + encodeURIComponent("" + mappingId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStatistics(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStatistics(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ScraperRunStatisticsDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ScraperRunStatisticsDtoApiResponse>;
        }));
    }

    protected processGetStatistics(response: HttpResponseBase): Observable<ScraperRunStatisticsDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ScraperRunStatisticsDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getRetryChain(runId: string): Observable<ScraperRunLogDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/scraper-logs/{runId}/retry-chain";
        if (runId === undefined || runId === null)
            throw new Error("The parameter 'runId' must be defined.");
        url_ = url_.replace("{runId}", encodeURIComponent("" + runId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRetryChain(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRetryChain(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ScraperRunLogDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ScraperRunLogDtoIEnumerableApiResponse>;
        }));
    }

    protected processGetRetryChain(response: HttpResponseBase): Observable<ScraperRunLogDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ScraperRunLogDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param dateFrom (optional) 
     * @param dateTo (optional) 
     * @return OK
     */
    getPerformanceMetrics(dateFrom: Date | undefined, dateTo: Date | undefined): Observable<SellerPerformanceMetricDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/scraper-logs/performance-metrics?";
        if (dateFrom === null)
            throw new Error("The parameter 'dateFrom' cannot be null.");
        else if (dateFrom !== undefined)
            url_ += "dateFrom=" + encodeURIComponent(dateFrom ? "" + dateFrom.toISOString() : "") + "&";
        if (dateTo === null)
            throw new Error("The parameter 'dateTo' cannot be null.");
        else if (dateTo !== undefined)
            url_ += "dateTo=" + encodeURIComponent(dateTo ? "" + dateTo.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPerformanceMetrics(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPerformanceMetrics(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SellerPerformanceMetricDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SellerPerformanceMetricDtoIEnumerableApiResponse>;
        }));
    }

    protected processGetPerformanceMetrics(response: HttpResponseBase): Observable<SellerPerformanceMetricDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SellerPerformanceMetricDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getInProgressRuns(): Observable<ScraperRunLogSummaryDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/scraper-logs/in-progress";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInProgressRuns(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInProgressRuns(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ScraperRunLogSummaryDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ScraperRunLogSummaryDtoIEnumerableApiResponse>;
        }));
    }

    protected processGetInProgressRuns(response: HttpResponseBase): Observable<ScraperRunLogSummaryDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ScraperRunLogSummaryDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param daysToKeep (optional) 
     * @return OK
     */
    cleanupOldLogs(daysToKeep: number | undefined): Observable<Int32ApiResponse> {
        let url_ = this.baseUrl + "/api/scraper-logs/cleanup?";
        if (daysToKeep === null)
            throw new Error("The parameter 'daysToKeep' cannot be null.");
        else if (daysToKeep !== undefined)
            url_ += "daysToKeep=" + encodeURIComponent("" + daysToKeep) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCleanupOldLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCleanupOldLogs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Int32ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Int32ApiResponse>;
        }));
    }

    protected processCleanupOldLogs(response: HttpResponseBase): Observable<Int32ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Int32ApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getAllSiteConfigs(): Observable<ScraperSiteConfigurationDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/site-configs/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSiteConfigs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSiteConfigs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ScraperSiteConfigurationDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ScraperSiteConfigurationDtoIEnumerableApiResponse>;
        }));
    }

    protected processGetAllSiteConfigs(response: HttpResponseBase): Observable<ScraperSiteConfigurationDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ScraperSiteConfigurationDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createSiteConfig(body: CreateScraperSiteConfigurationDto | undefined): Observable<ScraperSiteConfigurationDtoApiResponse> {
        let url_ = this.baseUrl + "/api/site-configs";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateSiteConfig(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateSiteConfig(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ScraperSiteConfigurationDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ScraperSiteConfigurationDtoApiResponse>;
        }));
    }

    protected processCreateSiteConfig(response: HttpResponseBase): Observable<ScraperSiteConfigurationDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ScraperSiteConfigurationDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param domain (optional) 
     * @return OK
     */
    getSiteConfigByDomain(domain: string | undefined): Observable<ScraperSiteConfigurationDtoApiResponse> {
        let url_ = this.baseUrl + "/api/site-configs?";
        if (domain === null)
            throw new Error("The parameter 'domain' cannot be null.");
        else if (domain !== undefined)
            url_ += "domain=" + encodeURIComponent("" + domain) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSiteConfigByDomain(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSiteConfigByDomain(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ScraperSiteConfigurationDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ScraperSiteConfigurationDtoApiResponse>;
        }));
    }

    protected processGetSiteConfigByDomain(response: HttpResponseBase): Observable<ScraperSiteConfigurationDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ScraperSiteConfigurationDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getSiteConfig(siteConfigId: string): Observable<ScraperSiteConfigurationDtoApiResponse> {
        let url_ = this.baseUrl + "/api/site-configs/{siteConfigId}";
        if (siteConfigId === undefined || siteConfigId === null)
            throw new Error("The parameter 'siteConfigId' must be defined.");
        url_ = url_.replace("{siteConfigId}", encodeURIComponent("" + siteConfigId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSiteConfig(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSiteConfig(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ScraperSiteConfigurationDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ScraperSiteConfigurationDtoApiResponse>;
        }));
    }

    protected processGetSiteConfig(response: HttpResponseBase): Observable<ScraperSiteConfigurationDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ScraperSiteConfigurationDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    updateSiteConfig(siteConfigId: string, body: UpdateScraperSiteConfigurationDto | undefined): Observable<ScraperSiteConfigurationDtoApiResponse> {
        let url_ = this.baseUrl + "/api/site-configs/{siteConfigId}";
        if (siteConfigId === undefined || siteConfigId === null)
            throw new Error("The parameter 'siteConfigId' must be defined.");
        url_ = url_.replace("{siteConfigId}", encodeURIComponent("" + siteConfigId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSiteConfig(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSiteConfig(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ScraperSiteConfigurationDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ScraperSiteConfigurationDtoApiResponse>;
        }));
    }

    protected processUpdateSiteConfig(response: HttpResponseBase): Observable<ScraperSiteConfigurationDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ScraperSiteConfigurationDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    deleteSiteConfig(siteConfigId: string): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/api/site-configs/{siteConfigId}";
        if (siteConfigId === undefined || siteConfigId === null)
            throw new Error("The parameter 'siteConfigId' must be defined.");
        url_ = url_.replace("{siteConfigId}", encodeURIComponent("" + siteConfigId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteSiteConfig(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteSiteConfig(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processDeleteSiteConfig(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class AlertRuleDto implements IAlertRuleDto {
    alertRuleId?: string;
    userId?: string;
    canonicalProductId?: string;
    conditionType?: string | undefined;
    thresholdValue?: number | undefined;
    percentageValue?: number | undefined;
    specificSellerName?: string | undefined;
    notificationFrequencyMinutes?: number;
    isActive?: boolean;
    lastNotifiedAt?: Date | undefined;
    createdAt?: Date;
    updatedAt?: Date;
    ruleDescription?: string | undefined;
    user?: UserDto;
    product?: ProductDto;

    constructor(data?: IAlertRuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alertRuleId = _data["alertRuleId"];
            this.userId = _data["userId"];
            this.canonicalProductId = _data["canonicalProductId"];
            this.conditionType = _data["conditionType"];
            this.thresholdValue = _data["thresholdValue"];
            this.percentageValue = _data["percentageValue"];
            this.specificSellerName = _data["specificSellerName"];
            this.notificationFrequencyMinutes = _data["notificationFrequencyMinutes"];
            this.isActive = _data["isActive"];
            this.lastNotifiedAt = _data["lastNotifiedAt"] ? new Date(_data["lastNotifiedAt"].toString()) : <any>undefined;
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.ruleDescription = _data["ruleDescription"];
            this.user = _data["user"] ? UserDto.fromJS(_data["user"]) : <any>undefined;
            this.product = _data["product"] ? ProductDto.fromJS(_data["product"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AlertRuleDto {
        data = typeof data === 'object' ? data : {};
        let result = new AlertRuleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["alertRuleId"] = this.alertRuleId;
        data["userId"] = this.userId;
        data["canonicalProductId"] = this.canonicalProductId;
        data["conditionType"] = this.conditionType;
        data["thresholdValue"] = this.thresholdValue;
        data["percentageValue"] = this.percentageValue;
        data["specificSellerName"] = this.specificSellerName;
        data["notificationFrequencyMinutes"] = this.notificationFrequencyMinutes;
        data["isActive"] = this.isActive;
        data["lastNotifiedAt"] = this.lastNotifiedAt ? this.lastNotifiedAt.toISOString() : <any>undefined;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["ruleDescription"] = this.ruleDescription;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        return data;
    }
}

export interface IAlertRuleDto {
    alertRuleId?: string;
    userId?: string;
    canonicalProductId?: string;
    conditionType?: string | undefined;
    thresholdValue?: number | undefined;
    percentageValue?: number | undefined;
    specificSellerName?: string | undefined;
    notificationFrequencyMinutes?: number;
    isActive?: boolean;
    lastNotifiedAt?: Date | undefined;
    createdAt?: Date;
    updatedAt?: Date;
    ruleDescription?: string | undefined;
    user?: UserDto;
    product?: ProductDto;
}

export class AlertRuleDtoApiResponse implements IAlertRuleDtoApiResponse {
    success?: boolean;
    data?: AlertRuleDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IAlertRuleDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"] ? AlertRuleDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): AlertRuleDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AlertRuleDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IAlertRuleDtoApiResponse {
    success?: boolean;
    data?: AlertRuleDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class AlertRuleDtoIEnumerableApiResponse implements IAlertRuleDtoIEnumerableApiResponse {
    success?: boolean;
    data?: AlertRuleDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IAlertRuleDtoIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(AlertRuleDto.fromJS(item));
            }
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): AlertRuleDtoIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AlertRuleDtoIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : <any>undefined);
        }
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IAlertRuleDtoIEnumerableApiResponse {
    success?: boolean;
    data?: AlertRuleDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class AlertRuleDtoPagedResponse implements IAlertRuleDtoPagedResponse {
    success?: boolean;
    data?: AlertRuleDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
    pagination?: PaginationMeta;

    constructor(data?: IAlertRuleDtoPagedResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(AlertRuleDto.fromJS(item));
            }
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
            this.pagination = _data["pagination"] ? PaginationMeta.fromJS(_data["pagination"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AlertRuleDtoPagedResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AlertRuleDtoPagedResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : <any>undefined);
        }
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        data["pagination"] = this.pagination ? this.pagination.toJSON() : <any>undefined;
        return data;
    }
}

export interface IAlertRuleDtoPagedResponse {
    success?: boolean;
    data?: AlertRuleDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
    pagination?: PaginationMeta;
}

export class ApiResponse implements IApiResponse {
    success?: boolean;
    data?: any | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"];
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): ApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IApiResponse {
    success?: boolean;
    data?: any | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class BooleanApiResponse implements IBooleanApiResponse {
    success?: boolean;
    data?: boolean;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IBooleanApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"];
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): BooleanApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new BooleanApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IBooleanApiResponse {
    success?: boolean;
    data?: boolean;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class CategoryDto implements ICategoryDto {
    categoryId?: string;
    name?: string | undefined;
    slug?: string | undefined;
    description?: string | undefined;
    createdAt?: Date;
    updatedAt?: Date;

    constructor(data?: ICategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.categoryId = _data["categoryId"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.description = _data["description"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["categoryId"] = this.categoryId;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["description"] = this.description;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        return data;
    }
}

export interface ICategoryDto {
    categoryId?: string;
    name?: string | undefined;
    slug?: string | undefined;
    description?: string | undefined;
    createdAt?: Date;
    updatedAt?: Date;
}

export class CategoryDtoApiResponse implements ICategoryDtoApiResponse {
    success?: boolean;
    data?: CategoryDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: ICategoryDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"] ? CategoryDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): CategoryDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface ICategoryDtoApiResponse {
    success?: boolean;
    data?: CategoryDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class CategoryDtoIEnumerableApiResponse implements ICategoryDtoIEnumerableApiResponse {
    success?: boolean;
    data?: CategoryDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: ICategoryDtoIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(CategoryDto.fromJS(item));
            }
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): CategoryDtoIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryDtoIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : <any>undefined);
        }
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface ICategoryDtoIEnumerableApiResponse {
    success?: boolean;
    data?: CategoryDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class CreateAlertRuleDto implements ICreateAlertRuleDto {
    canonicalProductId!: string;
    conditionType!: string;
    thresholdValue?: number | undefined;
    percentageValue?: number | undefined;
    specificSellerName?: string | undefined;
    notificationFrequencyMinutes?: number;

    constructor(data?: ICreateAlertRuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.canonicalProductId = _data["canonicalProductId"];
            this.conditionType = _data["conditionType"];
            this.thresholdValue = _data["thresholdValue"];
            this.percentageValue = _data["percentageValue"];
            this.specificSellerName = _data["specificSellerName"];
            this.notificationFrequencyMinutes = _data["notificationFrequencyMinutes"];
        }
    }

    static fromJS(data: any): CreateAlertRuleDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAlertRuleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canonicalProductId"] = this.canonicalProductId;
        data["conditionType"] = this.conditionType;
        data["thresholdValue"] = this.thresholdValue;
        data["percentageValue"] = this.percentageValue;
        data["specificSellerName"] = this.specificSellerName;
        data["notificationFrequencyMinutes"] = this.notificationFrequencyMinutes;
        return data;
    }
}

export interface ICreateAlertRuleDto {
    canonicalProductId: string;
    conditionType: string;
    thresholdValue?: number | undefined;
    percentageValue?: number | undefined;
    specificSellerName?: string | undefined;
    notificationFrequencyMinutes?: number;
}

export class CreateCategoryDto implements ICreateCategoryDto {
    name!: string;
    slug?: string | undefined;
    description?: string | undefined;

    constructor(data?: ICreateCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): CreateCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["description"] = this.description;
        return data;
    }
}

export interface ICreateCategoryDto {
    name: string;
    slug?: string | undefined;
    description?: string | undefined;
}

export class CreatePermissionDto implements ICreatePermissionDto {
    name!: string;
    description?: string | undefined;
    category!: string;

    constructor(data?: ICreatePermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.category = _data["category"];
        }
    }

    static fromJS(data: any): CreatePermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["category"] = this.category;
        return data;
    }
}

export interface ICreatePermissionDto {
    name: string;
    description?: string | undefined;
    category: string;
}

export class CreateProductDto implements ICreateProductDto {
    name!: string;
    manufacturer?: string | undefined;
    modelNumber?: string | undefined;
    sku?: string | undefined;
    categoryId!: string;
    description?: string | undefined;
    specifications?: { [key: string]: any; } | undefined;

    constructor(data?: ICreateProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.manufacturer = _data["manufacturer"];
            this.modelNumber = _data["modelNumber"];
            this.sku = _data["sku"];
            this.categoryId = _data["categoryId"];
            this.description = _data["description"];
            if (_data["specifications"]) {
                this.specifications = {} as any;
                for (let key in _data["specifications"]) {
                    if (_data["specifications"].hasOwnProperty(key))
                        (<any>this.specifications)![key] = _data["specifications"][key];
                }
            }
        }
    }

    static fromJS(data: any): CreateProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["manufacturer"] = this.manufacturer;
        data["modelNumber"] = this.modelNumber;
        data["sku"] = this.sku;
        data["categoryId"] = this.categoryId;
        data["description"] = this.description;
        if (this.specifications) {
            data["specifications"] = {};
            for (let key in this.specifications) {
                if (this.specifications.hasOwnProperty(key))
                    (<any>data["specifications"])[key] = (<any>this.specifications)[key];
            }
        }
        return data;
    }
}

export interface ICreateProductDto {
    name: string;
    manufacturer?: string | undefined;
    modelNumber?: string | undefined;
    sku?: string | undefined;
    categoryId: string;
    description?: string | undefined;
    specifications?: { [key: string]: any; } | undefined;
}

export class CreateProductSellerMappingDto implements ICreateProductSellerMappingDto {
    canonicalProductId!: string;
    sellerName!: string;
    exactProductUrl!: string;
    isActiveForScraping?: boolean;
    scrapingFrequencyOverride?: string | undefined;
    siteConfigId?: string | undefined;

    constructor(data?: ICreateProductSellerMappingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.canonicalProductId = _data["canonicalProductId"];
            this.sellerName = _data["sellerName"];
            this.exactProductUrl = _data["exactProductUrl"];
            this.isActiveForScraping = _data["isActiveForScraping"];
            this.scrapingFrequencyOverride = _data["scrapingFrequencyOverride"];
            this.siteConfigId = _data["siteConfigId"];
        }
    }

    static fromJS(data: any): CreateProductSellerMappingDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductSellerMappingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canonicalProductId"] = this.canonicalProductId;
        data["sellerName"] = this.sellerName;
        data["exactProductUrl"] = this.exactProductUrl;
        data["isActiveForScraping"] = this.isActiveForScraping;
        data["scrapingFrequencyOverride"] = this.scrapingFrequencyOverride;
        data["siteConfigId"] = this.siteConfigId;
        return data;
    }
}

export interface ICreateProductSellerMappingDto {
    canonicalProductId: string;
    sellerName: string;
    exactProductUrl: string;
    isActiveForScraping?: boolean;
    scrapingFrequencyOverride?: string | undefined;
    siteConfigId?: string | undefined;
}

export class CreateRoleDto implements ICreateRoleDto {
    name?: string | undefined;

    constructor(data?: ICreateRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CreateRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }
}

export interface ICreateRoleDto {
    name?: string | undefined;
}

export class CreateScraperSiteConfigurationDto implements ICreateScraperSiteConfigurationDto {
    siteDomain!: string;
    productNameSelector!: string;
    priceSelector!: string;
    stockSelector!: string;
    sellerNameOnPageSelector?: string | undefined;
    defaultUserAgent?: string | undefined;
    additionalHeaders?: { [key: string]: string; } | undefined;
    isEnabled?: boolean;

    constructor(data?: ICreateScraperSiteConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.siteDomain = _data["siteDomain"];
            this.productNameSelector = _data["productNameSelector"];
            this.priceSelector = _data["priceSelector"];
            this.stockSelector = _data["stockSelector"];
            this.sellerNameOnPageSelector = _data["sellerNameOnPageSelector"];
            this.defaultUserAgent = _data["defaultUserAgent"];
            if (_data["additionalHeaders"]) {
                this.additionalHeaders = {} as any;
                for (let key in _data["additionalHeaders"]) {
                    if (_data["additionalHeaders"].hasOwnProperty(key))
                        (<any>this.additionalHeaders)![key] = _data["additionalHeaders"][key];
                }
            }
            this.isEnabled = _data["isEnabled"];
        }
    }

    static fromJS(data: any): CreateScraperSiteConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateScraperSiteConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["siteDomain"] = this.siteDomain;
        data["productNameSelector"] = this.productNameSelector;
        data["priceSelector"] = this.priceSelector;
        data["stockSelector"] = this.stockSelector;
        data["sellerNameOnPageSelector"] = this.sellerNameOnPageSelector;
        data["defaultUserAgent"] = this.defaultUserAgent;
        if (this.additionalHeaders) {
            data["additionalHeaders"] = {};
            for (let key in this.additionalHeaders) {
                if (this.additionalHeaders.hasOwnProperty(key))
                    (<any>data["additionalHeaders"])[key] = (<any>this.additionalHeaders)[key];
            }
        }
        data["isEnabled"] = this.isEnabled;
        return data;
    }
}

export interface ICreateScraperSiteConfigurationDto {
    siteDomain: string;
    productNameSelector: string;
    priceSelector: string;
    stockSelector: string;
    sellerNameOnPageSelector?: string | undefined;
    defaultUserAgent?: string | undefined;
    additionalHeaders?: { [key: string]: string; } | undefined;
    isEnabled?: boolean;
}

export class CreateUserDto implements ICreateUserDto {
    email!: string;
    password!: string;
    firstName?: string | undefined;
    lastName?: string | undefined;
    roles?: string[] | undefined;

    constructor(data?: ICreateUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data;
    }
}

export interface ICreateUserDto {
    email: string;
    password: string;
    firstName?: string | undefined;
    lastName?: string | undefined;
    roles?: string[] | undefined;
}

export class CurrentPriceDto implements ICurrentPriceDto {
    sellerName?: string | undefined;
    price?: number;
    stockStatus?: string | undefined;
    sourceUrl?: string | undefined;
    lastUpdated?: Date;
    scrapedProductNameOnPage?: string | undefined;

    constructor(data?: ICurrentPriceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sellerName = _data["sellerName"];
            this.price = _data["price"];
            this.stockStatus = _data["stockStatus"];
            this.sourceUrl = _data["sourceUrl"];
            this.lastUpdated = _data["lastUpdated"] ? new Date(_data["lastUpdated"].toString()) : <any>undefined;
            this.scrapedProductNameOnPage = _data["scrapedProductNameOnPage"];
        }
    }

    static fromJS(data: any): CurrentPriceDto {
        data = typeof data === 'object' ? data : {};
        let result = new CurrentPriceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sellerName"] = this.sellerName;
        data["price"] = this.price;
        data["stockStatus"] = this.stockStatus;
        data["sourceUrl"] = this.sourceUrl;
        data["lastUpdated"] = this.lastUpdated ? this.lastUpdated.toISOString() : <any>undefined;
        data["scrapedProductNameOnPage"] = this.scrapedProductNameOnPage;
        return data;
    }
}

export interface ICurrentPriceDto {
    sellerName?: string | undefined;
    price?: number;
    stockStatus?: string | undefined;
    sourceUrl?: string | undefined;
    lastUpdated?: Date;
    scrapedProductNameOnPage?: string | undefined;
}

export class CurrentPriceDtoIEnumerableApiResponse implements ICurrentPriceDtoIEnumerableApiResponse {
    success?: boolean;
    data?: CurrentPriceDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: ICurrentPriceDtoIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(CurrentPriceDto.fromJS(item));
            }
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): CurrentPriceDtoIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CurrentPriceDtoIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : <any>undefined);
        }
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface ICurrentPriceDtoIEnumerableApiResponse {
    success?: boolean;
    data?: CurrentPriceDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class DashboardStatsDto implements IDashboardStatsDto {
    totalProducts?: number;
    totalCategories?: number;
    activeMappings?: number;
    activeAlerts?: number;
    totalUsers?: number | undefined;

    constructor(data?: IDashboardStatsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalProducts = _data["totalProducts"];
            this.totalCategories = _data["totalCategories"];
            this.activeMappings = _data["activeMappings"];
            this.activeAlerts = _data["activeAlerts"];
            this.totalUsers = _data["totalUsers"];
        }
    }

    static fromJS(data: any): DashboardStatsDto {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardStatsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalProducts"] = this.totalProducts;
        data["totalCategories"] = this.totalCategories;
        data["activeMappings"] = this.activeMappings;
        data["activeAlerts"] = this.activeAlerts;
        data["totalUsers"] = this.totalUsers;
        return data;
    }
}

export interface IDashboardStatsDto {
    totalProducts?: number;
    totalCategories?: number;
    activeMappings?: number;
    activeAlerts?: number;
    totalUsers?: number | undefined;
}

export class DashboardStatsDtoApiResponse implements IDashboardStatsDtoApiResponse {
    success?: boolean;
    data?: DashboardStatsDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IDashboardStatsDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"] ? DashboardStatsDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): DashboardStatsDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardStatsDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IDashboardStatsDtoApiResponse {
    success?: boolean;
    data?: DashboardStatsDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class Int32ApiResponse implements IInt32ApiResponse {
    success?: boolean;
    data?: number;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IInt32ApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"];
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): Int32ApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new Int32ApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IInt32ApiResponse {
    success?: boolean;
    data?: number;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class LoginResponseDto implements ILoginResponseDto {
    token?: string | undefined;
    userId?: string;
    email?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    roles?: string[] | undefined;

    constructor(data?: ILoginResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
            this.userId = _data["userId"];
            this.email = _data["email"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
        }
    }

    static fromJS(data: any): LoginResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new LoginResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        data["userId"] = this.userId;
        data["email"] = this.email;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data;
    }
}

export interface ILoginResponseDto {
    token?: string | undefined;
    userId?: string;
    email?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    roles?: string[] | undefined;
}

export class LoginResponseDtoApiResponse implements ILoginResponseDtoApiResponse {
    success?: boolean;
    data?: LoginResponseDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: ILoginResponseDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"] ? LoginResponseDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): LoginResponseDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new LoginResponseDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface ILoginResponseDtoApiResponse {
    success?: boolean;
    data?: LoginResponseDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class LoginUserDto implements ILoginUserDto {
    email!: string;
    password!: string;

    constructor(data?: ILoginUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): LoginUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new LoginUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        return data;
    }
}

export interface ILoginUserDto {
    email: string;
    password: string;
}

export class ObjectApiResponse implements IObjectApiResponse {
    success?: boolean;
    data?: any | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IObjectApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"];
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): ObjectApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ObjectApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IObjectApiResponse {
    success?: boolean;
    data?: any | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class ObjectPagedResponse implements IObjectPagedResponse {
    success?: boolean;
    data?: any[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
    pagination?: PaginationMeta;

    constructor(data?: IObjectPagedResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(item);
            }
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
            this.pagination = _data["pagination"] ? PaginationMeta.fromJS(_data["pagination"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ObjectPagedResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ObjectPagedResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item);
        }
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        data["pagination"] = this.pagination ? this.pagination.toJSON() : <any>undefined;
        return data;
    }
}

export interface IObjectPagedResponse {
    success?: boolean;
    data?: any[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
    pagination?: PaginationMeta;
}

export class PaginationMeta implements IPaginationMeta {
    pageNumber?: number;
    pageSize?: number;
    totalCount?: number;
    readonly totalPages?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;
    readonly firstItemOnPage?: number;
    readonly lastItemOnPage?: number;

    constructor(data?: IPaginationMeta) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
            this.totalCount = _data["totalCount"];
            (<any>this).totalPages = _data["totalPages"];
            (<any>this).hasPreviousPage = _data["hasPreviousPage"];
            (<any>this).hasNextPage = _data["hasNextPage"];
            (<any>this).firstItemOnPage = _data["firstItemOnPage"];
            (<any>this).lastItemOnPage = _data["lastItemOnPage"];
        }
    }

    static fromJS(data: any): PaginationMeta {
        data = typeof data === 'object' ? data : {};
        let result = new PaginationMeta();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        data["totalCount"] = this.totalCount;
        data["totalPages"] = this.totalPages;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        data["firstItemOnPage"] = this.firstItemOnPage;
        data["lastItemOnPage"] = this.lastItemOnPage;
        return data;
    }
}

export interface IPaginationMeta {
    pageNumber?: number;
    pageSize?: number;
    totalCount?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    firstItemOnPage?: number;
    lastItemOnPage?: number;
}

export class PermissionDto implements IPermissionDto {
    permissionId?: string;
    name?: string | undefined;
    description?: string | undefined;
    category?: string | undefined;
    createdAt?: Date;
    updatedAt?: Date;

    constructor(data?: IPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.permissionId = _data["permissionId"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.category = _data["category"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): PermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["permissionId"] = this.permissionId;
        data["name"] = this.name;
        data["description"] = this.description;
        data["category"] = this.category;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        return data;
    }
}

export interface IPermissionDto {
    permissionId?: string;
    name?: string | undefined;
    description?: string | undefined;
    category?: string | undefined;
    createdAt?: Date;
    updatedAt?: Date;
}

export class PermissionDtoApiResponse implements IPermissionDtoApiResponse {
    success?: boolean;
    data?: PermissionDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IPermissionDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"] ? PermissionDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): PermissionDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IPermissionDtoApiResponse {
    success?: boolean;
    data?: PermissionDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class PermissionDtoIEnumerableApiResponse implements IPermissionDtoIEnumerableApiResponse {
    success?: boolean;
    data?: PermissionDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IPermissionDtoIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(PermissionDto.fromJS(item));
            }
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): PermissionDtoIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDtoIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : <any>undefined);
        }
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IPermissionDtoIEnumerableApiResponse {
    success?: boolean;
    data?: PermissionDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class PriceHistoryDto implements IPriceHistoryDto {
    timestamp?: Date;
    price?: number;
    stockStatus?: string | undefined;
    sourceUrl?: string | undefined;
    scrapedProductNameOnPage?: string | undefined;

    constructor(data?: IPriceHistoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.price = _data["price"];
            this.stockStatus = _data["stockStatus"];
            this.sourceUrl = _data["sourceUrl"];
            this.scrapedProductNameOnPage = _data["scrapedProductNameOnPage"];
        }
    }

    static fromJS(data: any): PriceHistoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new PriceHistoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["price"] = this.price;
        data["stockStatus"] = this.stockStatus;
        data["sourceUrl"] = this.sourceUrl;
        data["scrapedProductNameOnPage"] = this.scrapedProductNameOnPage;
        return data;
    }
}

export interface IPriceHistoryDto {
    timestamp?: Date;
    price?: number;
    stockStatus?: string | undefined;
    sourceUrl?: string | undefined;
    scrapedProductNameOnPage?: string | undefined;
}

export class PriceHistoryDtoIEnumerableApiResponse implements IPriceHistoryDtoIEnumerableApiResponse {
    success?: boolean;
    data?: PriceHistoryDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IPriceHistoryDtoIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(PriceHistoryDto.fromJS(item));
            }
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): PriceHistoryDtoIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PriceHistoryDtoIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : <any>undefined);
        }
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IPriceHistoryDtoIEnumerableApiResponse {
    success?: boolean;
    data?: PriceHistoryDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class ProductDto implements IProductDto {
    productId?: string;
    name?: string | undefined;
    manufacturer?: string | undefined;
    modelNumber?: string | undefined;
    sku?: string | undefined;
    categoryId?: string;
    description?: string | undefined;
    specifications?: { [key: string]: any; } | undefined;
    isActive?: boolean;
    createdAt?: Date;
    updatedAt?: Date;
    category?: CategoryDto;

    constructor(data?: IProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.name = _data["name"];
            this.manufacturer = _data["manufacturer"];
            this.modelNumber = _data["modelNumber"];
            this.sku = _data["sku"];
            this.categoryId = _data["categoryId"];
            this.description = _data["description"];
            if (_data["specifications"]) {
                this.specifications = {} as any;
                for (let key in _data["specifications"]) {
                    if (_data["specifications"].hasOwnProperty(key))
                        (<any>this.specifications)![key] = _data["specifications"][key];
                }
            }
            this.isActive = _data["isActive"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.category = _data["category"] ? CategoryDto.fromJS(_data["category"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["name"] = this.name;
        data["manufacturer"] = this.manufacturer;
        data["modelNumber"] = this.modelNumber;
        data["sku"] = this.sku;
        data["categoryId"] = this.categoryId;
        data["description"] = this.description;
        if (this.specifications) {
            data["specifications"] = {};
            for (let key in this.specifications) {
                if (this.specifications.hasOwnProperty(key))
                    (<any>data["specifications"])[key] = (<any>this.specifications)[key];
            }
        }
        data["isActive"] = this.isActive;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["category"] = this.category ? this.category.toJSON() : <any>undefined;
        return data;
    }
}

export interface IProductDto {
    productId?: string;
    name?: string | undefined;
    manufacturer?: string | undefined;
    modelNumber?: string | undefined;
    sku?: string | undefined;
    categoryId?: string;
    description?: string | undefined;
    specifications?: { [key: string]: any; } | undefined;
    isActive?: boolean;
    createdAt?: Date;
    updatedAt?: Date;
    category?: CategoryDto;
}

export class ProductDtoApiResponse implements IProductDtoApiResponse {
    success?: boolean;
    data?: ProductDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IProductDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"] ? ProductDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): ProductDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ProductDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IProductDtoApiResponse {
    success?: boolean;
    data?: ProductDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class ProductDtoPagedResponse implements IProductDtoPagedResponse {
    success?: boolean;
    data?: ProductDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
    pagination?: PaginationMeta;

    constructor(data?: IProductDtoPagedResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(ProductDto.fromJS(item));
            }
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
            this.pagination = _data["pagination"] ? PaginationMeta.fromJS(_data["pagination"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProductDtoPagedResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ProductDtoPagedResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : <any>undefined);
        }
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        data["pagination"] = this.pagination ? this.pagination.toJSON() : <any>undefined;
        return data;
    }
}

export interface IProductDtoPagedResponse {
    success?: boolean;
    data?: ProductDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
    pagination?: PaginationMeta;
}

export class ProductSellerMappingDto implements IProductSellerMappingDto {
    mappingId?: string;
    canonicalProductId?: string;
    sellerName?: string | undefined;
    exactProductUrl?: string | undefined;
    isActiveForScraping?: boolean;
    scrapingFrequencyOverride?: string | undefined;
    siteConfigId?: string | undefined;
    lastScrapedAt?: Date | undefined;
    nextScrapeAt?: Date | undefined;
    lastScrapeStatus?: string | undefined;
    lastScrapeErrorCode?: string | undefined;
    consecutiveFailureCount?: number;
    createdAt?: Date;
    updatedAt?: Date;
    product?: ProductDto;
    siteConfiguration?: ScraperSiteConfigurationDto;

    constructor(data?: IProductSellerMappingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.mappingId = _data["mappingId"];
            this.canonicalProductId = _data["canonicalProductId"];
            this.sellerName = _data["sellerName"];
            this.exactProductUrl = _data["exactProductUrl"];
            this.isActiveForScraping = _data["isActiveForScraping"];
            this.scrapingFrequencyOverride = _data["scrapingFrequencyOverride"];
            this.siteConfigId = _data["siteConfigId"];
            this.lastScrapedAt = _data["lastScrapedAt"] ? new Date(_data["lastScrapedAt"].toString()) : <any>undefined;
            this.nextScrapeAt = _data["nextScrapeAt"] ? new Date(_data["nextScrapeAt"].toString()) : <any>undefined;
            this.lastScrapeStatus = _data["lastScrapeStatus"];
            this.lastScrapeErrorCode = _data["lastScrapeErrorCode"];
            this.consecutiveFailureCount = _data["consecutiveFailureCount"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.product = _data["product"] ? ProductDto.fromJS(_data["product"]) : <any>undefined;
            this.siteConfiguration = _data["siteConfiguration"] ? ScraperSiteConfigurationDto.fromJS(_data["siteConfiguration"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProductSellerMappingDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductSellerMappingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mappingId"] = this.mappingId;
        data["canonicalProductId"] = this.canonicalProductId;
        data["sellerName"] = this.sellerName;
        data["exactProductUrl"] = this.exactProductUrl;
        data["isActiveForScraping"] = this.isActiveForScraping;
        data["scrapingFrequencyOverride"] = this.scrapingFrequencyOverride;
        data["siteConfigId"] = this.siteConfigId;
        data["lastScrapedAt"] = this.lastScrapedAt ? this.lastScrapedAt.toISOString() : <any>undefined;
        data["nextScrapeAt"] = this.nextScrapeAt ? this.nextScrapeAt.toISOString() : <any>undefined;
        data["lastScrapeStatus"] = this.lastScrapeStatus;
        data["lastScrapeErrorCode"] = this.lastScrapeErrorCode;
        data["consecutiveFailureCount"] = this.consecutiveFailureCount;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        data["siteConfiguration"] = this.siteConfiguration ? this.siteConfiguration.toJSON() : <any>undefined;
        return data;
    }
}

export interface IProductSellerMappingDto {
    mappingId?: string;
    canonicalProductId?: string;
    sellerName?: string | undefined;
    exactProductUrl?: string | undefined;
    isActiveForScraping?: boolean;
    scrapingFrequencyOverride?: string | undefined;
    siteConfigId?: string | undefined;
    lastScrapedAt?: Date | undefined;
    nextScrapeAt?: Date | undefined;
    lastScrapeStatus?: string | undefined;
    lastScrapeErrorCode?: string | undefined;
    consecutiveFailureCount?: number;
    createdAt?: Date;
    updatedAt?: Date;
    product?: ProductDto;
    siteConfiguration?: ScraperSiteConfigurationDto;
}

export class ProductSellerMappingDtoApiResponse implements IProductSellerMappingDtoApiResponse {
    success?: boolean;
    data?: ProductSellerMappingDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IProductSellerMappingDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"] ? ProductSellerMappingDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): ProductSellerMappingDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ProductSellerMappingDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IProductSellerMappingDtoApiResponse {
    success?: boolean;
    data?: ProductSellerMappingDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class ProductSellerMappingDtoIEnumerableApiResponse implements IProductSellerMappingDtoIEnumerableApiResponse {
    success?: boolean;
    data?: ProductSellerMappingDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IProductSellerMappingDtoIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(ProductSellerMappingDto.fromJS(item));
            }
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): ProductSellerMappingDtoIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ProductSellerMappingDtoIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : <any>undefined);
        }
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IProductSellerMappingDtoIEnumerableApiResponse {
    success?: boolean;
    data?: ProductSellerMappingDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class ProductWithCurrentPricesDto implements IProductWithCurrentPricesDto {
    productId?: string;
    name?: string | undefined;
    manufacturer?: string | undefined;
    modelNumber?: string | undefined;
    sku?: string | undefined;
    categoryId?: string;
    description?: string | undefined;
    specifications?: { [key: string]: any; } | undefined;
    isActive?: boolean;
    createdAt?: Date;
    updatedAt?: Date;
    category?: CategoryDto;
    currentPrices?: CurrentPriceDto[] | undefined;
    lowestCurrentPrice?: number | undefined;
    highestCurrentPrice?: number | undefined;
    availableSellersCount?: number;

    constructor(data?: IProductWithCurrentPricesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.name = _data["name"];
            this.manufacturer = _data["manufacturer"];
            this.modelNumber = _data["modelNumber"];
            this.sku = _data["sku"];
            this.categoryId = _data["categoryId"];
            this.description = _data["description"];
            if (_data["specifications"]) {
                this.specifications = {} as any;
                for (let key in _data["specifications"]) {
                    if (_data["specifications"].hasOwnProperty(key))
                        (<any>this.specifications)![key] = _data["specifications"][key];
                }
            }
            this.isActive = _data["isActive"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.category = _data["category"] ? CategoryDto.fromJS(_data["category"]) : <any>undefined;
            if (Array.isArray(_data["currentPrices"])) {
                this.currentPrices = [] as any;
                for (let item of _data["currentPrices"])
                    this.currentPrices!.push(CurrentPriceDto.fromJS(item));
            }
            this.lowestCurrentPrice = _data["lowestCurrentPrice"];
            this.highestCurrentPrice = _data["highestCurrentPrice"];
            this.availableSellersCount = _data["availableSellersCount"];
        }
    }

    static fromJS(data: any): ProductWithCurrentPricesDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductWithCurrentPricesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["name"] = this.name;
        data["manufacturer"] = this.manufacturer;
        data["modelNumber"] = this.modelNumber;
        data["sku"] = this.sku;
        data["categoryId"] = this.categoryId;
        data["description"] = this.description;
        if (this.specifications) {
            data["specifications"] = {};
            for (let key in this.specifications) {
                if (this.specifications.hasOwnProperty(key))
                    (<any>data["specifications"])[key] = (<any>this.specifications)[key];
            }
        }
        data["isActive"] = this.isActive;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["category"] = this.category ? this.category.toJSON() : <any>undefined;
        if (Array.isArray(this.currentPrices)) {
            data["currentPrices"] = [];
            for (let item of this.currentPrices)
                data["currentPrices"].push(item ? item.toJSON() : <any>undefined);
        }
        data["lowestCurrentPrice"] = this.lowestCurrentPrice;
        data["highestCurrentPrice"] = this.highestCurrentPrice;
        data["availableSellersCount"] = this.availableSellersCount;
        return data;
    }
}

export interface IProductWithCurrentPricesDto {
    productId?: string;
    name?: string | undefined;
    manufacturer?: string | undefined;
    modelNumber?: string | undefined;
    sku?: string | undefined;
    categoryId?: string;
    description?: string | undefined;
    specifications?: { [key: string]: any; } | undefined;
    isActive?: boolean;
    createdAt?: Date;
    updatedAt?: Date;
    category?: CategoryDto;
    currentPrices?: CurrentPriceDto[] | undefined;
    lowestCurrentPrice?: number | undefined;
    highestCurrentPrice?: number | undefined;
    availableSellersCount?: number;
}

export class ProductWithCurrentPricesDtoApiResponse implements IProductWithCurrentPricesDtoApiResponse {
    success?: boolean;
    data?: ProductWithCurrentPricesDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IProductWithCurrentPricesDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"] ? ProductWithCurrentPricesDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): ProductWithCurrentPricesDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ProductWithCurrentPricesDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IProductWithCurrentPricesDtoApiResponse {
    success?: boolean;
    data?: ProductWithCurrentPricesDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class ProductWithCurrentPricesDtoPagedResponse implements IProductWithCurrentPricesDtoPagedResponse {
    success?: boolean;
    data?: ProductWithCurrentPricesDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
    pagination?: PaginationMeta;

    constructor(data?: IProductWithCurrentPricesDtoPagedResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(ProductWithCurrentPricesDto.fromJS(item));
            }
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
            this.pagination = _data["pagination"] ? PaginationMeta.fromJS(_data["pagination"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProductWithCurrentPricesDtoPagedResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ProductWithCurrentPricesDtoPagedResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : <any>undefined);
        }
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        data["pagination"] = this.pagination ? this.pagination.toJSON() : <any>undefined;
        return data;
    }
}

export interface IProductWithCurrentPricesDtoPagedResponse {
    success?: boolean;
    data?: ProductWithCurrentPricesDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
    pagination?: PaginationMeta;
}

export class RegisterUserDto implements IRegisterUserDto {
    email!: string;
    password!: string;
    firstName?: string | undefined;
    lastName?: string | undefined;

    constructor(data?: IRegisterUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
        }
    }

    static fromJS(data: any): RegisterUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        return data;
    }
}

export interface IRegisterUserDto {
    email: string;
    password: string;
    firstName?: string | undefined;
    lastName?: string | undefined;
}

export class RoleInfoDto implements IRoleInfoDto {
    id?: string;
    name?: string | undefined;
    displayName?: string | undefined;
    description?: string | undefined;
    userCount?: number;
    isSystemRole?: boolean;

    constructor(data?: IRoleInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.userCount = _data["userCount"];
            this.isSystemRole = _data["isSystemRole"];
        }
    }

    static fromJS(data: any): RoleInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["userCount"] = this.userCount;
        data["isSystemRole"] = this.isSystemRole;
        return data;
    }
}

export interface IRoleInfoDto {
    id?: string;
    name?: string | undefined;
    displayName?: string | undefined;
    description?: string | undefined;
    userCount?: number;
    isSystemRole?: boolean;
}

export class RoleInfoDtoApiResponse implements IRoleInfoDtoApiResponse {
    success?: boolean;
    data?: RoleInfoDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IRoleInfoDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"] ? RoleInfoDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): RoleInfoDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RoleInfoDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IRoleInfoDtoApiResponse {
    success?: boolean;
    data?: RoleInfoDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class RoleInfoDtoIEnumerableApiResponse implements IRoleInfoDtoIEnumerableApiResponse {
    success?: boolean;
    data?: RoleInfoDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IRoleInfoDtoIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(RoleInfoDto.fromJS(item));
            }
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): RoleInfoDtoIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RoleInfoDtoIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : <any>undefined);
        }
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IRoleInfoDtoIEnumerableApiResponse {
    success?: boolean;
    data?: RoleInfoDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class ScraperRunLogDto implements IScraperRunLogDto {
    runId?: string;
    mappingId?: string;
    startedAt?: Date;
    completedAt?: Date | undefined;
    duration?: string | undefined;
    status?: string | undefined;
    statusDisplayName?: string | undefined;
    targetUrl?: string | undefined;
    userAgent?: string | undefined;
    additionalHeaders?: { [key: string]: string; } | undefined;
    selectors?: ScrapingSelectorsDto;
    httpStatusCode?: number | undefined;
    responseTime?: string | undefined;
    responseSizeBytes?: number | undefined;
    extractedProductName?: string | undefined;
    extractedPrice?: number | undefined;
    extractedStockStatus?: string | undefined;
    extractedSellerName?: string | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errorStackTrace?: string | undefined;
    errorCategory?: string | undefined;
    errorCategoryDisplayName?: string | undefined;
    attemptNumber?: number;
    parentRunId?: string | undefined;
    isRetry?: boolean;
    pageLoadTime?: string | undefined;
    parsingTime?: string | undefined;
    rawHtmlSnippet?: string | undefined;
    debugNotes?: string | undefined;
    mapping?: ProductSellerMappingDto;
    retryAttempts?: ScraperRunLogSummaryDto[] | undefined;
    createdAt?: Date;

    constructor(data?: IScraperRunLogDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.runId = _data["runId"];
            this.mappingId = _data["mappingId"];
            this.startedAt = _data["startedAt"] ? new Date(_data["startedAt"].toString()) : <any>undefined;
            this.completedAt = _data["completedAt"] ? new Date(_data["completedAt"].toString()) : <any>undefined;
            this.duration = _data["duration"];
            this.status = _data["status"];
            this.statusDisplayName = _data["statusDisplayName"];
            this.targetUrl = _data["targetUrl"];
            this.userAgent = _data["userAgent"];
            if (_data["additionalHeaders"]) {
                this.additionalHeaders = {} as any;
                for (let key in _data["additionalHeaders"]) {
                    if (_data["additionalHeaders"].hasOwnProperty(key))
                        (<any>this.additionalHeaders)![key] = _data["additionalHeaders"][key];
                }
            }
            this.selectors = _data["selectors"] ? ScrapingSelectorsDto.fromJS(_data["selectors"]) : <any>undefined;
            this.httpStatusCode = _data["httpStatusCode"];
            this.responseTime = _data["responseTime"];
            this.responseSizeBytes = _data["responseSizeBytes"];
            this.extractedProductName = _data["extractedProductName"];
            this.extractedPrice = _data["extractedPrice"];
            this.extractedStockStatus = _data["extractedStockStatus"];
            this.extractedSellerName = _data["extractedSellerName"];
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            this.errorStackTrace = _data["errorStackTrace"];
            this.errorCategory = _data["errorCategory"];
            this.errorCategoryDisplayName = _data["errorCategoryDisplayName"];
            this.attemptNumber = _data["attemptNumber"];
            this.parentRunId = _data["parentRunId"];
            this.isRetry = _data["isRetry"];
            this.pageLoadTime = _data["pageLoadTime"];
            this.parsingTime = _data["parsingTime"];
            this.rawHtmlSnippet = _data["rawHtmlSnippet"];
            this.debugNotes = _data["debugNotes"];
            this.mapping = _data["mapping"] ? ProductSellerMappingDto.fromJS(_data["mapping"]) : <any>undefined;
            if (Array.isArray(_data["retryAttempts"])) {
                this.retryAttempts = [] as any;
                for (let item of _data["retryAttempts"])
                    this.retryAttempts!.push(ScraperRunLogSummaryDto.fromJS(item));
            }
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ScraperRunLogDto {
        data = typeof data === 'object' ? data : {};
        let result = new ScraperRunLogDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["runId"] = this.runId;
        data["mappingId"] = this.mappingId;
        data["startedAt"] = this.startedAt ? this.startedAt.toISOString() : <any>undefined;
        data["completedAt"] = this.completedAt ? this.completedAt.toISOString() : <any>undefined;
        data["duration"] = this.duration;
        data["status"] = this.status;
        data["statusDisplayName"] = this.statusDisplayName;
        data["targetUrl"] = this.targetUrl;
        data["userAgent"] = this.userAgent;
        if (this.additionalHeaders) {
            data["additionalHeaders"] = {};
            for (let key in this.additionalHeaders) {
                if (this.additionalHeaders.hasOwnProperty(key))
                    (<any>data["additionalHeaders"])[key] = (<any>this.additionalHeaders)[key];
            }
        }
        data["selectors"] = this.selectors ? this.selectors.toJSON() : <any>undefined;
        data["httpStatusCode"] = this.httpStatusCode;
        data["responseTime"] = this.responseTime;
        data["responseSizeBytes"] = this.responseSizeBytes;
        data["extractedProductName"] = this.extractedProductName;
        data["extractedPrice"] = this.extractedPrice;
        data["extractedStockStatus"] = this.extractedStockStatus;
        data["extractedSellerName"] = this.extractedSellerName;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        data["errorStackTrace"] = this.errorStackTrace;
        data["errorCategory"] = this.errorCategory;
        data["errorCategoryDisplayName"] = this.errorCategoryDisplayName;
        data["attemptNumber"] = this.attemptNumber;
        data["parentRunId"] = this.parentRunId;
        data["isRetry"] = this.isRetry;
        data["pageLoadTime"] = this.pageLoadTime;
        data["parsingTime"] = this.parsingTime;
        data["rawHtmlSnippet"] = this.rawHtmlSnippet;
        data["debugNotes"] = this.debugNotes;
        data["mapping"] = this.mapping ? this.mapping.toJSON() : <any>undefined;
        if (Array.isArray(this.retryAttempts)) {
            data["retryAttempts"] = [];
            for (let item of this.retryAttempts)
                data["retryAttempts"].push(item ? item.toJSON() : <any>undefined);
        }
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        return data;
    }
}

export interface IScraperRunLogDto {
    runId?: string;
    mappingId?: string;
    startedAt?: Date;
    completedAt?: Date | undefined;
    duration?: string | undefined;
    status?: string | undefined;
    statusDisplayName?: string | undefined;
    targetUrl?: string | undefined;
    userAgent?: string | undefined;
    additionalHeaders?: { [key: string]: string; } | undefined;
    selectors?: ScrapingSelectorsDto;
    httpStatusCode?: number | undefined;
    responseTime?: string | undefined;
    responseSizeBytes?: number | undefined;
    extractedProductName?: string | undefined;
    extractedPrice?: number | undefined;
    extractedStockStatus?: string | undefined;
    extractedSellerName?: string | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errorStackTrace?: string | undefined;
    errorCategory?: string | undefined;
    errorCategoryDisplayName?: string | undefined;
    attemptNumber?: number;
    parentRunId?: string | undefined;
    isRetry?: boolean;
    pageLoadTime?: string | undefined;
    parsingTime?: string | undefined;
    rawHtmlSnippet?: string | undefined;
    debugNotes?: string | undefined;
    mapping?: ProductSellerMappingDto;
    retryAttempts?: ScraperRunLogSummaryDto[] | undefined;
    createdAt?: Date;
}

export class ScraperRunLogDtoApiResponse implements IScraperRunLogDtoApiResponse {
    success?: boolean;
    data?: ScraperRunLogDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IScraperRunLogDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"] ? ScraperRunLogDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): ScraperRunLogDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ScraperRunLogDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IScraperRunLogDtoApiResponse {
    success?: boolean;
    data?: ScraperRunLogDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class ScraperRunLogDtoIEnumerableApiResponse implements IScraperRunLogDtoIEnumerableApiResponse {
    success?: boolean;
    data?: ScraperRunLogDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IScraperRunLogDtoIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(ScraperRunLogDto.fromJS(item));
            }
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): ScraperRunLogDtoIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ScraperRunLogDtoIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : <any>undefined);
        }
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IScraperRunLogDtoIEnumerableApiResponse {
    success?: boolean;
    data?: ScraperRunLogDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class ScraperRunLogSummaryDto implements IScraperRunLogSummaryDto {
    runId?: string;
    mappingId?: string;
    startedAt?: Date;
    completedAt?: Date | undefined;
    duration?: string | undefined;
    status?: string | undefined;
    statusDisplayName?: string | undefined;
    targetUrl?: string | undefined;
    extractedPrice?: number | undefined;
    errorMessage?: string | undefined;
    errorCategory?: string | undefined;
    errorCategoryDisplayName?: string | undefined;
    attemptNumber?: number;
    isRetry?: boolean;
    responseTime?: string | undefined;
    sellerName?: string | undefined;
    productName?: string | undefined;

    constructor(data?: IScraperRunLogSummaryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.runId = _data["runId"];
            this.mappingId = _data["mappingId"];
            this.startedAt = _data["startedAt"] ? new Date(_data["startedAt"].toString()) : <any>undefined;
            this.completedAt = _data["completedAt"] ? new Date(_data["completedAt"].toString()) : <any>undefined;
            this.duration = _data["duration"];
            this.status = _data["status"];
            this.statusDisplayName = _data["statusDisplayName"];
            this.targetUrl = _data["targetUrl"];
            this.extractedPrice = _data["extractedPrice"];
            this.errorMessage = _data["errorMessage"];
            this.errorCategory = _data["errorCategory"];
            this.errorCategoryDisplayName = _data["errorCategoryDisplayName"];
            this.attemptNumber = _data["attemptNumber"];
            this.isRetry = _data["isRetry"];
            this.responseTime = _data["responseTime"];
            this.sellerName = _data["sellerName"];
            this.productName = _data["productName"];
        }
    }

    static fromJS(data: any): ScraperRunLogSummaryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ScraperRunLogSummaryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["runId"] = this.runId;
        data["mappingId"] = this.mappingId;
        data["startedAt"] = this.startedAt ? this.startedAt.toISOString() : <any>undefined;
        data["completedAt"] = this.completedAt ? this.completedAt.toISOString() : <any>undefined;
        data["duration"] = this.duration;
        data["status"] = this.status;
        data["statusDisplayName"] = this.statusDisplayName;
        data["targetUrl"] = this.targetUrl;
        data["extractedPrice"] = this.extractedPrice;
        data["errorMessage"] = this.errorMessage;
        data["errorCategory"] = this.errorCategory;
        data["errorCategoryDisplayName"] = this.errorCategoryDisplayName;
        data["attemptNumber"] = this.attemptNumber;
        data["isRetry"] = this.isRetry;
        data["responseTime"] = this.responseTime;
        data["sellerName"] = this.sellerName;
        data["productName"] = this.productName;
        return data;
    }
}

export interface IScraperRunLogSummaryDto {
    runId?: string;
    mappingId?: string;
    startedAt?: Date;
    completedAt?: Date | undefined;
    duration?: string | undefined;
    status?: string | undefined;
    statusDisplayName?: string | undefined;
    targetUrl?: string | undefined;
    extractedPrice?: number | undefined;
    errorMessage?: string | undefined;
    errorCategory?: string | undefined;
    errorCategoryDisplayName?: string | undefined;
    attemptNumber?: number;
    isRetry?: boolean;
    responseTime?: string | undefined;
    sellerName?: string | undefined;
    productName?: string | undefined;
}

export class ScraperRunLogSummaryDtoIEnumerableApiResponse implements IScraperRunLogSummaryDtoIEnumerableApiResponse {
    success?: boolean;
    data?: ScraperRunLogSummaryDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IScraperRunLogSummaryDtoIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(ScraperRunLogSummaryDto.fromJS(item));
            }
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): ScraperRunLogSummaryDtoIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ScraperRunLogSummaryDtoIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : <any>undefined);
        }
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IScraperRunLogSummaryDtoIEnumerableApiResponse {
    success?: boolean;
    data?: ScraperRunLogSummaryDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class ScraperRunLogSummaryDtoPagedResultDto implements IScraperRunLogSummaryDtoPagedResultDto {
    items?: ScraperRunLogSummaryDto[] | undefined;
    totalCount?: number;
    page?: number;
    pageSize?: number;
    readonly totalPages?: number;
    readonly hasNextPage?: boolean;
    readonly hasPreviousPage?: boolean;

    constructor(data?: IScraperRunLogSummaryDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ScraperRunLogSummaryDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            this.page = _data["page"];
            this.pageSize = _data["pageSize"];
            (<any>this).totalPages = _data["totalPages"];
            (<any>this).hasNextPage = _data["hasNextPage"];
            (<any>this).hasPreviousPage = _data["hasPreviousPage"];
        }
    }

    static fromJS(data: any): ScraperRunLogSummaryDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ScraperRunLogSummaryDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : <any>undefined);
        }
        data["totalCount"] = this.totalCount;
        data["page"] = this.page;
        data["pageSize"] = this.pageSize;
        data["totalPages"] = this.totalPages;
        data["hasNextPage"] = this.hasNextPage;
        data["hasPreviousPage"] = this.hasPreviousPage;
        return data;
    }
}

export interface IScraperRunLogSummaryDtoPagedResultDto {
    items?: ScraperRunLogSummaryDto[] | undefined;
    totalCount?: number;
    page?: number;
    pageSize?: number;
    totalPages?: number;
    hasNextPage?: boolean;
    hasPreviousPage?: boolean;
}

export class ScraperRunLogSummaryDtoPagedResultDtoApiResponse implements IScraperRunLogSummaryDtoPagedResultDtoApiResponse {
    success?: boolean;
    data?: ScraperRunLogSummaryDtoPagedResultDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IScraperRunLogSummaryDtoPagedResultDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"] ? ScraperRunLogSummaryDtoPagedResultDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): ScraperRunLogSummaryDtoPagedResultDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ScraperRunLogSummaryDtoPagedResultDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IScraperRunLogSummaryDtoPagedResultDtoApiResponse {
    success?: boolean;
    data?: ScraperRunLogSummaryDtoPagedResultDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class ScraperRunStatisticsDto implements IScraperRunStatisticsDto {
    totalRuns?: number;
    successfulRuns?: number;
    failedRuns?: number;
    inProgressRuns?: number;
    successRate?: number;
    averageResponseTime?: string | undefined;
    averageDuration?: string | undefined;
    errorCategoryCounts?: { [key: string]: number; } | undefined;
    statusCounts?: { [key: string]: number; } | undefined;
    dateFrom?: Date | undefined;
    dateTo?: Date | undefined;

    constructor(data?: IScraperRunStatisticsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalRuns = _data["totalRuns"];
            this.successfulRuns = _data["successfulRuns"];
            this.failedRuns = _data["failedRuns"];
            this.inProgressRuns = _data["inProgressRuns"];
            this.successRate = _data["successRate"];
            this.averageResponseTime = _data["averageResponseTime"];
            this.averageDuration = _data["averageDuration"];
            if (_data["errorCategoryCounts"]) {
                this.errorCategoryCounts = {} as any;
                for (let key in _data["errorCategoryCounts"]) {
                    if (_data["errorCategoryCounts"].hasOwnProperty(key))
                        (<any>this.errorCategoryCounts)![key] = _data["errorCategoryCounts"][key];
                }
            }
            if (_data["statusCounts"]) {
                this.statusCounts = {} as any;
                for (let key in _data["statusCounts"]) {
                    if (_data["statusCounts"].hasOwnProperty(key))
                        (<any>this.statusCounts)![key] = _data["statusCounts"][key];
                }
            }
            this.dateFrom = _data["dateFrom"] ? new Date(_data["dateFrom"].toString()) : <any>undefined;
            this.dateTo = _data["dateTo"] ? new Date(_data["dateTo"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ScraperRunStatisticsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ScraperRunStatisticsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalRuns"] = this.totalRuns;
        data["successfulRuns"] = this.successfulRuns;
        data["failedRuns"] = this.failedRuns;
        data["inProgressRuns"] = this.inProgressRuns;
        data["successRate"] = this.successRate;
        data["averageResponseTime"] = this.averageResponseTime;
        data["averageDuration"] = this.averageDuration;
        if (this.errorCategoryCounts) {
            data["errorCategoryCounts"] = {};
            for (let key in this.errorCategoryCounts) {
                if (this.errorCategoryCounts.hasOwnProperty(key))
                    (<any>data["errorCategoryCounts"])[key] = (<any>this.errorCategoryCounts)[key];
            }
        }
        if (this.statusCounts) {
            data["statusCounts"] = {};
            for (let key in this.statusCounts) {
                if (this.statusCounts.hasOwnProperty(key))
                    (<any>data["statusCounts"])[key] = (<any>this.statusCounts)[key];
            }
        }
        data["dateFrom"] = this.dateFrom ? this.dateFrom.toISOString() : <any>undefined;
        data["dateTo"] = this.dateTo ? this.dateTo.toISOString() : <any>undefined;
        return data;
    }
}

export interface IScraperRunStatisticsDto {
    totalRuns?: number;
    successfulRuns?: number;
    failedRuns?: number;
    inProgressRuns?: number;
    successRate?: number;
    averageResponseTime?: string | undefined;
    averageDuration?: string | undefined;
    errorCategoryCounts?: { [key: string]: number; } | undefined;
    statusCounts?: { [key: string]: number; } | undefined;
    dateFrom?: Date | undefined;
    dateTo?: Date | undefined;
}

export class ScraperRunStatisticsDtoApiResponse implements IScraperRunStatisticsDtoApiResponse {
    success?: boolean;
    data?: ScraperRunStatisticsDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IScraperRunStatisticsDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"] ? ScraperRunStatisticsDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): ScraperRunStatisticsDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ScraperRunStatisticsDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IScraperRunStatisticsDtoApiResponse {
    success?: boolean;
    data?: ScraperRunStatisticsDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class ScraperSiteConfigurationDto implements IScraperSiteConfigurationDto {
    siteConfigId?: string;
    siteDomain?: string | undefined;
    productNameSelector?: string | undefined;
    priceSelector?: string | undefined;
    stockSelector?: string | undefined;
    sellerNameOnPageSelector?: string | undefined;
    defaultUserAgent?: string | undefined;
    additionalHeaders?: { [key: string]: string; } | undefined;
    isEnabled?: boolean;
    createdAt?: Date;
    updatedAt?: Date;

    constructor(data?: IScraperSiteConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.siteConfigId = _data["siteConfigId"];
            this.siteDomain = _data["siteDomain"];
            this.productNameSelector = _data["productNameSelector"];
            this.priceSelector = _data["priceSelector"];
            this.stockSelector = _data["stockSelector"];
            this.sellerNameOnPageSelector = _data["sellerNameOnPageSelector"];
            this.defaultUserAgent = _data["defaultUserAgent"];
            if (_data["additionalHeaders"]) {
                this.additionalHeaders = {} as any;
                for (let key in _data["additionalHeaders"]) {
                    if (_data["additionalHeaders"].hasOwnProperty(key))
                        (<any>this.additionalHeaders)![key] = _data["additionalHeaders"][key];
                }
            }
            this.isEnabled = _data["isEnabled"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ScraperSiteConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ScraperSiteConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["siteConfigId"] = this.siteConfigId;
        data["siteDomain"] = this.siteDomain;
        data["productNameSelector"] = this.productNameSelector;
        data["priceSelector"] = this.priceSelector;
        data["stockSelector"] = this.stockSelector;
        data["sellerNameOnPageSelector"] = this.sellerNameOnPageSelector;
        data["defaultUserAgent"] = this.defaultUserAgent;
        if (this.additionalHeaders) {
            data["additionalHeaders"] = {};
            for (let key in this.additionalHeaders) {
                if (this.additionalHeaders.hasOwnProperty(key))
                    (<any>data["additionalHeaders"])[key] = (<any>this.additionalHeaders)[key];
            }
        }
        data["isEnabled"] = this.isEnabled;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        return data;
    }
}

export interface IScraperSiteConfigurationDto {
    siteConfigId?: string;
    siteDomain?: string | undefined;
    productNameSelector?: string | undefined;
    priceSelector?: string | undefined;
    stockSelector?: string | undefined;
    sellerNameOnPageSelector?: string | undefined;
    defaultUserAgent?: string | undefined;
    additionalHeaders?: { [key: string]: string; } | undefined;
    isEnabled?: boolean;
    createdAt?: Date;
    updatedAt?: Date;
}

export class ScraperSiteConfigurationDtoApiResponse implements IScraperSiteConfigurationDtoApiResponse {
    success?: boolean;
    data?: ScraperSiteConfigurationDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IScraperSiteConfigurationDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"] ? ScraperSiteConfigurationDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): ScraperSiteConfigurationDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ScraperSiteConfigurationDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IScraperSiteConfigurationDtoApiResponse {
    success?: boolean;
    data?: ScraperSiteConfigurationDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class ScraperSiteConfigurationDtoIEnumerableApiResponse implements IScraperSiteConfigurationDtoIEnumerableApiResponse {
    success?: boolean;
    data?: ScraperSiteConfigurationDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IScraperSiteConfigurationDtoIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(ScraperSiteConfigurationDto.fromJS(item));
            }
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): ScraperSiteConfigurationDtoIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ScraperSiteConfigurationDtoIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : <any>undefined);
        }
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IScraperSiteConfigurationDtoIEnumerableApiResponse {
    success?: boolean;
    data?: ScraperSiteConfigurationDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class ScrapingSelectorsDto implements IScrapingSelectorsDto {
    productNameSelector?: string | undefined;
    priceSelector?: string | undefined;
    stockSelector?: string | undefined;
    sellerNameOnPageSelector?: string | undefined;

    constructor(data?: IScrapingSelectorsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productNameSelector = _data["productNameSelector"];
            this.priceSelector = _data["priceSelector"];
            this.stockSelector = _data["stockSelector"];
            this.sellerNameOnPageSelector = _data["sellerNameOnPageSelector"];
        }
    }

    static fromJS(data: any): ScrapingSelectorsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ScrapingSelectorsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productNameSelector"] = this.productNameSelector;
        data["priceSelector"] = this.priceSelector;
        data["stockSelector"] = this.stockSelector;
        data["sellerNameOnPageSelector"] = this.sellerNameOnPageSelector;
        return data;
    }
}

export interface IScrapingSelectorsDto {
    productNameSelector?: string | undefined;
    priceSelector?: string | undefined;
    stockSelector?: string | undefined;
    sellerNameOnPageSelector?: string | undefined;
}

export class SellerPerformanceMetricDto implements ISellerPerformanceMetricDto {
    sellerName?: string | undefined;
    totalRuns?: number;
    successfulRuns?: number;
    successRate?: number;
    averageResponseTime?: string | undefined;
    averageDuration?: string | undefined;

    constructor(data?: ISellerPerformanceMetricDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sellerName = _data["sellerName"];
            this.totalRuns = _data["totalRuns"];
            this.successfulRuns = _data["successfulRuns"];
            this.successRate = _data["successRate"];
            this.averageResponseTime = _data["averageResponseTime"];
            this.averageDuration = _data["averageDuration"];
        }
    }

    static fromJS(data: any): SellerPerformanceMetricDto {
        data = typeof data === 'object' ? data : {};
        let result = new SellerPerformanceMetricDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sellerName"] = this.sellerName;
        data["totalRuns"] = this.totalRuns;
        data["successfulRuns"] = this.successfulRuns;
        data["successRate"] = this.successRate;
        data["averageResponseTime"] = this.averageResponseTime;
        data["averageDuration"] = this.averageDuration;
        return data;
    }
}

export interface ISellerPerformanceMetricDto {
    sellerName?: string | undefined;
    totalRuns?: number;
    successfulRuns?: number;
    successRate?: number;
    averageResponseTime?: string | undefined;
    averageDuration?: string | undefined;
}

export class SellerPerformanceMetricDtoIEnumerableApiResponse implements ISellerPerformanceMetricDtoIEnumerableApiResponse {
    success?: boolean;
    data?: SellerPerformanceMetricDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: ISellerPerformanceMetricDtoIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(SellerPerformanceMetricDto.fromJS(item));
            }
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): SellerPerformanceMetricDtoIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SellerPerformanceMetricDtoIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : <any>undefined);
        }
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface ISellerPerformanceMetricDtoIEnumerableApiResponse {
    success?: boolean;
    data?: SellerPerformanceMetricDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class StringApiResponse implements IStringApiResponse {
    success?: boolean;
    data?: string | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IStringApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"];
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): StringApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new StringApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IStringApiResponse {
    success?: boolean;
    data?: string | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class StringStringArrayDictionaryApiResponse implements IStringStringArrayDictionaryApiResponse {
    success?: boolean;
    data?: { [key: string]: string[]; } | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IStringStringArrayDictionaryApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (_data["data"]) {
                this.data = {} as any;
                for (let key in _data["data"]) {
                    if (_data["data"].hasOwnProperty(key))
                        (<any>this.data)![key] = _data["data"][key];
                }
            }
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): StringStringArrayDictionaryApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new StringStringArrayDictionaryApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (this.data) {
            data["data"] = {};
            for (let key in this.data) {
                if (this.data.hasOwnProperty(key))
                    (<any>data["data"])[key] = (<any>this.data)[key];
            }
        }
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IStringStringArrayDictionaryApiResponse {
    success?: boolean;
    data?: { [key: string]: string[]; } | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class UpdateAlertRuleDto implements IUpdateAlertRuleDto {
    conditionType?: string | undefined;
    thresholdValue?: number | undefined;
    percentageValue?: number | undefined;
    specificSellerName?: string | undefined;
    notificationFrequencyMinutes?: number | undefined;
    isActive?: boolean | undefined;

    constructor(data?: IUpdateAlertRuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.conditionType = _data["conditionType"];
            this.thresholdValue = _data["thresholdValue"];
            this.percentageValue = _data["percentageValue"];
            this.specificSellerName = _data["specificSellerName"];
            this.notificationFrequencyMinutes = _data["notificationFrequencyMinutes"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): UpdateAlertRuleDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAlertRuleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["conditionType"] = this.conditionType;
        data["thresholdValue"] = this.thresholdValue;
        data["percentageValue"] = this.percentageValue;
        data["specificSellerName"] = this.specificSellerName;
        data["notificationFrequencyMinutes"] = this.notificationFrequencyMinutes;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IUpdateAlertRuleDto {
    conditionType?: string | undefined;
    thresholdValue?: number | undefined;
    percentageValue?: number | undefined;
    specificSellerName?: string | undefined;
    notificationFrequencyMinutes?: number | undefined;
    isActive?: boolean | undefined;
}

export class UpdateCategoryDto implements IUpdateCategoryDto {
    name?: string | undefined;
    slug?: string | undefined;
    description?: string | undefined;

    constructor(data?: IUpdateCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): UpdateCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["description"] = this.description;
        return data;
    }
}

export interface IUpdateCategoryDto {
    name?: string | undefined;
    slug?: string | undefined;
    description?: string | undefined;
}

export class UpdatePermissionDto implements IUpdatePermissionDto {
    description?: string | undefined;
    category?: string | undefined;

    constructor(data?: IUpdatePermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.category = _data["category"];
        }
    }

    static fromJS(data: any): UpdatePermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["category"] = this.category;
        return data;
    }
}

export interface IUpdatePermissionDto {
    description?: string | undefined;
    category?: string | undefined;
}

export class UpdateProductDto implements IUpdateProductDto {
    name?: string | undefined;
    manufacturer?: string | undefined;
    modelNumber?: string | undefined;
    sku?: string | undefined;
    categoryId?: string | undefined;
    description?: string | undefined;
    specifications?: { [key: string]: any; } | undefined;
    isActive?: boolean | undefined;

    constructor(data?: IUpdateProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.manufacturer = _data["manufacturer"];
            this.modelNumber = _data["modelNumber"];
            this.sku = _data["sku"];
            this.categoryId = _data["categoryId"];
            this.description = _data["description"];
            if (_data["specifications"]) {
                this.specifications = {} as any;
                for (let key in _data["specifications"]) {
                    if (_data["specifications"].hasOwnProperty(key))
                        (<any>this.specifications)![key] = _data["specifications"][key];
                }
            }
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): UpdateProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["manufacturer"] = this.manufacturer;
        data["modelNumber"] = this.modelNumber;
        data["sku"] = this.sku;
        data["categoryId"] = this.categoryId;
        data["description"] = this.description;
        if (this.specifications) {
            data["specifications"] = {};
            for (let key in this.specifications) {
                if (this.specifications.hasOwnProperty(key))
                    (<any>data["specifications"])[key] = (<any>this.specifications)[key];
            }
        }
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IUpdateProductDto {
    name?: string | undefined;
    manufacturer?: string | undefined;
    modelNumber?: string | undefined;
    sku?: string | undefined;
    categoryId?: string | undefined;
    description?: string | undefined;
    specifications?: { [key: string]: any; } | undefined;
    isActive?: boolean | undefined;
}

export class UpdateProductSellerMappingDto implements IUpdateProductSellerMappingDto {
    sellerName?: string | undefined;
    exactProductUrl?: string | undefined;
    isActiveForScraping?: boolean | undefined;
    scrapingFrequencyOverride?: string | undefined;
    siteConfigId?: string | undefined;

    constructor(data?: IUpdateProductSellerMappingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sellerName = _data["sellerName"];
            this.exactProductUrl = _data["exactProductUrl"];
            this.isActiveForScraping = _data["isActiveForScraping"];
            this.scrapingFrequencyOverride = _data["scrapingFrequencyOverride"];
            this.siteConfigId = _data["siteConfigId"];
        }
    }

    static fromJS(data: any): UpdateProductSellerMappingDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductSellerMappingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sellerName"] = this.sellerName;
        data["exactProductUrl"] = this.exactProductUrl;
        data["isActiveForScraping"] = this.isActiveForScraping;
        data["scrapingFrequencyOverride"] = this.scrapingFrequencyOverride;
        data["siteConfigId"] = this.siteConfigId;
        return data;
    }
}

export interface IUpdateProductSellerMappingDto {
    sellerName?: string | undefined;
    exactProductUrl?: string | undefined;
    isActiveForScraping?: boolean | undefined;
    scrapingFrequencyOverride?: string | undefined;
    siteConfigId?: string | undefined;
}

export class UpdateScraperSiteConfigurationDto implements IUpdateScraperSiteConfigurationDto {
    siteDomain?: string | undefined;
    productNameSelector?: string | undefined;
    priceSelector?: string | undefined;
    stockSelector?: string | undefined;
    sellerNameOnPageSelector?: string | undefined;
    defaultUserAgent?: string | undefined;
    additionalHeaders?: { [key: string]: string; } | undefined;
    isEnabled?: boolean | undefined;

    constructor(data?: IUpdateScraperSiteConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.siteDomain = _data["siteDomain"];
            this.productNameSelector = _data["productNameSelector"];
            this.priceSelector = _data["priceSelector"];
            this.stockSelector = _data["stockSelector"];
            this.sellerNameOnPageSelector = _data["sellerNameOnPageSelector"];
            this.defaultUserAgent = _data["defaultUserAgent"];
            if (_data["additionalHeaders"]) {
                this.additionalHeaders = {} as any;
                for (let key in _data["additionalHeaders"]) {
                    if (_data["additionalHeaders"].hasOwnProperty(key))
                        (<any>this.additionalHeaders)![key] = _data["additionalHeaders"][key];
                }
            }
            this.isEnabled = _data["isEnabled"];
        }
    }

    static fromJS(data: any): UpdateScraperSiteConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateScraperSiteConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["siteDomain"] = this.siteDomain;
        data["productNameSelector"] = this.productNameSelector;
        data["priceSelector"] = this.priceSelector;
        data["stockSelector"] = this.stockSelector;
        data["sellerNameOnPageSelector"] = this.sellerNameOnPageSelector;
        data["defaultUserAgent"] = this.defaultUserAgent;
        if (this.additionalHeaders) {
            data["additionalHeaders"] = {};
            for (let key in this.additionalHeaders) {
                if (this.additionalHeaders.hasOwnProperty(key))
                    (<any>data["additionalHeaders"])[key] = (<any>this.additionalHeaders)[key];
            }
        }
        data["isEnabled"] = this.isEnabled;
        return data;
    }
}

export interface IUpdateScraperSiteConfigurationDto {
    siteDomain?: string | undefined;
    productNameSelector?: string | undefined;
    priceSelector?: string | undefined;
    stockSelector?: string | undefined;
    sellerNameOnPageSelector?: string | undefined;
    defaultUserAgent?: string | undefined;
    additionalHeaders?: { [key: string]: string; } | undefined;
    isEnabled?: boolean | undefined;
}

export class UpdateUserDto implements IUpdateUserDto {
    email?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    roles?: string[] | undefined;
    isActive?: boolean | undefined;

    constructor(data?: IUpdateUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): UpdateUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IUpdateUserDto {
    email?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    roles?: string[] | undefined;
    isActive?: boolean | undefined;
}

export class UserDto implements IUserDto {
    userId?: string;
    email?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    fullName?: string | undefined;
    isActive?: boolean;
    createdAt?: Date;
    updatedAt?: Date;
    roles?: string[] | undefined;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.email = _data["email"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.fullName = _data["fullName"];
            this.isActive = _data["isActive"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["email"] = this.email;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["fullName"] = this.fullName;
        data["isActive"] = this.isActive;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data;
    }
}

export interface IUserDto {
    userId?: string;
    email?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    fullName?: string | undefined;
    isActive?: boolean;
    createdAt?: Date;
    updatedAt?: Date;
    roles?: string[] | undefined;
}

export class UserDtoApiResponse implements IUserDtoApiResponse {
    success?: boolean;
    data?: UserDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IUserDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"] ? UserDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): UserDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UserDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IUserDtoApiResponse {
    success?: boolean;
    data?: UserDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class UserDtoPagedResponse implements IUserDtoPagedResponse {
    success?: boolean;
    data?: UserDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
    pagination?: PaginationMeta;

    constructor(data?: IUserDtoPagedResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(UserDto.fromJS(item));
            }
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
            this.pagination = _data["pagination"] ? PaginationMeta.fromJS(_data["pagination"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UserDtoPagedResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UserDtoPagedResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : <any>undefined);
        }
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        data["pagination"] = this.pagination ? this.pagination.toJSON() : <any>undefined;
        return data;
    }
}

export interface IUserDtoPagedResponse {
    success?: boolean;
    data?: UserDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
    pagination?: PaginationMeta;
}

export class UserRoleInfoDto implements IUserRoleInfoDto {
    userId?: string;
    email?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    fullName?: string | undefined;
    roleName?: string | undefined;
    assignedAt?: Date;

    constructor(data?: IUserRoleInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.email = _data["email"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.fullName = _data["fullName"];
            this.roleName = _data["roleName"];
            this.assignedAt = _data["assignedAt"] ? new Date(_data["assignedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UserRoleInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserRoleInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["email"] = this.email;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["fullName"] = this.fullName;
        data["roleName"] = this.roleName;
        data["assignedAt"] = this.assignedAt ? this.assignedAt.toISOString() : <any>undefined;
        return data;
    }
}

export interface IUserRoleInfoDto {
    userId?: string;
    email?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    fullName?: string | undefined;
    roleName?: string | undefined;
    assignedAt?: Date;
}

export class UserRoleInfoDtoIEnumerableApiResponse implements IUserRoleInfoDtoIEnumerableApiResponse {
    success?: boolean;
    data?: UserRoleInfoDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IUserRoleInfoDtoIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(UserRoleInfoDto.fromJS(item));
            }
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): UserRoleInfoDtoIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UserRoleInfoDtoIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : <any>undefined);
        }
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IUserRoleInfoDtoIEnumerableApiResponse {
    success?: boolean;
    data?: UserRoleInfoDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class UtilitiesExampleRequest implements IUtilitiesExampleRequest {
    text?: string | undefined;
    email?: string | undefined;

    constructor(data?: IUtilitiesExampleRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.text = _data["text"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): UtilitiesExampleRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UtilitiesExampleRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["text"] = this.text;
        data["email"] = this.email;
        return data;
    }
}

export interface IUtilitiesExampleRequest {
    text?: string | undefined;
    email?: string | undefined;
}

export class ValidationExampleRequest implements IValidationExampleRequest {
    email?: string | undefined;
    phone?: string | undefined;
    website?: string | undefined;

    constructor(data?: IValidationExampleRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.phone = _data["phone"];
            this.website = _data["website"];
        }
    }

    static fromJS(data: any): ValidationExampleRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationExampleRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["website"] = this.website;
        return data;
    }
}

export interface IValidationExampleRequest {
    email?: string | undefined;
    phone?: string | undefined;
    website?: string | undefined;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    return _observableThrow(new ApiException(message, status, response, headers, result));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}