//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.4.0.0 (NJsonSchema v11.3.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable({
    providedIn: 'root'
})
export class TechTickerApiClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return OK
     */
    usersGET(page: number | undefined, pageSize: number | undefined): Observable<UserDtoPagedResponse> {
        let url_ = this.baseUrl + "/api/Admin/users?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUsersGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUsersGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDtoPagedResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDtoPagedResponse>;
        }));
    }

    protected processUsersGET(response: HttpResponseBase): Observable<UserDtoPagedResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDtoPagedResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    usersPOST(body: CreateUserDto | undefined): Observable<UserDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Admin/users";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUsersPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUsersPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDtoApiResponse>;
        }));
    }

    protected processUsersPOST(response: HttpResponseBase): Observable<UserDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    usersGET2(userId: string): Observable<UserDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Admin/users/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUsersGET2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUsersGET2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDtoApiResponse>;
        }));
    }

    protected processUsersGET2(response: HttpResponseBase): Observable<UserDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    usersPUT(userId: string, body: UpdateUserDto | undefined): Observable<UserDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Admin/users/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUsersPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUsersPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDtoApiResponse>;
        }));
    }

    protected processUsersPUT(response: HttpResponseBase): Observable<UserDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    usersDELETE(userId: string): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/api/Admin/users/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUsersDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUsersDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processUsersDELETE(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param userId (optional) 
     * @param productId (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return OK
     */
    alerts(userId: string | undefined, productId: string | undefined, page: number | undefined, pageSize: number | undefined): Observable<AlertRuleDtoPagedResponse> {
        let url_ = this.baseUrl + "/api/Admin/alerts?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (productId === null)
            throw new Error("The parameter 'productId' cannot be null.");
        else if (productId !== undefined)
            url_ += "productId=" + encodeURIComponent("" + productId) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAlerts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAlerts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AlertRuleDtoPagedResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AlertRuleDtoPagedResponse>;
        }));
    }

    protected processAlerts(response: HttpResponseBase): Observable<AlertRuleDtoPagedResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AlertRuleDtoPagedResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    alertsPOST(body: CreateAlertRuleDto | undefined): Observable<AlertRuleDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Alerts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAlertsPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAlertsPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AlertRuleDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AlertRuleDtoApiResponse>;
        }));
    }

    protected processAlertsPOST(response: HttpResponseBase): Observable<AlertRuleDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AlertRuleDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    alertsGET(): Observable<AlertRuleDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Alerts";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAlertsGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAlertsGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AlertRuleDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AlertRuleDtoIEnumerableApiResponse>;
        }));
    }

    protected processAlertsGET(response: HttpResponseBase): Observable<AlertRuleDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AlertRuleDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    product(productId: string): Observable<AlertRuleDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Alerts/product/{productId}";
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProduct(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AlertRuleDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AlertRuleDtoIEnumerableApiResponse>;
        }));
    }

    protected processProduct(response: HttpResponseBase): Observable<AlertRuleDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AlertRuleDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    alertsPUT(alertRuleId: string, body: UpdateAlertRuleDto | undefined): Observable<AlertRuleDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Alerts/{alertRuleId}";
        if (alertRuleId === undefined || alertRuleId === null)
            throw new Error("The parameter 'alertRuleId' must be defined.");
        url_ = url_.replace("{alertRuleId}", encodeURIComponent("" + alertRuleId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAlertsPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAlertsPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AlertRuleDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AlertRuleDtoApiResponse>;
        }));
    }

    protected processAlertsPUT(response: HttpResponseBase): Observable<AlertRuleDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AlertRuleDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    alertsDELETE(alertRuleId: string): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/api/Alerts/{alertRuleId}";
        if (alertRuleId === undefined || alertRuleId === null)
            throw new Error("The parameter 'alertRuleId' must be defined.");
        url_ = url_.replace("{alertRuleId}", encodeURIComponent("" + alertRuleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAlertsDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAlertsDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processAlertsDELETE(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    register(body: RegisterUserDto | undefined): Observable<UserDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Auth/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDtoApiResponse>;
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<UserDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    login(body: LoginUserDto | undefined): Observable<LoginResponseDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Auth/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LoginResponseDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LoginResponseDtoApiResponse>;
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<LoginResponseDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoginResponseDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    me(): Observable<UserDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Auth/me";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMe(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMe(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDtoApiResponse>;
        }));
    }

    protected processMe(response: HttpResponseBase): Observable<UserDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    categoriesPOST(body: CreateCategoryDto | undefined): Observable<CategoryDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Categories";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCategoriesPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCategoriesPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CategoryDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CategoryDtoApiResponse>;
        }));
    }

    protected processCategoriesPOST(response: HttpResponseBase): Observable<CategoryDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CategoryDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    categoriesGET(): Observable<CategoryDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Categories";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCategoriesGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCategoriesGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CategoryDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CategoryDtoIEnumerableApiResponse>;
        }));
    }

    protected processCategoriesGET(response: HttpResponseBase): Observable<CategoryDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CategoryDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    categoriesGET2(categoryIdOrSlug: string): Observable<CategoryDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Categories/{categoryIdOrSlug}";
        if (categoryIdOrSlug === undefined || categoryIdOrSlug === null)
            throw new Error("The parameter 'categoryIdOrSlug' must be defined.");
        url_ = url_.replace("{categoryIdOrSlug}", encodeURIComponent("" + categoryIdOrSlug));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCategoriesGET2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCategoriesGET2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CategoryDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CategoryDtoApiResponse>;
        }));
    }

    protected processCategoriesGET2(response: HttpResponseBase): Observable<CategoryDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CategoryDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    categoriesPUT(categoryId: string, body: UpdateCategoryDto | undefined): Observable<CategoryDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Categories/{categoryId}";
        if (categoryId === undefined || categoryId === null)
            throw new Error("The parameter 'categoryId' must be defined.");
        url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCategoriesPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCategoriesPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CategoryDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CategoryDtoApiResponse>;
        }));
    }

    protected processCategoriesPUT(response: HttpResponseBase): Observable<CategoryDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CategoryDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    categoriesDELETE(categoryId: string): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/api/Categories/{categoryId}";
        if (categoryId === undefined || categoryId === null)
            throw new Error("The parameter 'categoryId' must be defined.");
        url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCategoriesDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCategoriesDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processCategoriesDELETE(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    stats(): Observable<DashboardStatsDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Dashboard/stats";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStats(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DashboardStatsDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DashboardStatsDtoApiResponse>;
        }));
    }

    protected processStats(response: HttpResponseBase): Observable<DashboardStatsDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DashboardStatsDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    success(): Observable<ObjectApiResponse> {
        let url_ = this.baseUrl + "/api/Example/success";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSuccess(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSuccess(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResponse>;
        }));
    }

    protected processSuccess(response: HttpResponseBase): Observable<ObjectApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param skip (optional) 
     * @param take (optional) 
     * @return OK
     */
    paginated(pageNumber: number | undefined, pageSize: number | undefined, skip: number | undefined, take: number | undefined): Observable<ObjectPagedResponse> {
        let url_ = this.baseUrl + "/api/Example/paginated?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPaginated(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPaginated(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectPagedResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectPagedResponse>;
        }));
    }

    protected processPaginated(response: HttpResponseBase): Observable<ObjectPagedResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectPagedResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    result(id: number): Observable<ObjectApiResponse> {
        let url_ = this.baseUrl + "/api/Example/result/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResult(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResult(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResponse>;
        }));
    }

    protected processResult(response: HttpResponseBase): Observable<ObjectApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    error(type: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Example/error/{type}";
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined.");
        url_ = url_.replace("{type}", encodeURIComponent("" + type));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processError(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processError(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processError(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    validate(body: ValidationExampleRequest | undefined): Observable<StringApiResponse> {
        let url_ = this.baseUrl + "/api/Example/validate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StringApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StringApiResponse>;
        }));
    }

    protected processValidate(response: HttpResponseBase): Observable<StringApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    utilities(body: UtilitiesExampleRequest | undefined): Observable<ObjectApiResponse> {
        let url_ = this.baseUrl + "/api/Example/utilities";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUtilities(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUtilities(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResponse>;
        }));
    }

    protected processUtilities(response: HttpResponseBase): Observable<ObjectApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    mappingsPOST(body: CreateProductSellerMappingDto | undefined): Observable<ProductSellerMappingDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Mappings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMappingsPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMappingsPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductSellerMappingDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductSellerMappingDtoApiResponse>;
        }));
    }

    protected processMappingsPOST(response: HttpResponseBase): Observable<ProductSellerMappingDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductSellerMappingDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param canonicalProductId (optional) 
     * @return OK
     */
    mappingsGET(canonicalProductId: string | undefined): Observable<ProductSellerMappingDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Mappings?";
        if (canonicalProductId === null)
            throw new Error("The parameter 'canonicalProductId' cannot be null.");
        else if (canonicalProductId !== undefined)
            url_ += "canonicalProductId=" + encodeURIComponent("" + canonicalProductId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMappingsGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMappingsGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductSellerMappingDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductSellerMappingDtoIEnumerableApiResponse>;
        }));
    }

    protected processMappingsGET(response: HttpResponseBase): Observable<ProductSellerMappingDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductSellerMappingDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    active(): Observable<ProductSellerMappingDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Mappings/active";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActive(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActive(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductSellerMappingDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductSellerMappingDtoIEnumerableApiResponse>;
        }));
    }

    protected processActive(response: HttpResponseBase): Observable<ProductSellerMappingDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductSellerMappingDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    mappingsPUT(mappingId: string, body: UpdateProductSellerMappingDto | undefined): Observable<ProductSellerMappingDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Mappings/{mappingId}";
        if (mappingId === undefined || mappingId === null)
            throw new Error("The parameter 'mappingId' must be defined.");
        url_ = url_.replace("{mappingId}", encodeURIComponent("" + mappingId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMappingsPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMappingsPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductSellerMappingDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductSellerMappingDtoApiResponse>;
        }));
    }

    protected processMappingsPUT(response: HttpResponseBase): Observable<ProductSellerMappingDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductSellerMappingDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    mappingsDELETE(mappingId: string): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/api/Mappings/{mappingId}";
        if (mappingId === undefined || mappingId === null)
            throw new Error("The parameter 'mappingId' must be defined.");
        url_ = url_.replace("{mappingId}", encodeURIComponent("" + mappingId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMappingsDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMappingsDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processMappingsDELETE(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    scrapeNow(mappingId: string): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/api/Mappings/{mappingId}/scrape-now";
        if (mappingId === undefined || mappingId === null)
            throw new Error("The parameter 'mappingId' must be defined.");
        url_ = url_.replace("{mappingId}", encodeURIComponent("" + mappingId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processScrapeNow(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processScrapeNow(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processScrapeNow(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    analyzeUrl(body: AnalyzeUrlRequest | undefined): Observable<DiscoveryResultApiResponse> {
        let url_ = this.baseUrl + "/api/ProductDiscovery/analyze-url";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAnalyzeUrl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAnalyzeUrl(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DiscoveryResultApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DiscoveryResultApiResponse>;
        }));
    }

    protected processAnalyzeUrl(response: HttpResponseBase): Observable<DiscoveryResultApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DiscoveryResultApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ApiResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    bulkAnalyze(body: BulkAnalyzeRequest | undefined): Observable<DiscoveryResultApiResponse> {
        let url_ = this.baseUrl + "/api/ProductDiscovery/bulk-analyze";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBulkAnalyze(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBulkAnalyze(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DiscoveryResultApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DiscoveryResultApiResponse>;
        }));
    }

    protected processBulkAnalyze(response: HttpResponseBase): Observable<DiscoveryResultApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DiscoveryResultApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ApiResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param status (optional) 
     * @param categoryId (optional) 
     * @param discoveredByUserId (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param searchTerm (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param sortBy (optional) 
     * @param sortDescending (optional) 
     * @return OK
     */
    candidates(status: DiscoveryStatus | undefined, categoryId: string | undefined, discoveredByUserId: string | undefined, fromDate: Date | undefined, toDate: Date | undefined, searchTerm: string | undefined, pageNumber: number | undefined, pageSize: number | undefined, sortBy: string | undefined, sortDescending: boolean | undefined): Observable<ProductDiscoveryCandidateDtoPagedResponse> {
        let url_ = this.baseUrl + "/api/ProductDiscovery/candidates?";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        if (categoryId === null)
            throw new Error("The parameter 'categoryId' cannot be null.");
        else if (categoryId !== undefined)
            url_ += "CategoryId=" + encodeURIComponent("" + categoryId) + "&";
        if (discoveredByUserId === null)
            throw new Error("The parameter 'discoveredByUserId' cannot be null.");
        else if (discoveredByUserId !== undefined)
            url_ += "DiscoveredByUserId=" + encodeURIComponent("" + discoveredByUserId) + "&";
        if (fromDate === null)
            throw new Error("The parameter 'fromDate' cannot be null.");
        else if (fromDate !== undefined)
            url_ += "FromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toISOString() : "") + "&";
        if (toDate === null)
            throw new Error("The parameter 'toDate' cannot be null.");
        else if (toDate !== undefined)
            url_ += "ToDate=" + encodeURIComponent(toDate ? "" + toDate.toISOString() : "") + "&";
        if (searchTerm === null)
            throw new Error("The parameter 'searchTerm' cannot be null.");
        else if (searchTerm !== undefined)
            url_ += "SearchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortDescending === null)
            throw new Error("The parameter 'sortDescending' cannot be null.");
        else if (sortDescending !== undefined)
            url_ += "SortDescending=" + encodeURIComponent("" + sortDescending) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCandidates(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCandidates(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductDiscoveryCandidateDtoPagedResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductDiscoveryCandidateDtoPagedResponse>;
        }));
    }

    protected processCandidates(response: HttpResponseBase): Observable<ProductDiscoveryCandidateDtoPagedResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductDiscoveryCandidateDtoPagedResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ApiResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    candidates2(candidateId: string): Observable<ProductDiscoveryCandidateDtoApiResponse> {
        let url_ = this.baseUrl + "/api/ProductDiscovery/candidates/{candidateId}";
        if (candidateId === undefined || candidateId === null)
            throw new Error("The parameter 'candidateId' must be defined.");
        url_ = url_.replace("{candidateId}", encodeURIComponent("" + candidateId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCandidates2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCandidates2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductDiscoveryCandidateDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductDiscoveryCandidateDtoApiResponse>;
        }));
    }

    protected processCandidates2(response: HttpResponseBase): Observable<ProductDiscoveryCandidateDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductDiscoveryCandidateDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ApiResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    approve(candidateId: string, body: ApprovalRequest | undefined): Observable<ApprovalResultApiResponse> {
        let url_ = this.baseUrl + "/api/ProductDiscovery/candidates/{candidateId}/approve";
        if (candidateId === undefined || candidateId === null)
            throw new Error("The parameter 'candidateId' must be defined.");
        url_ = url_.replace("{candidateId}", encodeURIComponent("" + candidateId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApprove(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApprove(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApprovalResultApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApprovalResultApiResponse>;
        }));
    }

    protected processApprove(response: HttpResponseBase): Observable<ApprovalResultApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApprovalResultApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ApiResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ApiResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ApiResponse.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    reject(candidateId: string, body: RejectionRequest | undefined): Observable<ApprovalResultApiResponse> {
        let url_ = this.baseUrl + "/api/ProductDiscovery/candidates/{candidateId}/reject";
        if (candidateId === undefined || candidateId === null)
            throw new Error("The parameter 'candidateId' must be defined.");
        url_ = url_.replace("{candidateId}", encodeURIComponent("" + candidateId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReject(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApprovalResultApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApprovalResultApiResponse>;
        }));
    }

    protected processReject(response: HttpResponseBase): Observable<ApprovalResultApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApprovalResultApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ApiResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ApiResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ApiResponse.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param limit (optional) 
     * @return OK
     */
    similarProducts(candidateId: string, limit: number | undefined): Observable<SimilarProductResultListApiResponse> {
        let url_ = this.baseUrl + "/api/ProductDiscovery/similar-products/{candidateId}?";
        if (candidateId === undefined || candidateId === null)
            throw new Error("The parameter 'candidateId' must be defined.");
        url_ = url_.replace("{candidateId}", encodeURIComponent("" + candidateId));
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSimilarProducts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSimilarProducts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SimilarProductResultListApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SimilarProductResultListApiResponse>;
        }));
    }

    protected processSimilarProducts(response: HttpResponseBase): Observable<SimilarProductResultListApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SimilarProductResultListApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ApiResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param grouping (optional) 
     * @return OK
     */
    statistics(startDate: Date, endDate: Date, grouping: string | undefined): Observable<ObjectApiResponse> {
        let url_ = this.baseUrl + "/api/ProductDiscovery/statistics?";
        if (startDate === undefined || startDate === null)
            throw new Error("The parameter 'startDate' must be defined and cannot be null.");
        else
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === undefined || endDate === null)
            throw new Error("The parameter 'endDate' must be defined and cannot be null.");
        else
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        if (grouping === null)
            throw new Error("The parameter 'grouping' cannot be null.");
        else if (grouping !== undefined)
            url_ += "Grouping=" + encodeURIComponent("" + grouping) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStatistics(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStatistics(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResponse>;
        }));
    }

    protected processStatistics(response: HttpResponseBase): Observable<ObjectApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ApiResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    retry(body: string[] | undefined): Observable<DiscoveryResultApiResponse> {
        let url_ = this.baseUrl + "/api/ProductDiscovery/retry";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRetry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRetry(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DiscoveryResultApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DiscoveryResultApiResponse>;
        }));
    }

    protected processRetry(response: HttpResponseBase): Observable<DiscoveryResultApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DiscoveryResultApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ApiResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    productsPOST(body: CreateProductDto | undefined): Observable<ProductDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Products";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProductsPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProductsPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductDtoApiResponse>;
        }));
    }

    protected processProductsPOST(response: HttpResponseBase): Observable<ProductDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param categoryId (optional) 
     * @param search (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return OK
     */
    productsGET(categoryId: string | undefined, search: string | undefined, page: number | undefined, pageSize: number | undefined): Observable<ProductDtoPagedResponse> {
        let url_ = this.baseUrl + "/api/Products?";
        if (categoryId === null)
            throw new Error("The parameter 'categoryId' cannot be null.");
        else if (categoryId !== undefined)
            url_ += "categoryId=" + encodeURIComponent("" + categoryId) + "&";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProductsGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProductsGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductDtoPagedResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductDtoPagedResponse>;
        }));
    }

    protected processProductsGET(response: HttpResponseBase): Observable<ProductDtoPagedResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductDtoPagedResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    productsGET2(productId: string): Observable<ProductDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Products/{productId}";
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProductsGET2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProductsGET2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductDtoApiResponse>;
        }));
    }

    protected processProductsGET2(response: HttpResponseBase): Observable<ProductDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    productsPUT(productId: string, body: UpdateProductDto | undefined): Observable<ProductDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Products/{productId}";
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProductsPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProductsPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductDtoApiResponse>;
        }));
    }

    protected processProductsPUT(response: HttpResponseBase): Observable<ProductDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    productsDELETE(productId: string): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/api/Products/{productId}";
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProductsDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProductsDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processProductsDELETE(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param sellerName (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param limit (optional) 
     * @return OK
     */
    priceHistory(productId: string, sellerName: string | undefined, startDate: Date | undefined, endDate: Date | undefined, limit: number | undefined): Observable<PriceHistoryDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Products/{productId}/price-history?";
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        if (sellerName === null)
            throw new Error("The parameter 'sellerName' cannot be null.");
        else if (sellerName !== undefined)
            url_ += "sellerName=" + encodeURIComponent("" + sellerName) + "&";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPriceHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPriceHistory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PriceHistoryDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PriceHistoryDtoIEnumerableApiResponse>;
        }));
    }

    protected processPriceHistory(response: HttpResponseBase): Observable<PriceHistoryDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PriceHistoryDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    public(): Observable<ObjectApiResponse> {
        let url_ = this.baseUrl + "/api/Sample/public";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPublic(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPublic(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResponse>;
        }));
    }

    protected processPublic(response: HttpResponseBase): Observable<ObjectApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    dataGET(): Observable<ObjectApiResponse> {
        let url_ = this.baseUrl + "/api/Sample/data";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDataGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDataGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResponse>;
        }));
    }

    protected processDataGET(response: HttpResponseBase): Observable<ObjectApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    dataPOST(body: any | undefined): Observable<ObjectApiResponse> {
        let url_ = this.baseUrl + "/api/Sample/data";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDataPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDataPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResponse>;
        }));
    }

    protected processDataPOST(response: HttpResponseBase): Observable<ObjectApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    admin(): Observable<ObjectApiResponse> {
        let url_ = this.baseUrl + "/api/Sample/admin";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdmin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdmin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResponse>;
        }));
    }

    protected processAdmin(response: HttpResponseBase): Observable<ObjectApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    dataGET2(userId: string): Observable<ObjectApiResponse> {
        let url_ = this.baseUrl + "/api/Sample/users/{userId}/data";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDataGET2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDataGET2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResponse>;
        }));
    }

    protected processDataGET2(response: HttpResponseBase): Observable<ObjectApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    internal(): Observable<ObjectApiResponse> {
        let url_ = this.baseUrl + "/api/Sample/internal";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInternal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInternal(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResponse>;
        }));
    }

    protected processInternal(response: HttpResponseBase): Observable<ObjectApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    custom(): Observable<ObjectApiResponse> {
        let url_ = this.baseUrl + "/api/Sample/custom";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCustom(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCustom(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResponse>;
        }));
    }

    protected processCustom(response: HttpResponseBase): Observable<ObjectApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    manualAuth(): Observable<ObjectApiResponse> {
        let url_ = this.baseUrl + "/api/Sample/manual-auth";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processManualAuth(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processManualAuth(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResponse>;
        }));
    }

    protected processManualAuth(response: HttpResponseBase): Observable<ObjectApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @param mappingId (optional) 
     * @param status (optional) 
     * @param errorCategory (optional) 
     * @param dateFrom (optional) 
     * @param dateTo (optional) 
     * @param sellerName (optional) 
     * @return OK
     */
    scraperLogs(page: number | undefined, pageSize: number | undefined, mappingId: string | undefined, status: string | undefined, errorCategory: string | undefined, dateFrom: Date | undefined, dateTo: Date | undefined, sellerName: string | undefined): Observable<ScraperRunLogSummaryDtoPagedResultDtoApiResponse> {
        let url_ = this.baseUrl + "/api/scraper-logs?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (mappingId === null)
            throw new Error("The parameter 'mappingId' cannot be null.");
        else if (mappingId !== undefined)
            url_ += "mappingId=" + encodeURIComponent("" + mappingId) + "&";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        if (errorCategory === null)
            throw new Error("The parameter 'errorCategory' cannot be null.");
        else if (errorCategory !== undefined)
            url_ += "errorCategory=" + encodeURIComponent("" + errorCategory) + "&";
        if (dateFrom === null)
            throw new Error("The parameter 'dateFrom' cannot be null.");
        else if (dateFrom !== undefined)
            url_ += "dateFrom=" + encodeURIComponent(dateFrom ? "" + dateFrom.toISOString() : "") + "&";
        if (dateTo === null)
            throw new Error("The parameter 'dateTo' cannot be null.");
        else if (dateTo !== undefined)
            url_ += "dateTo=" + encodeURIComponent(dateTo ? "" + dateTo.toISOString() : "") + "&";
        if (sellerName === null)
            throw new Error("The parameter 'sellerName' cannot be null.");
        else if (sellerName !== undefined)
            url_ += "sellerName=" + encodeURIComponent("" + sellerName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processScraperLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processScraperLogs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ScraperRunLogSummaryDtoPagedResultDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ScraperRunLogSummaryDtoPagedResultDtoApiResponse>;
        }));
    }

    protected processScraperLogs(response: HttpResponseBase): Observable<ScraperRunLogSummaryDtoPagedResultDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ScraperRunLogSummaryDtoPagedResultDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    scraperLogs2(runId: string): Observable<ScraperRunLogDtoApiResponse> {
        let url_ = this.baseUrl + "/api/scraper-logs/{runId}";
        if (runId === undefined || runId === null)
            throw new Error("The parameter 'runId' must be defined.");
        url_ = url_.replace("{runId}", encodeURIComponent("" + runId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processScraperLogs2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processScraperLogs2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ScraperRunLogDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ScraperRunLogDtoApiResponse>;
        }));
    }

    protected processScraperLogs2(response: HttpResponseBase): Observable<ScraperRunLogDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ScraperRunLogDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return OK
     */
    mapping(mappingId: string, page: number | undefined, pageSize: number | undefined): Observable<ScraperRunLogSummaryDtoPagedResultDtoApiResponse> {
        let url_ = this.baseUrl + "/api/scraper-logs/mapping/{mappingId}?";
        if (mappingId === undefined || mappingId === null)
            throw new Error("The parameter 'mappingId' must be defined.");
        url_ = url_.replace("{mappingId}", encodeURIComponent("" + mappingId));
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMapping(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMapping(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ScraperRunLogSummaryDtoPagedResultDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ScraperRunLogSummaryDtoPagedResultDtoApiResponse>;
        }));
    }

    protected processMapping(response: HttpResponseBase): Observable<ScraperRunLogSummaryDtoPagedResultDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ScraperRunLogSummaryDtoPagedResultDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param count (optional) 
     * @return OK
     */
    recentFailures(count: number | undefined): Observable<ScraperRunLogSummaryDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/scraper-logs/recent-failures?";
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRecentFailures(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRecentFailures(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ScraperRunLogSummaryDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ScraperRunLogSummaryDtoIEnumerableApiResponse>;
        }));
    }

    protected processRecentFailures(response: HttpResponseBase): Observable<ScraperRunLogSummaryDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ScraperRunLogSummaryDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param count (optional) 
     * @return OK
     */
    recent(mappingId: string, count: number | undefined): Observable<ScraperRunLogSummaryDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/scraper-logs/mapping/{mappingId}/recent?";
        if (mappingId === undefined || mappingId === null)
            throw new Error("The parameter 'mappingId' must be defined.");
        url_ = url_.replace("{mappingId}", encodeURIComponent("" + mappingId));
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRecent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRecent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ScraperRunLogSummaryDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ScraperRunLogSummaryDtoIEnumerableApiResponse>;
        }));
    }

    protected processRecent(response: HttpResponseBase): Observable<ScraperRunLogSummaryDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ScraperRunLogSummaryDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param dateFrom (optional) 
     * @param dateTo (optional) 
     * @param mappingId (optional) 
     * @return OK
     */
    statistics2(dateFrom: Date | undefined, dateTo: Date | undefined, mappingId: string | undefined): Observable<ScraperRunStatisticsDtoApiResponse> {
        let url_ = this.baseUrl + "/api/scraper-logs/statistics?";
        if (dateFrom === null)
            throw new Error("The parameter 'dateFrom' cannot be null.");
        else if (dateFrom !== undefined)
            url_ += "dateFrom=" + encodeURIComponent(dateFrom ? "" + dateFrom.toISOString() : "") + "&";
        if (dateTo === null)
            throw new Error("The parameter 'dateTo' cannot be null.");
        else if (dateTo !== undefined)
            url_ += "dateTo=" + encodeURIComponent(dateTo ? "" + dateTo.toISOString() : "") + "&";
        if (mappingId === null)
            throw new Error("The parameter 'mappingId' cannot be null.");
        else if (mappingId !== undefined)
            url_ += "mappingId=" + encodeURIComponent("" + mappingId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStatistics2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStatistics2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ScraperRunStatisticsDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ScraperRunStatisticsDtoApiResponse>;
        }));
    }

    protected processStatistics2(response: HttpResponseBase): Observable<ScraperRunStatisticsDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ScraperRunStatisticsDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    retryChain(runId: string): Observable<ScraperRunLogDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/scraper-logs/{runId}/retry-chain";
        if (runId === undefined || runId === null)
            throw new Error("The parameter 'runId' must be defined.");
        url_ = url_.replace("{runId}", encodeURIComponent("" + runId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRetryChain(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRetryChain(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ScraperRunLogDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ScraperRunLogDtoIEnumerableApiResponse>;
        }));
    }

    protected processRetryChain(response: HttpResponseBase): Observable<ScraperRunLogDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ScraperRunLogDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param dateFrom (optional) 
     * @param dateTo (optional) 
     * @return OK
     */
    performanceMetrics(dateFrom: Date | undefined, dateTo: Date | undefined): Observable<SellerPerformanceMetricDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/scraper-logs/performance-metrics?";
        if (dateFrom === null)
            throw new Error("The parameter 'dateFrom' cannot be null.");
        else if (dateFrom !== undefined)
            url_ += "dateFrom=" + encodeURIComponent(dateFrom ? "" + dateFrom.toISOString() : "") + "&";
        if (dateTo === null)
            throw new Error("The parameter 'dateTo' cannot be null.");
        else if (dateTo !== undefined)
            url_ += "dateTo=" + encodeURIComponent(dateTo ? "" + dateTo.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPerformanceMetrics(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPerformanceMetrics(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SellerPerformanceMetricDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SellerPerformanceMetricDtoIEnumerableApiResponse>;
        }));
    }

    protected processPerformanceMetrics(response: HttpResponseBase): Observable<SellerPerformanceMetricDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SellerPerformanceMetricDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    inProgress(): Observable<ScraperRunLogSummaryDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/scraper-logs/in-progress";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInProgress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInProgress(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ScraperRunLogSummaryDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ScraperRunLogSummaryDtoIEnumerableApiResponse>;
        }));
    }

    protected processInProgress(response: HttpResponseBase): Observable<ScraperRunLogSummaryDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ScraperRunLogSummaryDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param daysToKeep (optional) 
     * @return OK
     */
    cleanup(daysToKeep: number | undefined): Observable<Int32ApiResponse> {
        let url_ = this.baseUrl + "/api/scraper-logs/cleanup?";
        if (daysToKeep === null)
            throw new Error("The parameter 'daysToKeep' cannot be null.");
        else if (daysToKeep !== undefined)
            url_ += "daysToKeep=" + encodeURIComponent("" + daysToKeep) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCleanup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCleanup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Int32ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Int32ApiResponse>;
        }));
    }

    protected processCleanup(response: HttpResponseBase): Observable<Int32ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Int32ApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    all(): Observable<ScraperSiteConfigurationDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/site-configs/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ScraperSiteConfigurationDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ScraperSiteConfigurationDtoIEnumerableApiResponse>;
        }));
    }

    protected processAll(response: HttpResponseBase): Observable<ScraperSiteConfigurationDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ScraperSiteConfigurationDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    siteConfigsPOST(body: CreateScraperSiteConfigurationDto | undefined): Observable<ScraperSiteConfigurationDtoApiResponse> {
        let url_ = this.baseUrl + "/api/site-configs";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSiteConfigsPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSiteConfigsPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ScraperSiteConfigurationDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ScraperSiteConfigurationDtoApiResponse>;
        }));
    }

    protected processSiteConfigsPOST(response: HttpResponseBase): Observable<ScraperSiteConfigurationDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ScraperSiteConfigurationDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param domain (optional) 
     * @return OK
     */
    siteConfigsGET(domain: string | undefined): Observable<ScraperSiteConfigurationDtoApiResponse> {
        let url_ = this.baseUrl + "/api/site-configs?";
        if (domain === null)
            throw new Error("The parameter 'domain' cannot be null.");
        else if (domain !== undefined)
            url_ += "domain=" + encodeURIComponent("" + domain) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSiteConfigsGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSiteConfigsGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ScraperSiteConfigurationDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ScraperSiteConfigurationDtoApiResponse>;
        }));
    }

    protected processSiteConfigsGET(response: HttpResponseBase): Observable<ScraperSiteConfigurationDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ScraperSiteConfigurationDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    siteConfigsGET2(siteConfigId: string): Observable<ScraperSiteConfigurationDtoApiResponse> {
        let url_ = this.baseUrl + "/api/site-configs/{siteConfigId}";
        if (siteConfigId === undefined || siteConfigId === null)
            throw new Error("The parameter 'siteConfigId' must be defined.");
        url_ = url_.replace("{siteConfigId}", encodeURIComponent("" + siteConfigId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSiteConfigsGET2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSiteConfigsGET2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ScraperSiteConfigurationDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ScraperSiteConfigurationDtoApiResponse>;
        }));
    }

    protected processSiteConfigsGET2(response: HttpResponseBase): Observable<ScraperSiteConfigurationDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ScraperSiteConfigurationDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    siteConfigsPUT(siteConfigId: string, body: UpdateScraperSiteConfigurationDto | undefined): Observable<ScraperSiteConfigurationDtoApiResponse> {
        let url_ = this.baseUrl + "/api/site-configs/{siteConfigId}";
        if (siteConfigId === undefined || siteConfigId === null)
            throw new Error("The parameter 'siteConfigId' must be defined.");
        url_ = url_.replace("{siteConfigId}", encodeURIComponent("" + siteConfigId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSiteConfigsPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSiteConfigsPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ScraperSiteConfigurationDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ScraperSiteConfigurationDtoApiResponse>;
        }));
    }

    protected processSiteConfigsPUT(response: HttpResponseBase): Observable<ScraperSiteConfigurationDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ScraperSiteConfigurationDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    siteConfigsDELETE(siteConfigId: string): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/api/site-configs/{siteConfigId}";
        if (siteConfigId === undefined || siteConfigId === null)
            throw new Error("The parameter 'siteConfigId' must be defined.");
        url_ = url_.replace("{siteConfigId}", encodeURIComponent("" + siteConfigId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSiteConfigsDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSiteConfigsDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processSiteConfigsDELETE(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param domain (optional) 
     * @param siteName (optional) 
     * @param isActive (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @param sortBy (optional) 
     * @param sortDescending (optional) 
     * @return OK
     */
    siteConfigurationGET(domain: string | undefined, siteName: string | undefined, isActive: boolean | undefined, page: number | undefined, pageSize: number | undefined, sortBy: string | undefined, sortDescending: boolean | undefined): Observable<SiteConfigurationDtoPagedResponse> {
        let url_ = this.baseUrl + "/api/SiteConfiguration?";
        if (domain === null)
            throw new Error("The parameter 'domain' cannot be null.");
        else if (domain !== undefined)
            url_ += "Domain=" + encodeURIComponent("" + domain) + "&";
        if (siteName === null)
            throw new Error("The parameter 'siteName' cannot be null.");
        else if (siteName !== undefined)
            url_ += "SiteName=" + encodeURIComponent("" + siteName) + "&";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortDescending === null)
            throw new Error("The parameter 'sortDescending' cannot be null.");
        else if (sortDescending !== undefined)
            url_ += "SortDescending=" + encodeURIComponent("" + sortDescending) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSiteConfigurationGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSiteConfigurationGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SiteConfigurationDtoPagedResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SiteConfigurationDtoPagedResponse>;
        }));
    }

    protected processSiteConfigurationGET(response: HttpResponseBase): Observable<SiteConfigurationDtoPagedResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SiteConfigurationDtoPagedResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    siteConfigurationPOST(body: SaveSiteConfigurationRequest | undefined): Observable<SiteConfigurationDtoApiResponse> {
        let url_ = this.baseUrl + "/api/SiteConfiguration";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSiteConfigurationPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSiteConfigurationPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SiteConfigurationDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SiteConfigurationDtoApiResponse>;
        }));
    }

    protected processSiteConfigurationPOST(response: HttpResponseBase): Observable<SiteConfigurationDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = SiteConfigurationDtoApiResponse.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ApiResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    siteConfigurationGET2(id: string): Observable<SiteConfigurationDtoApiResponse> {
        let url_ = this.baseUrl + "/api/SiteConfiguration/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSiteConfigurationGET2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSiteConfigurationGET2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SiteConfigurationDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SiteConfigurationDtoApiResponse>;
        }));
    }

    protected processSiteConfigurationGET2(response: HttpResponseBase): Observable<SiteConfigurationDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SiteConfigurationDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ApiResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    siteConfigurationPUT(id: string, body: SaveSiteConfigurationRequest | undefined): Observable<SiteConfigurationDtoApiResponse> {
        let url_ = this.baseUrl + "/api/SiteConfiguration/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSiteConfigurationPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSiteConfigurationPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SiteConfigurationDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SiteConfigurationDtoApiResponse>;
        }));
    }

    protected processSiteConfigurationPUT(response: HttpResponseBase): Observable<SiteConfigurationDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SiteConfigurationDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ApiResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ApiResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    siteConfigurationDELETE(id: string): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/api/SiteConfiguration/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSiteConfigurationDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSiteConfigurationDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processSiteConfigurationDELETE(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ApiResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    byDomain(domain: string): Observable<SiteConfigurationDtoApiResponse> {
        let url_ = this.baseUrl + "/api/SiteConfiguration/by-domain/{domain}";
        if (domain === undefined || domain === null)
            throw new Error("The parameter 'domain' must be defined.");
        url_ = url_.replace("{domain}", encodeURIComponent("" + domain));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processByDomain(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processByDomain(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SiteConfigurationDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SiteConfigurationDtoApiResponse>;
        }));
    }

    protected processByDomain(response: HttpResponseBase): Observable<SiteConfigurationDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SiteConfigurationDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ApiResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    active2(): Observable<SiteConfigurationDtoListApiResponse> {
        let url_ = this.baseUrl + "/api/SiteConfiguration/active";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActive2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActive2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SiteConfigurationDtoListApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SiteConfigurationDtoListApiResponse>;
        }));
    }

    protected processActive2(response: HttpResponseBase): Observable<SiteConfigurationDtoListApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SiteConfigurationDtoListApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    generateSelectors(body: GenerateSelectorsRequest | undefined): Observable<SelectorGenerationResultApiResponse> {
        let url_ = this.baseUrl + "/api/SiteConfiguration/generate-selectors";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerateSelectors(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerateSelectors(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectorGenerationResultApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectorGenerationResultApiResponse>;
        }));
    }

    protected processGenerateSelectors(response: HttpResponseBase): Observable<SelectorGenerationResultApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SelectorGenerationResultApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ApiResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    testSelectors(body: TestSelectorsRequest | undefined): Observable<SelectorTestResultApiResponse> {
        let url_ = this.baseUrl + "/api/SiteConfiguration/test-selectors";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestSelectors(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestSelectors(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectorTestResultApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectorTestResultApiResponse>;
        }));
    }

    protected processTestSelectors(response: HttpResponseBase): Observable<SelectorTestResultApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SelectorTestResultApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ApiResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    suggestImprovements(body: SelectorImprovementRequest | undefined): Observable<SelectorSuggestionListApiResponse> {
        let url_ = this.baseUrl + "/api/SiteConfiguration/suggest-improvements";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSuggestImprovements(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSuggestImprovements(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectorSuggestionListApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectorSuggestionListApiResponse>;
        }));
    }

    protected processSuggestImprovements(response: HttpResponseBase): Observable<SelectorSuggestionListApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SelectorSuggestionListApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ApiResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class AlertRuleDto implements IAlertRuleDto {
    alertRuleId?: string;
    userId?: string;
    canonicalProductId?: string;
    conditionType?: string | undefined;
    thresholdValue?: number | undefined;
    percentageValue?: number | undefined;
    specificSellerName?: string | undefined;
    notificationFrequencyMinutes?: number;
    isActive?: boolean;
    lastNotifiedAt?: Date | undefined;
    createdAt?: Date;
    updatedAt?: Date;
    ruleDescription?: string | undefined;
    user?: UserDto;
    product?: ProductDto;

    constructor(data?: IAlertRuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alertRuleId = _data["alertRuleId"];
            this.userId = _data["userId"];
            this.canonicalProductId = _data["canonicalProductId"];
            this.conditionType = _data["conditionType"];
            this.thresholdValue = _data["thresholdValue"];
            this.percentageValue = _data["percentageValue"];
            this.specificSellerName = _data["specificSellerName"];
            this.notificationFrequencyMinutes = _data["notificationFrequencyMinutes"];
            this.isActive = _data["isActive"];
            this.lastNotifiedAt = _data["lastNotifiedAt"] ? new Date(_data["lastNotifiedAt"].toString()) : <any>undefined;
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.ruleDescription = _data["ruleDescription"];
            this.user = _data["user"] ? UserDto.fromJS(_data["user"]) : <any>undefined;
            this.product = _data["product"] ? ProductDto.fromJS(_data["product"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AlertRuleDto {
        data = typeof data === 'object' ? data : {};
        let result = new AlertRuleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["alertRuleId"] = this.alertRuleId;
        data["userId"] = this.userId;
        data["canonicalProductId"] = this.canonicalProductId;
        data["conditionType"] = this.conditionType;
        data["thresholdValue"] = this.thresholdValue;
        data["percentageValue"] = this.percentageValue;
        data["specificSellerName"] = this.specificSellerName;
        data["notificationFrequencyMinutes"] = this.notificationFrequencyMinutes;
        data["isActive"] = this.isActive;
        data["lastNotifiedAt"] = this.lastNotifiedAt ? this.lastNotifiedAt.toISOString() : <any>undefined;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["ruleDescription"] = this.ruleDescription;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        return data;
    }
}

export interface IAlertRuleDto {
    alertRuleId?: string;
    userId?: string;
    canonicalProductId?: string;
    conditionType?: string | undefined;
    thresholdValue?: number | undefined;
    percentageValue?: number | undefined;
    specificSellerName?: string | undefined;
    notificationFrequencyMinutes?: number;
    isActive?: boolean;
    lastNotifiedAt?: Date | undefined;
    createdAt?: Date;
    updatedAt?: Date;
    ruleDescription?: string | undefined;
    user?: UserDto;
    product?: ProductDto;
}

export class AlertRuleDtoApiResponse implements IAlertRuleDtoApiResponse {
    success?: boolean;
    data?: AlertRuleDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IAlertRuleDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"] ? AlertRuleDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): AlertRuleDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AlertRuleDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IAlertRuleDtoApiResponse {
    success?: boolean;
    data?: AlertRuleDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class AlertRuleDtoIEnumerableApiResponse implements IAlertRuleDtoIEnumerableApiResponse {
    success?: boolean;
    data?: AlertRuleDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IAlertRuleDtoIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(AlertRuleDto.fromJS(item));
            }
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): AlertRuleDtoIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AlertRuleDtoIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : <any>undefined);
        }
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IAlertRuleDtoIEnumerableApiResponse {
    success?: boolean;
    data?: AlertRuleDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class AlertRuleDtoPagedResponse implements IAlertRuleDtoPagedResponse {
    success?: boolean;
    data?: AlertRuleDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
    pagination?: PaginationMeta;

    constructor(data?: IAlertRuleDtoPagedResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(AlertRuleDto.fromJS(item));
            }
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
            this.pagination = _data["pagination"] ? PaginationMeta.fromJS(_data["pagination"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AlertRuleDtoPagedResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AlertRuleDtoPagedResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : <any>undefined);
        }
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        data["pagination"] = this.pagination ? this.pagination.toJSON() : <any>undefined;
        return data;
    }
}

export interface IAlertRuleDtoPagedResponse {
    success?: boolean;
    data?: AlertRuleDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
    pagination?: PaginationMeta;
}

export class AnalyzeUrlRequest implements IAnalyzeUrlRequest {
    url!: string;
    userId?: string | undefined;
    autoApprove?: boolean;
    autoApprovalThreshold?: number | undefined;

    constructor(data?: IAnalyzeUrlRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.url = _data["url"];
            this.userId = _data["userId"];
            this.autoApprove = _data["autoApprove"];
            this.autoApprovalThreshold = _data["autoApprovalThreshold"];
        }
    }

    static fromJS(data: any): AnalyzeUrlRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AnalyzeUrlRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        data["userId"] = this.userId;
        data["autoApprove"] = this.autoApprove;
        data["autoApprovalThreshold"] = this.autoApprovalThreshold;
        return data;
    }
}

export interface IAnalyzeUrlRequest {
    url: string;
    userId?: string | undefined;
    autoApprove?: boolean;
    autoApprovalThreshold?: number | undefined;
}

export class ApiResponse implements IApiResponse {
    success?: boolean;
    data?: any | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"];
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): ApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IApiResponse {
    success?: boolean;
    data?: any | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class ApprovalRequest implements IApprovalRequest {
    action!: WorkflowAction;
    comments?: string | undefined;
    modifications?: { [key: string]: any; } | undefined;
    createProduct?: boolean;
    categoryOverride?: string | undefined;
    productNameOverride?: string | undefined;

    constructor(data?: IApprovalRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.action = _data["action"];
            this.comments = _data["comments"];
            if (_data["modifications"]) {
                this.modifications = {} as any;
                for (let key in _data["modifications"]) {
                    if (_data["modifications"].hasOwnProperty(key))
                        (<any>this.modifications)![key] = _data["modifications"][key];
                }
            }
            this.createProduct = _data["createProduct"];
            this.categoryOverride = _data["categoryOverride"];
            this.productNameOverride = _data["productNameOverride"];
        }
    }

    static fromJS(data: any): ApprovalRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ApprovalRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["action"] = this.action;
        data["comments"] = this.comments;
        if (this.modifications) {
            data["modifications"] = {};
            for (let key in this.modifications) {
                if (this.modifications.hasOwnProperty(key))
                    (<any>data["modifications"])[key] = (<any>this.modifications)[key];
            }
        }
        data["createProduct"] = this.createProduct;
        data["categoryOverride"] = this.categoryOverride;
        data["productNameOverride"] = this.productNameOverride;
        return data;
    }
}

export interface IApprovalRequest {
    action: WorkflowAction;
    comments?: string | undefined;
    modifications?: { [key: string]: any; } | undefined;
    createProduct?: boolean;
    categoryOverride?: string | undefined;
    productNameOverride?: string | undefined;
}

export class ApprovalResult implements IApprovalResult {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    candidateId?: string;
    newStatus?: DiscoveryStatus;
    createdProductId?: string | undefined;
    workflowNotes?: string | undefined;

    constructor(data?: IApprovalResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.errorMessage = _data["errorMessage"];
            this.candidateId = _data["candidateId"];
            this.newStatus = _data["newStatus"];
            this.createdProductId = _data["createdProductId"];
            this.workflowNotes = _data["workflowNotes"];
        }
    }

    static fromJS(data: any): ApprovalResult {
        data = typeof data === 'object' ? data : {};
        let result = new ApprovalResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["errorMessage"] = this.errorMessage;
        data["candidateId"] = this.candidateId;
        data["newStatus"] = this.newStatus;
        data["createdProductId"] = this.createdProductId;
        data["workflowNotes"] = this.workflowNotes;
        return data;
    }
}

export interface IApprovalResult {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    candidateId?: string;
    newStatus?: DiscoveryStatus;
    createdProductId?: string | undefined;
    workflowNotes?: string | undefined;
}

export class ApprovalResultApiResponse implements IApprovalResultApiResponse {
    success?: boolean;
    data?: ApprovalResult;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IApprovalResultApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"] ? ApprovalResult.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): ApprovalResultApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ApprovalResultApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IApprovalResultApiResponse {
    success?: boolean;
    data?: ApprovalResult;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class BulkAnalyzeRequest implements IBulkAnalyzeRequest {
    urls!: string[];
    batchSize?: number | undefined;
    discoveryMethod?: string | undefined;
    userId?: string | undefined;

    constructor(data?: IBulkAnalyzeRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.urls = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["urls"])) {
                this.urls = [] as any;
                for (let item of _data["urls"])
                    this.urls!.push(item);
            }
            this.batchSize = _data["batchSize"];
            this.discoveryMethod = _data["discoveryMethod"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): BulkAnalyzeRequest {
        data = typeof data === 'object' ? data : {};
        let result = new BulkAnalyzeRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.urls)) {
            data["urls"] = [];
            for (let item of this.urls)
                data["urls"].push(item);
        }
        data["batchSize"] = this.batchSize;
        data["discoveryMethod"] = this.discoveryMethod;
        data["userId"] = this.userId;
        return data;
    }
}

export interface IBulkAnalyzeRequest {
    urls: string[];
    batchSize?: number | undefined;
    discoveryMethod?: string | undefined;
    userId?: string | undefined;
}

export class CategoryDto implements ICategoryDto {
    categoryId?: string;
    name?: string | undefined;
    slug?: string | undefined;
    description?: string | undefined;
    createdAt?: Date;
    updatedAt?: Date;

    constructor(data?: ICategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.categoryId = _data["categoryId"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.description = _data["description"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["categoryId"] = this.categoryId;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["description"] = this.description;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        return data;
    }
}

export interface ICategoryDto {
    categoryId?: string;
    name?: string | undefined;
    slug?: string | undefined;
    description?: string | undefined;
    createdAt?: Date;
    updatedAt?: Date;
}

export class CategoryDtoApiResponse implements ICategoryDtoApiResponse {
    success?: boolean;
    data?: CategoryDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: ICategoryDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"] ? CategoryDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): CategoryDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface ICategoryDtoApiResponse {
    success?: boolean;
    data?: CategoryDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class CategoryDtoIEnumerableApiResponse implements ICategoryDtoIEnumerableApiResponse {
    success?: boolean;
    data?: CategoryDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: ICategoryDtoIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(CategoryDto.fromJS(item));
            }
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): CategoryDtoIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryDtoIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : <any>undefined);
        }
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface ICategoryDtoIEnumerableApiResponse {
    success?: boolean;
    data?: CategoryDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class CreateAlertRuleDto implements ICreateAlertRuleDto {
    canonicalProductId!: string;
    conditionType!: string;
    thresholdValue?: number | undefined;
    percentageValue?: number | undefined;
    specificSellerName?: string | undefined;
    notificationFrequencyMinutes?: number;

    constructor(data?: ICreateAlertRuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.canonicalProductId = _data["canonicalProductId"];
            this.conditionType = _data["conditionType"];
            this.thresholdValue = _data["thresholdValue"];
            this.percentageValue = _data["percentageValue"];
            this.specificSellerName = _data["specificSellerName"];
            this.notificationFrequencyMinutes = _data["notificationFrequencyMinutes"];
        }
    }

    static fromJS(data: any): CreateAlertRuleDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAlertRuleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canonicalProductId"] = this.canonicalProductId;
        data["conditionType"] = this.conditionType;
        data["thresholdValue"] = this.thresholdValue;
        data["percentageValue"] = this.percentageValue;
        data["specificSellerName"] = this.specificSellerName;
        data["notificationFrequencyMinutes"] = this.notificationFrequencyMinutes;
        return data;
    }
}

export interface ICreateAlertRuleDto {
    canonicalProductId: string;
    conditionType: string;
    thresholdValue?: number | undefined;
    percentageValue?: number | undefined;
    specificSellerName?: string | undefined;
    notificationFrequencyMinutes?: number;
}

export class CreateCategoryDto implements ICreateCategoryDto {
    name!: string;
    slug?: string | undefined;
    description?: string | undefined;

    constructor(data?: ICreateCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): CreateCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["description"] = this.description;
        return data;
    }
}

export interface ICreateCategoryDto {
    name: string;
    slug?: string | undefined;
    description?: string | undefined;
}

export class CreateProductDto implements ICreateProductDto {
    name!: string;
    manufacturer?: string | undefined;
    modelNumber?: string | undefined;
    sku?: string | undefined;
    categoryId!: string;
    description?: string | undefined;
    specifications?: { [key: string]: any; } | undefined;

    constructor(data?: ICreateProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.manufacturer = _data["manufacturer"];
            this.modelNumber = _data["modelNumber"];
            this.sku = _data["sku"];
            this.categoryId = _data["categoryId"];
            this.description = _data["description"];
            if (_data["specifications"]) {
                this.specifications = {} as any;
                for (let key in _data["specifications"]) {
                    if (_data["specifications"].hasOwnProperty(key))
                        (<any>this.specifications)![key] = _data["specifications"][key];
                }
            }
        }
    }

    static fromJS(data: any): CreateProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["manufacturer"] = this.manufacturer;
        data["modelNumber"] = this.modelNumber;
        data["sku"] = this.sku;
        data["categoryId"] = this.categoryId;
        data["description"] = this.description;
        if (this.specifications) {
            data["specifications"] = {};
            for (let key in this.specifications) {
                if (this.specifications.hasOwnProperty(key))
                    (<any>data["specifications"])[key] = (<any>this.specifications)[key];
            }
        }
        return data;
    }
}

export interface ICreateProductDto {
    name: string;
    manufacturer?: string | undefined;
    modelNumber?: string | undefined;
    sku?: string | undefined;
    categoryId: string;
    description?: string | undefined;
    specifications?: { [key: string]: any; } | undefined;
}

export class CreateProductSellerMappingDto implements ICreateProductSellerMappingDto {
    canonicalProductId!: string;
    sellerName!: string;
    exactProductUrl!: string;
    isActiveForScraping?: boolean;
    scrapingFrequencyOverride?: string | undefined;
    siteConfigId?: string | undefined;

    constructor(data?: ICreateProductSellerMappingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.canonicalProductId = _data["canonicalProductId"];
            this.sellerName = _data["sellerName"];
            this.exactProductUrl = _data["exactProductUrl"];
            this.isActiveForScraping = _data["isActiveForScraping"];
            this.scrapingFrequencyOverride = _data["scrapingFrequencyOverride"];
            this.siteConfigId = _data["siteConfigId"];
        }
    }

    static fromJS(data: any): CreateProductSellerMappingDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductSellerMappingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canonicalProductId"] = this.canonicalProductId;
        data["sellerName"] = this.sellerName;
        data["exactProductUrl"] = this.exactProductUrl;
        data["isActiveForScraping"] = this.isActiveForScraping;
        data["scrapingFrequencyOverride"] = this.scrapingFrequencyOverride;
        data["siteConfigId"] = this.siteConfigId;
        return data;
    }
}

export interface ICreateProductSellerMappingDto {
    canonicalProductId: string;
    sellerName: string;
    exactProductUrl: string;
    isActiveForScraping?: boolean;
    scrapingFrequencyOverride?: string | undefined;
    siteConfigId?: string | undefined;
}

export class CreateScraperSiteConfigurationDto implements ICreateScraperSiteConfigurationDto {
    siteDomain!: string;
    productNameSelector!: string;
    priceSelector!: string;
    stockSelector!: string;
    sellerNameOnPageSelector?: string | undefined;
    defaultUserAgent?: string | undefined;
    additionalHeaders?: { [key: string]: string; } | undefined;
    isEnabled?: boolean;

    constructor(data?: ICreateScraperSiteConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.siteDomain = _data["siteDomain"];
            this.productNameSelector = _data["productNameSelector"];
            this.priceSelector = _data["priceSelector"];
            this.stockSelector = _data["stockSelector"];
            this.sellerNameOnPageSelector = _data["sellerNameOnPageSelector"];
            this.defaultUserAgent = _data["defaultUserAgent"];
            if (_data["additionalHeaders"]) {
                this.additionalHeaders = {} as any;
                for (let key in _data["additionalHeaders"]) {
                    if (_data["additionalHeaders"].hasOwnProperty(key))
                        (<any>this.additionalHeaders)![key] = _data["additionalHeaders"][key];
                }
            }
            this.isEnabled = _data["isEnabled"];
        }
    }

    static fromJS(data: any): CreateScraperSiteConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateScraperSiteConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["siteDomain"] = this.siteDomain;
        data["productNameSelector"] = this.productNameSelector;
        data["priceSelector"] = this.priceSelector;
        data["stockSelector"] = this.stockSelector;
        data["sellerNameOnPageSelector"] = this.sellerNameOnPageSelector;
        data["defaultUserAgent"] = this.defaultUserAgent;
        if (this.additionalHeaders) {
            data["additionalHeaders"] = {};
            for (let key in this.additionalHeaders) {
                if (this.additionalHeaders.hasOwnProperty(key))
                    (<any>data["additionalHeaders"])[key] = (<any>this.additionalHeaders)[key];
            }
        }
        data["isEnabled"] = this.isEnabled;
        return data;
    }
}

export interface ICreateScraperSiteConfigurationDto {
    siteDomain: string;
    productNameSelector: string;
    priceSelector: string;
    stockSelector: string;
    sellerNameOnPageSelector?: string | undefined;
    defaultUserAgent?: string | undefined;
    additionalHeaders?: { [key: string]: string; } | undefined;
    isEnabled?: boolean;
}

export class CreateUserDto implements ICreateUserDto {
    email!: string;
    password!: string;
    firstName?: string | undefined;
    lastName?: string | undefined;
    roles?: string[] | undefined;

    constructor(data?: ICreateUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data;
    }
}

export interface ICreateUserDto {
    email: string;
    password: string;
    firstName?: string | undefined;
    lastName?: string | undefined;
    roles?: string[] | undefined;
}

export class DashboardStatsDto implements IDashboardStatsDto {
    totalProducts?: number;
    totalCategories?: number;
    activeMappings?: number;
    activeAlerts?: number;
    totalUsers?: number | undefined;

    constructor(data?: IDashboardStatsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalProducts = _data["totalProducts"];
            this.totalCategories = _data["totalCategories"];
            this.activeMappings = _data["activeMappings"];
            this.activeAlerts = _data["activeAlerts"];
            this.totalUsers = _data["totalUsers"];
        }
    }

    static fromJS(data: any): DashboardStatsDto {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardStatsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalProducts"] = this.totalProducts;
        data["totalCategories"] = this.totalCategories;
        data["activeMappings"] = this.activeMappings;
        data["activeAlerts"] = this.activeAlerts;
        data["totalUsers"] = this.totalUsers;
        return data;
    }
}

export interface IDashboardStatsDto {
    totalProducts?: number;
    totalCategories?: number;
    activeMappings?: number;
    activeAlerts?: number;
    totalUsers?: number | undefined;
}

export class DashboardStatsDtoApiResponse implements IDashboardStatsDtoApiResponse {
    success?: boolean;
    data?: DashboardStatsDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IDashboardStatsDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"] ? DashboardStatsDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): DashboardStatsDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardStatsDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IDashboardStatsDtoApiResponse {
    success?: boolean;
    data?: DashboardStatsDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class DiscoveryMetadata implements IDiscoveryMetadata {
    processedUrls?: number;
    successfulExtractions?: number;
    failedExtractions?: number;
    processingTime?: string;
    warnings?: string[] | undefined;
    errors?: string[] | undefined;

    constructor(data?: IDiscoveryMetadata) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.processedUrls = _data["processedUrls"];
            this.successfulExtractions = _data["successfulExtractions"];
            this.failedExtractions = _data["failedExtractions"];
            this.processingTime = _data["processingTime"];
            if (Array.isArray(_data["warnings"])) {
                this.warnings = [] as any;
                for (let item of _data["warnings"])
                    this.warnings!.push(item);
            }
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): DiscoveryMetadata {
        data = typeof data === 'object' ? data : {};
        let result = new DiscoveryMetadata();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["processedUrls"] = this.processedUrls;
        data["successfulExtractions"] = this.successfulExtractions;
        data["failedExtractions"] = this.failedExtractions;
        data["processingTime"] = this.processingTime;
        if (Array.isArray(this.warnings)) {
            data["warnings"] = [];
            for (let item of this.warnings)
                data["warnings"].push(item);
        }
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IDiscoveryMetadata {
    processedUrls?: number;
    successfulExtractions?: number;
    failedExtractions?: number;
    processingTime?: string;
    warnings?: string[] | undefined;
    errors?: string[] | undefined;
}

export class DiscoveryResult implements IDiscoveryResult {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    candidates?: ProductDiscoveryCandidateDto[] | undefined;
    metadata?: DiscoveryMetadata;

    constructor(data?: IDiscoveryResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.errorMessage = _data["errorMessage"];
            if (Array.isArray(_data["candidates"])) {
                this.candidates = [] as any;
                for (let item of _data["candidates"])
                    this.candidates!.push(ProductDiscoveryCandidateDto.fromJS(item));
            }
            this.metadata = _data["metadata"] ? DiscoveryMetadata.fromJS(_data["metadata"]) : <any>undefined;
        }
    }

    static fromJS(data: any): DiscoveryResult {
        data = typeof data === 'object' ? data : {};
        let result = new DiscoveryResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["errorMessage"] = this.errorMessage;
        if (Array.isArray(this.candidates)) {
            data["candidates"] = [];
            for (let item of this.candidates)
                data["candidates"].push(item ? item.toJSON() : <any>undefined);
        }
        data["metadata"] = this.metadata ? this.metadata.toJSON() : <any>undefined;
        return data;
    }
}

export interface IDiscoveryResult {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    candidates?: ProductDiscoveryCandidateDto[] | undefined;
    metadata?: DiscoveryMetadata;
}

export class DiscoveryResultApiResponse implements IDiscoveryResultApiResponse {
    success?: boolean;
    data?: DiscoveryResult;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IDiscoveryResultApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"] ? DiscoveryResult.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): DiscoveryResultApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new DiscoveryResultApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IDiscoveryResultApiResponse {
    success?: boolean;
    data?: DiscoveryResult;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export enum DiscoveryStatus {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export class FieldTestResult implements IFieldTestResult {
    value?: string | undefined;
    success?: boolean;
    selector?: string | undefined;
    error?: string | undefined;

    constructor(data?: IFieldTestResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.success = _data["success"];
            this.selector = _data["selector"];
            this.error = _data["error"];
        }
    }

    static fromJS(data: any): FieldTestResult {
        data = typeof data === 'object' ? data : {};
        let result = new FieldTestResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["success"] = this.success;
        data["selector"] = this.selector;
        data["error"] = this.error;
        return data;
    }
}

export interface IFieldTestResult {
    value?: string | undefined;
    success?: boolean;
    selector?: string | undefined;
    error?: string | undefined;
}

export class GenerateSelectorsRequest implements IGenerateSelectorsRequest {
    htmlContent!: string;
    domain!: string;
    siteName?: string | undefined;
    notes?: string | undefined;

    constructor(data?: IGenerateSelectorsRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.htmlContent = _data["htmlContent"];
            this.domain = _data["domain"];
            this.siteName = _data["siteName"];
            this.notes = _data["notes"];
        }
    }

    static fromJS(data: any): GenerateSelectorsRequest {
        data = typeof data === 'object' ? data : {};
        let result = new GenerateSelectorsRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["htmlContent"] = this.htmlContent;
        data["domain"] = this.domain;
        data["siteName"] = this.siteName;
        data["notes"] = this.notes;
        return data;
    }
}

export interface IGenerateSelectorsRequest {
    htmlContent: string;
    domain: string;
    siteName?: string | undefined;
    notes?: string | undefined;
}

export class Int32ApiResponse implements IInt32ApiResponse {
    success?: boolean;
    data?: number;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IInt32ApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"];
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): Int32ApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new Int32ApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IInt32ApiResponse {
    success?: boolean;
    data?: number;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class LoginResponseDto implements ILoginResponseDto {
    token?: string | undefined;
    userId?: string;
    email?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    roles?: string[] | undefined;

    constructor(data?: ILoginResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
            this.userId = _data["userId"];
            this.email = _data["email"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
        }
    }

    static fromJS(data: any): LoginResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new LoginResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        data["userId"] = this.userId;
        data["email"] = this.email;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data;
    }
}

export interface ILoginResponseDto {
    token?: string | undefined;
    userId?: string;
    email?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    roles?: string[] | undefined;
}

export class LoginResponseDtoApiResponse implements ILoginResponseDtoApiResponse {
    success?: boolean;
    data?: LoginResponseDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: ILoginResponseDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"] ? LoginResponseDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): LoginResponseDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new LoginResponseDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface ILoginResponseDtoApiResponse {
    success?: boolean;
    data?: LoginResponseDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class LoginUserDto implements ILoginUserDto {
    email!: string;
    password!: string;

    constructor(data?: ILoginUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): LoginUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new LoginUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        return data;
    }
}

export interface ILoginUserDto {
    email: string;
    password: string;
}

export class ObjectApiResponse implements IObjectApiResponse {
    success?: boolean;
    data?: any | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IObjectApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"];
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): ObjectApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ObjectApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IObjectApiResponse {
    success?: boolean;
    data?: any | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class ObjectPagedResponse implements IObjectPagedResponse {
    success?: boolean;
    data?: any[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
    pagination?: PaginationMeta;

    constructor(data?: IObjectPagedResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(item);
            }
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
            this.pagination = _data["pagination"] ? PaginationMeta.fromJS(_data["pagination"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ObjectPagedResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ObjectPagedResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item);
        }
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        data["pagination"] = this.pagination ? this.pagination.toJSON() : <any>undefined;
        return data;
    }
}

export interface IObjectPagedResponse {
    success?: boolean;
    data?: any[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
    pagination?: PaginationMeta;
}

export class PaginationMeta implements IPaginationMeta {
    pageNumber?: number;
    pageSize?: number;
    totalCount?: number;
    readonly totalPages?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;
    readonly firstItemOnPage?: number;
    readonly lastItemOnPage?: number;

    constructor(data?: IPaginationMeta) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
            this.totalCount = _data["totalCount"];
            (<any>this).totalPages = _data["totalPages"];
            (<any>this).hasPreviousPage = _data["hasPreviousPage"];
            (<any>this).hasNextPage = _data["hasNextPage"];
            (<any>this).firstItemOnPage = _data["firstItemOnPage"];
            (<any>this).lastItemOnPage = _data["lastItemOnPage"];
        }
    }

    static fromJS(data: any): PaginationMeta {
        data = typeof data === 'object' ? data : {};
        let result = new PaginationMeta();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        data["totalCount"] = this.totalCount;
        data["totalPages"] = this.totalPages;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        data["firstItemOnPage"] = this.firstItemOnPage;
        data["lastItemOnPage"] = this.lastItemOnPage;
        return data;
    }
}

export interface IPaginationMeta {
    pageNumber?: number;
    pageSize?: number;
    totalCount?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    firstItemOnPage?: number;
    lastItemOnPage?: number;
}

export class PriceHistoryDto implements IPriceHistoryDto {
    timestamp?: Date;
    price?: number;
    stockStatus?: string | undefined;
    sourceUrl?: string | undefined;
    scrapedProductNameOnPage?: string | undefined;

    constructor(data?: IPriceHistoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.price = _data["price"];
            this.stockStatus = _data["stockStatus"];
            this.sourceUrl = _data["sourceUrl"];
            this.scrapedProductNameOnPage = _data["scrapedProductNameOnPage"];
        }
    }

    static fromJS(data: any): PriceHistoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new PriceHistoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["price"] = this.price;
        data["stockStatus"] = this.stockStatus;
        data["sourceUrl"] = this.sourceUrl;
        data["scrapedProductNameOnPage"] = this.scrapedProductNameOnPage;
        return data;
    }
}

export interface IPriceHistoryDto {
    timestamp?: Date;
    price?: number;
    stockStatus?: string | undefined;
    sourceUrl?: string | undefined;
    scrapedProductNameOnPage?: string | undefined;
}

export class PriceHistoryDtoIEnumerableApiResponse implements IPriceHistoryDtoIEnumerableApiResponse {
    success?: boolean;
    data?: PriceHistoryDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IPriceHistoryDtoIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(PriceHistoryDto.fromJS(item));
            }
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): PriceHistoryDtoIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PriceHistoryDtoIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : <any>undefined);
        }
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IPriceHistoryDtoIEnumerableApiResponse {
    success?: boolean;
    data?: PriceHistoryDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;
}

export class ProductDiscoveryCandidateDto implements IProductDiscoveryCandidateDto {
    candidateId?: string;
    sourceUrl?: string | undefined;
    extractedProductName?: string | undefined;
    extractedManufacturer?: string | undefined;
    extractedModelNumber?: string | undefined;
    extractedPrice?: number | undefined;
    extractedImageUrl?: string | undefined;
    extractedDescription?: string | undefined;
    extractedSpecifications?: { [key: string]: any; } | undefined;
    suggestedCategoryId?: string | undefined;
    categoryConfidenceScore?: number;
    similarProductId?: string | undefined;
    similarityScore?: number;
    discoveryMethod?: string | undefined;
    discoveredByUserId?: string | undefined;
    discoveredAt?: Date;
    status?: DiscoveryStatus;
    rejectionReason?: string | undefined;
    createdAt?: Date;
    updatedAt?: Date;
    suggestedCategory?: CategoryDto;
    similarProduct?: ProductDto;
    discoveredByUser?: UserDto;

    constructor(data?: IProductDiscoveryCandidateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.candidateId = _data["candidateId"];
            this.sourceUrl = _data["sourceUrl"];
            this.extractedProductName = _data["extractedProductName"];
            this.extractedManufacturer = _data["extractedManufacturer"];
            this.extractedModelNumber = _data["extractedModelNumber"];
            this.extractedPrice = _data["extractedPrice"];
            this.extractedImageUrl = _data["extractedImageUrl"];
            this.extractedDescription = _data["extractedDescription"];
            if (_data["extractedSpecifications"]) {
                this.extractedSpecifications = {} as any;
                for (let key in _data["extractedSpecifications"]) {
                    if (_data["extractedSpecifications"].hasOwnProperty(key))
                        (<any>this.extractedSpecifications)![key] = _data["extractedSpecifications"][key];
                }
            }
            this.suggestedCategoryId = _data["suggestedCategoryId"];
            this.categoryConfidenceScore = _data["categoryConfidenceScore"];
            this.similarProductId = _data["similarProductId"];
            this.similarityScore = _data["similarityScore"];
            this.discoveryMethod = _data["discoveryMethod"];
            this.discoveredByUserId = _data["discoveredByUserId"];
            this.discoveredAt = _data["discoveredAt"] ? new Date(_data["discoveredAt"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.rejectionReason = _data["rejectionReason"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.suggestedCategory = _data["suggestedCategory"] ? CategoryDto.fromJS(_data["suggestedCategory"]) : <any>undefined;
            this.similarProduct = _data["similarProduct"] ? ProductDto.fromJS(_data["similarProduct"]) : <any>undefined;
            this.discoveredByUser = _data["discoveredByUser"] ? UserDto.fromJS(_data["discoveredByUser"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProductDiscoveryCandidateDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductDiscoveryCandidateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["candidateId"] = this.candidateId;
        data["sourceUrl"] = this.sourceUrl;
        data["extractedProductName"] = this.extractedProductName;
        data["extractedManufacturer"] = this.extractedManufacturer;
        data["extractedModelNumber"] = this.extractedModelNumber;
        data["extractedPrice"] = this.extractedPrice;
        data["extractedImageUrl"] = this.extractedImageUrl;
        data["extractedDescription"] = this.extractedDescription;
        if (this.extractedSpecifications) {
            data["extractedSpecifications"] = {};
            for (let key in this.extractedSpecifications) {
                if (this.extractedSpecifications.hasOwnProperty(key))
                    (<any>data["extractedSpecifications"])[key] = (<any>this.extractedSpecifications)[key];
            }
        }
        data["suggestedCategoryId"] = this.suggestedCategoryId;
        data["categoryConfidenceScore"] = this.categoryConfidenceScore;
        data["similarProductId"] = this.similarProductId;
        data["similarityScore"] = this.similarityScore;
        data["discoveryMethod"] = this.discoveryMethod;
        data["discoveredByUserId"] = this.discoveredByUserId;
        data["discoveredAt"] = this.discoveredAt ? this.discoveredAt.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["rejectionReason"] = this.rejectionReason;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["suggestedCategory"] = this.suggestedCategory ? this.suggestedCategory.toJSON() : <any>undefined;
        data["similarProduct"] = this.similarProduct ? this.similarProduct.toJSON() : <any>undefined;
        data["discoveredByUser"] = this.discoveredByUser ? this.discoveredByUser.toJSON() : <any>undefined;
        return data;
    }
}

export interface IProductDiscoveryCandidateDto {
    candidateId?: string;
    sourceUrl?: string | undefined;
    extractedProductName?: string | undefined;
    extractedManufacturer?: string | undefined;
    extractedModelNumber?: string | undefined;
    extractedPrice?: number | undefined;
    extractedImageUrl?: string | undefined;
    extractedDescription?: string | undefined;
    extractedSpecifications?: { [key: string]: any; } | undefined;
    suggestedCategoryId?: string | undefined;
    categoryConfidenceScore?: number;
    similarProductId?: string | undefined;
    similarityScore?: number;
    discoveryMethod?: string | undefined;
    discoveredByUserId?: string | undefined;
    discoveredAt?: Date;
    status?: DiscoveryStatus;
    rejectionReason?: string | undefined;
    createdAt?: Date;
    updatedAt?: Date;
    suggestedCategory?: CategoryDto;
    similarProduct?: ProductDto;
    discoveredByUser?: UserDto;
}

export class ProductDiscoveryCandidateDtoApiResponse implements IProductDiscoveryCandidateDtoApiResponse {
    success?: boolean;
    data?: ProductDiscoveryCandidateDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IProductDiscoveryCandidateDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"] ? ProductDiscoveryCandidateDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): ProductDiscoveryCandidateDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ProductDiscoveryCandidateDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IProductDiscoveryCandidateDtoApiResponse {
    success?: boolean;
    data?: ProductDiscoveryCandidateDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class ProductDiscoveryCandidateDtoPagedResponse implements IProductDiscoveryCandidateDtoPagedResponse {
    success?: boolean;
    data?: ProductDiscoveryCandidateDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
    pagination?: PaginationMeta;

    constructor(data?: IProductDiscoveryCandidateDtoPagedResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(ProductDiscoveryCandidateDto.fromJS(item));
            }
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
            this.pagination = _data["pagination"] ? PaginationMeta.fromJS(_data["pagination"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProductDiscoveryCandidateDtoPagedResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ProductDiscoveryCandidateDtoPagedResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : <any>undefined);
        }
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        data["pagination"] = this.pagination ? this.pagination.toJSON() : <any>undefined;
        return data;
    }
}

export interface IProductDiscoveryCandidateDtoPagedResponse {
    success?: boolean;
    data?: ProductDiscoveryCandidateDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
    pagination?: PaginationMeta;
}

export class ProductDto implements IProductDto {
    productId?: string;
    name?: string | undefined;
    manufacturer?: string | undefined;
    modelNumber?: string | undefined;
    sku?: string | undefined;
    categoryId?: string;
    description?: string | undefined;
    specifications?: { [key: string]: any; } | undefined;
    isActive?: boolean;
    createdAt?: Date;
    updatedAt?: Date;
    category?: CategoryDto;

    constructor(data?: IProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.name = _data["name"];
            this.manufacturer = _data["manufacturer"];
            this.modelNumber = _data["modelNumber"];
            this.sku = _data["sku"];
            this.categoryId = _data["categoryId"];
            this.description = _data["description"];
            if (_data["specifications"]) {
                this.specifications = {} as any;
                for (let key in _data["specifications"]) {
                    if (_data["specifications"].hasOwnProperty(key))
                        (<any>this.specifications)![key] = _data["specifications"][key];
                }
            }
            this.isActive = _data["isActive"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.category = _data["category"] ? CategoryDto.fromJS(_data["category"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["name"] = this.name;
        data["manufacturer"] = this.manufacturer;
        data["modelNumber"] = this.modelNumber;
        data["sku"] = this.sku;
        data["categoryId"] = this.categoryId;
        data["description"] = this.description;
        if (this.specifications) {
            data["specifications"] = {};
            for (let key in this.specifications) {
                if (this.specifications.hasOwnProperty(key))
                    (<any>data["specifications"])[key] = (<any>this.specifications)[key];
            }
        }
        data["isActive"] = this.isActive;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["category"] = this.category ? this.category.toJSON() : <any>undefined;
        return data;
    }
}

export interface IProductDto {
    productId?: string;
    name?: string | undefined;
    manufacturer?: string | undefined;
    modelNumber?: string | undefined;
    sku?: string | undefined;
    categoryId?: string;
    description?: string | undefined;
    specifications?: { [key: string]: any; } | undefined;
    isActive?: boolean;
    createdAt?: Date;
    updatedAt?: Date;
    category?: CategoryDto;
}

export class ProductDtoApiResponse implements IProductDtoApiResponse {
    success?: boolean;
    data?: ProductDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IProductDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"] ? ProductDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): ProductDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ProductDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IProductDtoApiResponse {
    success?: boolean;
    data?: ProductDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class ProductDtoPagedResponse implements IProductDtoPagedResponse {
    success?: boolean;
    data?: ProductDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
    pagination?: PaginationMeta;

    constructor(data?: IProductDtoPagedResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(ProductDto.fromJS(item));
            }
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
            this.pagination = _data["pagination"] ? PaginationMeta.fromJS(_data["pagination"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProductDtoPagedResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ProductDtoPagedResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : <any>undefined);
        }
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        data["pagination"] = this.pagination ? this.pagination.toJSON() : <any>undefined;
        return data;
    }
}

export interface IProductDtoPagedResponse {
    success?: boolean;
    data?: ProductDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
    pagination?: PaginationMeta;
}

export class ProductSellerMappingDto implements IProductSellerMappingDto {
    mappingId?: string;
    canonicalProductId?: string;
    sellerName?: string | undefined;
    exactProductUrl?: string | undefined;
    isActiveForScraping?: boolean;
    scrapingFrequencyOverride?: string | undefined;
    siteConfigId?: string | undefined;
    lastScrapedAt?: Date | undefined;
    nextScrapeAt?: Date | undefined;
    lastScrapeStatus?: string | undefined;
    lastScrapeErrorCode?: string | undefined;
    consecutiveFailureCount?: number;
    createdAt?: Date;
    updatedAt?: Date;
    product?: ProductDto;
    siteConfiguration?: ScraperSiteConfigurationDto;

    constructor(data?: IProductSellerMappingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.mappingId = _data["mappingId"];
            this.canonicalProductId = _data["canonicalProductId"];
            this.sellerName = _data["sellerName"];
            this.exactProductUrl = _data["exactProductUrl"];
            this.isActiveForScraping = _data["isActiveForScraping"];
            this.scrapingFrequencyOverride = _data["scrapingFrequencyOverride"];
            this.siteConfigId = _data["siteConfigId"];
            this.lastScrapedAt = _data["lastScrapedAt"] ? new Date(_data["lastScrapedAt"].toString()) : <any>undefined;
            this.nextScrapeAt = _data["nextScrapeAt"] ? new Date(_data["nextScrapeAt"].toString()) : <any>undefined;
            this.lastScrapeStatus = _data["lastScrapeStatus"];
            this.lastScrapeErrorCode = _data["lastScrapeErrorCode"];
            this.consecutiveFailureCount = _data["consecutiveFailureCount"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.product = _data["product"] ? ProductDto.fromJS(_data["product"]) : <any>undefined;
            this.siteConfiguration = _data["siteConfiguration"] ? ScraperSiteConfigurationDto.fromJS(_data["siteConfiguration"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProductSellerMappingDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductSellerMappingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mappingId"] = this.mappingId;
        data["canonicalProductId"] = this.canonicalProductId;
        data["sellerName"] = this.sellerName;
        data["exactProductUrl"] = this.exactProductUrl;
        data["isActiveForScraping"] = this.isActiveForScraping;
        data["scrapingFrequencyOverride"] = this.scrapingFrequencyOverride;
        data["siteConfigId"] = this.siteConfigId;
        data["lastScrapedAt"] = this.lastScrapedAt ? this.lastScrapedAt.toISOString() : <any>undefined;
        data["nextScrapeAt"] = this.nextScrapeAt ? this.nextScrapeAt.toISOString() : <any>undefined;
        data["lastScrapeStatus"] = this.lastScrapeStatus;
        data["lastScrapeErrorCode"] = this.lastScrapeErrorCode;
        data["consecutiveFailureCount"] = this.consecutiveFailureCount;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        data["siteConfiguration"] = this.siteConfiguration ? this.siteConfiguration.toJSON() : <any>undefined;
        return data;
    }
}

export interface IProductSellerMappingDto {
    mappingId?: string;
    canonicalProductId?: string;
    sellerName?: string | undefined;
    exactProductUrl?: string | undefined;
    isActiveForScraping?: boolean;
    scrapingFrequencyOverride?: string | undefined;
    siteConfigId?: string | undefined;
    lastScrapedAt?: Date | undefined;
    nextScrapeAt?: Date | undefined;
    lastScrapeStatus?: string | undefined;
    lastScrapeErrorCode?: string | undefined;
    consecutiveFailureCount?: number;
    createdAt?: Date;
    updatedAt?: Date;
    product?: ProductDto;
    siteConfiguration?: ScraperSiteConfigurationDto;
}

export class ProductSellerMappingDtoApiResponse implements IProductSellerMappingDtoApiResponse {
    success?: boolean;
    data?: ProductSellerMappingDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IProductSellerMappingDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"] ? ProductSellerMappingDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): ProductSellerMappingDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ProductSellerMappingDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IProductSellerMappingDtoApiResponse {
    success?: boolean;
    data?: ProductSellerMappingDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class ProductSellerMappingDtoIEnumerableApiResponse implements IProductSellerMappingDtoIEnumerableApiResponse {
    success?: boolean;
    data?: ProductSellerMappingDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IProductSellerMappingDtoIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(ProductSellerMappingDto.fromJS(item));
            }
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): ProductSellerMappingDtoIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ProductSellerMappingDtoIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : <any>undefined);
        }
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IProductSellerMappingDtoIEnumerableApiResponse {
    success?: boolean;
    data?: ProductSellerMappingDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class RegisterUserDto implements IRegisterUserDto {
    email!: string;
    password!: string;
    firstName?: string | undefined;
    lastName?: string | undefined;

    constructor(data?: IRegisterUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
        }
    }

    static fromJS(data: any): RegisterUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        return data;
    }
}

export interface IRegisterUserDto {
    email: string;
    password: string;
    firstName?: string | undefined;
    lastName?: string | undefined;
}

export class RejectionRequest implements IRejectionRequest {
    reason!: string;
    comments?: string | undefined;
    blockDomain?: boolean;
    useForTraining?: boolean;

    constructor(data?: IRejectionRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.reason = _data["reason"];
            this.comments = _data["comments"];
            this.blockDomain = _data["blockDomain"];
            this.useForTraining = _data["useForTraining"];
        }
    }

    static fromJS(data: any): RejectionRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RejectionRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reason"] = this.reason;
        data["comments"] = this.comments;
        data["blockDomain"] = this.blockDomain;
        data["useForTraining"] = this.useForTraining;
        return data;
    }
}

export interface IRejectionRequest {
    reason: string;
    comments?: string | undefined;
    blockDomain?: boolean;
    useForTraining?: boolean;
}

export class SaveSiteConfigurationRequest implements ISaveSiteConfigurationRequest {
    domain!: string;
    siteName!: string;
    selectors!: SelectorSet;
    isActive?: boolean;
    notes?: string | undefined;
    testHtml?: string | undefined;

    constructor(data?: ISaveSiteConfigurationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.selectors = new SelectorSet();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.domain = _data["domain"];
            this.siteName = _data["siteName"];
            this.selectors = _data["selectors"] ? SelectorSet.fromJS(_data["selectors"]) : new SelectorSet();
            this.isActive = _data["isActive"];
            this.notes = _data["notes"];
            this.testHtml = _data["testHtml"];
        }
    }

    static fromJS(data: any): SaveSiteConfigurationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SaveSiteConfigurationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["domain"] = this.domain;
        data["siteName"] = this.siteName;
        data["selectors"] = this.selectors ? this.selectors.toJSON() : <any>undefined;
        data["isActive"] = this.isActive;
        data["notes"] = this.notes;
        data["testHtml"] = this.testHtml;
        return data;
    }
}

export interface ISaveSiteConfigurationRequest {
    domain: string;
    siteName: string;
    selectors: SelectorSet;
    isActive?: boolean;
    notes?: string | undefined;
    testHtml?: string | undefined;
}

export class ScraperRunLogDto implements IScraperRunLogDto {
    runId?: string;
    mappingId?: string;
    startedAt?: Date;
    completedAt?: Date | undefined;
    duration?: string | undefined;
    status?: string | undefined;
    statusDisplayName?: string | undefined;
    targetUrl?: string | undefined;
    userAgent?: string | undefined;
    additionalHeaders?: { [key: string]: string; } | undefined;
    selectors?: ScrapingSelectorsDto;
    httpStatusCode?: number | undefined;
    responseTime?: string | undefined;
    responseSizeBytes?: number | undefined;
    extractedProductName?: string | undefined;
    extractedPrice?: number | undefined;
    extractedStockStatus?: string | undefined;
    extractedSellerName?: string | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errorStackTrace?: string | undefined;
    errorCategory?: string | undefined;
    errorCategoryDisplayName?: string | undefined;
    attemptNumber?: number;
    parentRunId?: string | undefined;
    isRetry?: boolean;
    pageLoadTime?: string | undefined;
    parsingTime?: string | undefined;
    rawHtmlSnippet?: string | undefined;
    debugNotes?: string | undefined;
    mapping?: ProductSellerMappingDto;
    retryAttempts?: ScraperRunLogSummaryDto[] | undefined;
    createdAt?: Date;

    constructor(data?: IScraperRunLogDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.runId = _data["runId"];
            this.mappingId = _data["mappingId"];
            this.startedAt = _data["startedAt"] ? new Date(_data["startedAt"].toString()) : <any>undefined;
            this.completedAt = _data["completedAt"] ? new Date(_data["completedAt"].toString()) : <any>undefined;
            this.duration = _data["duration"];
            this.status = _data["status"];
            this.statusDisplayName = _data["statusDisplayName"];
            this.targetUrl = _data["targetUrl"];
            this.userAgent = _data["userAgent"];
            if (_data["additionalHeaders"]) {
                this.additionalHeaders = {} as any;
                for (let key in _data["additionalHeaders"]) {
                    if (_data["additionalHeaders"].hasOwnProperty(key))
                        (<any>this.additionalHeaders)![key] = _data["additionalHeaders"][key];
                }
            }
            this.selectors = _data["selectors"] ? ScrapingSelectorsDto.fromJS(_data["selectors"]) : <any>undefined;
            this.httpStatusCode = _data["httpStatusCode"];
            this.responseTime = _data["responseTime"];
            this.responseSizeBytes = _data["responseSizeBytes"];
            this.extractedProductName = _data["extractedProductName"];
            this.extractedPrice = _data["extractedPrice"];
            this.extractedStockStatus = _data["extractedStockStatus"];
            this.extractedSellerName = _data["extractedSellerName"];
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            this.errorStackTrace = _data["errorStackTrace"];
            this.errorCategory = _data["errorCategory"];
            this.errorCategoryDisplayName = _data["errorCategoryDisplayName"];
            this.attemptNumber = _data["attemptNumber"];
            this.parentRunId = _data["parentRunId"];
            this.isRetry = _data["isRetry"];
            this.pageLoadTime = _data["pageLoadTime"];
            this.parsingTime = _data["parsingTime"];
            this.rawHtmlSnippet = _data["rawHtmlSnippet"];
            this.debugNotes = _data["debugNotes"];
            this.mapping = _data["mapping"] ? ProductSellerMappingDto.fromJS(_data["mapping"]) : <any>undefined;
            if (Array.isArray(_data["retryAttempts"])) {
                this.retryAttempts = [] as any;
                for (let item of _data["retryAttempts"])
                    this.retryAttempts!.push(ScraperRunLogSummaryDto.fromJS(item));
            }
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ScraperRunLogDto {
        data = typeof data === 'object' ? data : {};
        let result = new ScraperRunLogDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["runId"] = this.runId;
        data["mappingId"] = this.mappingId;
        data["startedAt"] = this.startedAt ? this.startedAt.toISOString() : <any>undefined;
        data["completedAt"] = this.completedAt ? this.completedAt.toISOString() : <any>undefined;
        data["duration"] = this.duration;
        data["status"] = this.status;
        data["statusDisplayName"] = this.statusDisplayName;
        data["targetUrl"] = this.targetUrl;
        data["userAgent"] = this.userAgent;
        if (this.additionalHeaders) {
            data["additionalHeaders"] = {};
            for (let key in this.additionalHeaders) {
                if (this.additionalHeaders.hasOwnProperty(key))
                    (<any>data["additionalHeaders"])[key] = (<any>this.additionalHeaders)[key];
            }
        }
        data["selectors"] = this.selectors ? this.selectors.toJSON() : <any>undefined;
        data["httpStatusCode"] = this.httpStatusCode;
        data["responseTime"] = this.responseTime;
        data["responseSizeBytes"] = this.responseSizeBytes;
        data["extractedProductName"] = this.extractedProductName;
        data["extractedPrice"] = this.extractedPrice;
        data["extractedStockStatus"] = this.extractedStockStatus;
        data["extractedSellerName"] = this.extractedSellerName;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        data["errorStackTrace"] = this.errorStackTrace;
        data["errorCategory"] = this.errorCategory;
        data["errorCategoryDisplayName"] = this.errorCategoryDisplayName;
        data["attemptNumber"] = this.attemptNumber;
        data["parentRunId"] = this.parentRunId;
        data["isRetry"] = this.isRetry;
        data["pageLoadTime"] = this.pageLoadTime;
        data["parsingTime"] = this.parsingTime;
        data["rawHtmlSnippet"] = this.rawHtmlSnippet;
        data["debugNotes"] = this.debugNotes;
        data["mapping"] = this.mapping ? this.mapping.toJSON() : <any>undefined;
        if (Array.isArray(this.retryAttempts)) {
            data["retryAttempts"] = [];
            for (let item of this.retryAttempts)
                data["retryAttempts"].push(item ? item.toJSON() : <any>undefined);
        }
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        return data;
    }
}

export interface IScraperRunLogDto {
    runId?: string;
    mappingId?: string;
    startedAt?: Date;
    completedAt?: Date | undefined;
    duration?: string | undefined;
    status?: string | undefined;
    statusDisplayName?: string | undefined;
    targetUrl?: string | undefined;
    userAgent?: string | undefined;
    additionalHeaders?: { [key: string]: string; } | undefined;
    selectors?: ScrapingSelectorsDto;
    httpStatusCode?: number | undefined;
    responseTime?: string | undefined;
    responseSizeBytes?: number | undefined;
    extractedProductName?: string | undefined;
    extractedPrice?: number | undefined;
    extractedStockStatus?: string | undefined;
    extractedSellerName?: string | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errorStackTrace?: string | undefined;
    errorCategory?: string | undefined;
    errorCategoryDisplayName?: string | undefined;
    attemptNumber?: number;
    parentRunId?: string | undefined;
    isRetry?: boolean;
    pageLoadTime?: string | undefined;
    parsingTime?: string | undefined;
    rawHtmlSnippet?: string | undefined;
    debugNotes?: string | undefined;
    mapping?: ProductSellerMappingDto;
    retryAttempts?: ScraperRunLogSummaryDto[] | undefined;
    createdAt?: Date;
}

export class ScraperRunLogDtoApiResponse implements IScraperRunLogDtoApiResponse {
    success?: boolean;
    data?: ScraperRunLogDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IScraperRunLogDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"] ? ScraperRunLogDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): ScraperRunLogDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ScraperRunLogDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IScraperRunLogDtoApiResponse {
    success?: boolean;
    data?: ScraperRunLogDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class ScraperRunLogDtoIEnumerableApiResponse implements IScraperRunLogDtoIEnumerableApiResponse {
    success?: boolean;
    data?: ScraperRunLogDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IScraperRunLogDtoIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(ScraperRunLogDto.fromJS(item));
            }
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): ScraperRunLogDtoIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ScraperRunLogDtoIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : <any>undefined);
        }
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IScraperRunLogDtoIEnumerableApiResponse {
    success?: boolean;
    data?: ScraperRunLogDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class ScraperRunLogSummaryDto implements IScraperRunLogSummaryDto {
    runId?: string;
    mappingId?: string;
    startedAt?: Date;
    completedAt?: Date | undefined;
    duration?: string | undefined;
    status?: string | undefined;
    statusDisplayName?: string | undefined;
    targetUrl?: string | undefined;
    extractedPrice?: number | undefined;
    errorMessage?: string | undefined;
    errorCategory?: string | undefined;
    errorCategoryDisplayName?: string | undefined;
    attemptNumber?: number;
    isRetry?: boolean;
    responseTime?: string | undefined;
    sellerName?: string | undefined;
    productName?: string | undefined;

    constructor(data?: IScraperRunLogSummaryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.runId = _data["runId"];
            this.mappingId = _data["mappingId"];
            this.startedAt = _data["startedAt"] ? new Date(_data["startedAt"].toString()) : <any>undefined;
            this.completedAt = _data["completedAt"] ? new Date(_data["completedAt"].toString()) : <any>undefined;
            this.duration = _data["duration"];
            this.status = _data["status"];
            this.statusDisplayName = _data["statusDisplayName"];
            this.targetUrl = _data["targetUrl"];
            this.extractedPrice = _data["extractedPrice"];
            this.errorMessage = _data["errorMessage"];
            this.errorCategory = _data["errorCategory"];
            this.errorCategoryDisplayName = _data["errorCategoryDisplayName"];
            this.attemptNumber = _data["attemptNumber"];
            this.isRetry = _data["isRetry"];
            this.responseTime = _data["responseTime"];
            this.sellerName = _data["sellerName"];
            this.productName = _data["productName"];
        }
    }

    static fromJS(data: any): ScraperRunLogSummaryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ScraperRunLogSummaryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["runId"] = this.runId;
        data["mappingId"] = this.mappingId;
        data["startedAt"] = this.startedAt ? this.startedAt.toISOString() : <any>undefined;
        data["completedAt"] = this.completedAt ? this.completedAt.toISOString() : <any>undefined;
        data["duration"] = this.duration;
        data["status"] = this.status;
        data["statusDisplayName"] = this.statusDisplayName;
        data["targetUrl"] = this.targetUrl;
        data["extractedPrice"] = this.extractedPrice;
        data["errorMessage"] = this.errorMessage;
        data["errorCategory"] = this.errorCategory;
        data["errorCategoryDisplayName"] = this.errorCategoryDisplayName;
        data["attemptNumber"] = this.attemptNumber;
        data["isRetry"] = this.isRetry;
        data["responseTime"] = this.responseTime;
        data["sellerName"] = this.sellerName;
        data["productName"] = this.productName;
        return data;
    }
}

export interface IScraperRunLogSummaryDto {
    runId?: string;
    mappingId?: string;
    startedAt?: Date;
    completedAt?: Date | undefined;
    duration?: string | undefined;
    status?: string | undefined;
    statusDisplayName?: string | undefined;
    targetUrl?: string | undefined;
    extractedPrice?: number | undefined;
    errorMessage?: string | undefined;
    errorCategory?: string | undefined;
    errorCategoryDisplayName?: string | undefined;
    attemptNumber?: number;
    isRetry?: boolean;
    responseTime?: string | undefined;
    sellerName?: string | undefined;
    productName?: string | undefined;
}

export class ScraperRunLogSummaryDtoIEnumerableApiResponse implements IScraperRunLogSummaryDtoIEnumerableApiResponse {
    success?: boolean;
    data?: ScraperRunLogSummaryDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IScraperRunLogSummaryDtoIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(ScraperRunLogSummaryDto.fromJS(item));
            }
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): ScraperRunLogSummaryDtoIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ScraperRunLogSummaryDtoIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : <any>undefined);
        }
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IScraperRunLogSummaryDtoIEnumerableApiResponse {
    success?: boolean;
    data?: ScraperRunLogSummaryDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class ScraperRunLogSummaryDtoPagedResultDto implements IScraperRunLogSummaryDtoPagedResultDto {
    items?: ScraperRunLogSummaryDto[] | undefined;
    totalCount?: number;
    page?: number;
    pageSize?: number;
    readonly totalPages?: number;
    readonly hasNextPage?: boolean;
    readonly hasPreviousPage?: boolean;

    constructor(data?: IScraperRunLogSummaryDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ScraperRunLogSummaryDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            this.page = _data["page"];
            this.pageSize = _data["pageSize"];
            (<any>this).totalPages = _data["totalPages"];
            (<any>this).hasNextPage = _data["hasNextPage"];
            (<any>this).hasPreviousPage = _data["hasPreviousPage"];
        }
    }

    static fromJS(data: any): ScraperRunLogSummaryDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ScraperRunLogSummaryDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : <any>undefined);
        }
        data["totalCount"] = this.totalCount;
        data["page"] = this.page;
        data["pageSize"] = this.pageSize;
        data["totalPages"] = this.totalPages;
        data["hasNextPage"] = this.hasNextPage;
        data["hasPreviousPage"] = this.hasPreviousPage;
        return data;
    }
}

export interface IScraperRunLogSummaryDtoPagedResultDto {
    items?: ScraperRunLogSummaryDto[] | undefined;
    totalCount?: number;
    page?: number;
    pageSize?: number;
    totalPages?: number;
    hasNextPage?: boolean;
    hasPreviousPage?: boolean;
}

export class ScraperRunLogSummaryDtoPagedResultDtoApiResponse implements IScraperRunLogSummaryDtoPagedResultDtoApiResponse {
    success?: boolean;
    data?: ScraperRunLogSummaryDtoPagedResultDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IScraperRunLogSummaryDtoPagedResultDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"] ? ScraperRunLogSummaryDtoPagedResultDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): ScraperRunLogSummaryDtoPagedResultDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ScraperRunLogSummaryDtoPagedResultDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IScraperRunLogSummaryDtoPagedResultDtoApiResponse {
    success?: boolean;
    data?: ScraperRunLogSummaryDtoPagedResultDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class ScraperRunStatisticsDto implements IScraperRunStatisticsDto {
    totalRuns?: number;
    successfulRuns?: number;
    failedRuns?: number;
    inProgressRuns?: number;
    successRate?: number;
    averageResponseTime?: string | undefined;
    averageDuration?: string | undefined;
    errorCategoryCounts?: { [key: string]: number; } | undefined;
    statusCounts?: { [key: string]: number; } | undefined;
    dateFrom?: Date | undefined;
    dateTo?: Date | undefined;

    constructor(data?: IScraperRunStatisticsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalRuns = _data["totalRuns"];
            this.successfulRuns = _data["successfulRuns"];
            this.failedRuns = _data["failedRuns"];
            this.inProgressRuns = _data["inProgressRuns"];
            this.successRate = _data["successRate"];
            this.averageResponseTime = _data["averageResponseTime"];
            this.averageDuration = _data["averageDuration"];
            if (_data["errorCategoryCounts"]) {
                this.errorCategoryCounts = {} as any;
                for (let key in _data["errorCategoryCounts"]) {
                    if (_data["errorCategoryCounts"].hasOwnProperty(key))
                        (<any>this.errorCategoryCounts)![key] = _data["errorCategoryCounts"][key];
                }
            }
            if (_data["statusCounts"]) {
                this.statusCounts = {} as any;
                for (let key in _data["statusCounts"]) {
                    if (_data["statusCounts"].hasOwnProperty(key))
                        (<any>this.statusCounts)![key] = _data["statusCounts"][key];
                }
            }
            this.dateFrom = _data["dateFrom"] ? new Date(_data["dateFrom"].toString()) : <any>undefined;
            this.dateTo = _data["dateTo"] ? new Date(_data["dateTo"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ScraperRunStatisticsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ScraperRunStatisticsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalRuns"] = this.totalRuns;
        data["successfulRuns"] = this.successfulRuns;
        data["failedRuns"] = this.failedRuns;
        data["inProgressRuns"] = this.inProgressRuns;
        data["successRate"] = this.successRate;
        data["averageResponseTime"] = this.averageResponseTime;
        data["averageDuration"] = this.averageDuration;
        if (this.errorCategoryCounts) {
            data["errorCategoryCounts"] = {};
            for (let key in this.errorCategoryCounts) {
                if (this.errorCategoryCounts.hasOwnProperty(key))
                    (<any>data["errorCategoryCounts"])[key] = (<any>this.errorCategoryCounts)[key];
            }
        }
        if (this.statusCounts) {
            data["statusCounts"] = {};
            for (let key in this.statusCounts) {
                if (this.statusCounts.hasOwnProperty(key))
                    (<any>data["statusCounts"])[key] = (<any>this.statusCounts)[key];
            }
        }
        data["dateFrom"] = this.dateFrom ? this.dateFrom.toISOString() : <any>undefined;
        data["dateTo"] = this.dateTo ? this.dateTo.toISOString() : <any>undefined;
        return data;
    }
}

export interface IScraperRunStatisticsDto {
    totalRuns?: number;
    successfulRuns?: number;
    failedRuns?: number;
    inProgressRuns?: number;
    successRate?: number;
    averageResponseTime?: string | undefined;
    averageDuration?: string | undefined;
    errorCategoryCounts?: { [key: string]: number; } | undefined;
    statusCounts?: { [key: string]: number; } | undefined;
    dateFrom?: Date | undefined;
    dateTo?: Date | undefined;
}

export class ScraperRunStatisticsDtoApiResponse implements IScraperRunStatisticsDtoApiResponse {
    success?: boolean;
    data?: ScraperRunStatisticsDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IScraperRunStatisticsDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"] ? ScraperRunStatisticsDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): ScraperRunStatisticsDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ScraperRunStatisticsDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IScraperRunStatisticsDtoApiResponse {
    success?: boolean;
    data?: ScraperRunStatisticsDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class ScraperSiteConfigurationDto implements IScraperSiteConfigurationDto {
    siteConfigId?: string;
    siteDomain?: string | undefined;
    productNameSelector?: string | undefined;
    priceSelector?: string | undefined;
    stockSelector?: string | undefined;
    sellerNameOnPageSelector?: string | undefined;
    defaultUserAgent?: string | undefined;
    additionalHeaders?: { [key: string]: string; } | undefined;
    isEnabled?: boolean;
    createdAt?: Date;
    updatedAt?: Date;

    constructor(data?: IScraperSiteConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.siteConfigId = _data["siteConfigId"];
            this.siteDomain = _data["siteDomain"];
            this.productNameSelector = _data["productNameSelector"];
            this.priceSelector = _data["priceSelector"];
            this.stockSelector = _data["stockSelector"];
            this.sellerNameOnPageSelector = _data["sellerNameOnPageSelector"];
            this.defaultUserAgent = _data["defaultUserAgent"];
            if (_data["additionalHeaders"]) {
                this.additionalHeaders = {} as any;
                for (let key in _data["additionalHeaders"]) {
                    if (_data["additionalHeaders"].hasOwnProperty(key))
                        (<any>this.additionalHeaders)![key] = _data["additionalHeaders"][key];
                }
            }
            this.isEnabled = _data["isEnabled"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ScraperSiteConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ScraperSiteConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["siteConfigId"] = this.siteConfigId;
        data["siteDomain"] = this.siteDomain;
        data["productNameSelector"] = this.productNameSelector;
        data["priceSelector"] = this.priceSelector;
        data["stockSelector"] = this.stockSelector;
        data["sellerNameOnPageSelector"] = this.sellerNameOnPageSelector;
        data["defaultUserAgent"] = this.defaultUserAgent;
        if (this.additionalHeaders) {
            data["additionalHeaders"] = {};
            for (let key in this.additionalHeaders) {
                if (this.additionalHeaders.hasOwnProperty(key))
                    (<any>data["additionalHeaders"])[key] = (<any>this.additionalHeaders)[key];
            }
        }
        data["isEnabled"] = this.isEnabled;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        return data;
    }
}

export interface IScraperSiteConfigurationDto {
    siteConfigId?: string;
    siteDomain?: string | undefined;
    productNameSelector?: string | undefined;
    priceSelector?: string | undefined;
    stockSelector?: string | undefined;
    sellerNameOnPageSelector?: string | undefined;
    defaultUserAgent?: string | undefined;
    additionalHeaders?: { [key: string]: string; } | undefined;
    isEnabled?: boolean;
    createdAt?: Date;
    updatedAt?: Date;
}

export class ScraperSiteConfigurationDtoApiResponse implements IScraperSiteConfigurationDtoApiResponse {
    success?: boolean;
    data?: ScraperSiteConfigurationDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IScraperSiteConfigurationDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"] ? ScraperSiteConfigurationDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): ScraperSiteConfigurationDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ScraperSiteConfigurationDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IScraperSiteConfigurationDtoApiResponse {
    success?: boolean;
    data?: ScraperSiteConfigurationDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class ScraperSiteConfigurationDtoIEnumerableApiResponse implements IScraperSiteConfigurationDtoIEnumerableApiResponse {
    success?: boolean;
    data?: ScraperSiteConfigurationDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IScraperSiteConfigurationDtoIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(ScraperSiteConfigurationDto.fromJS(item));
            }
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): ScraperSiteConfigurationDtoIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ScraperSiteConfigurationDtoIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : <any>undefined);
        }
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IScraperSiteConfigurationDtoIEnumerableApiResponse {
    success?: boolean;
    data?: ScraperSiteConfigurationDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class ScrapingSelectorsDto implements IScrapingSelectorsDto {
    productNameSelector?: string | undefined;
    priceSelector?: string | undefined;
    stockSelector?: string | undefined;
    sellerNameOnPageSelector?: string | undefined;

    constructor(data?: IScrapingSelectorsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productNameSelector = _data["productNameSelector"];
            this.priceSelector = _data["priceSelector"];
            this.stockSelector = _data["stockSelector"];
            this.sellerNameOnPageSelector = _data["sellerNameOnPageSelector"];
        }
    }

    static fromJS(data: any): ScrapingSelectorsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ScrapingSelectorsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productNameSelector"] = this.productNameSelector;
        data["priceSelector"] = this.priceSelector;
        data["stockSelector"] = this.stockSelector;
        data["sellerNameOnPageSelector"] = this.sellerNameOnPageSelector;
        return data;
    }
}

export interface IScrapingSelectorsDto {
    productNameSelector?: string | undefined;
    priceSelector?: string | undefined;
    stockSelector?: string | undefined;
    sellerNameOnPageSelector?: string | undefined;
}

export class SelectorGenerationResult implements ISelectorGenerationResult {
    domain?: string | undefined;
    selectors?: SelectorSet;
    confidence?: number;
    notes?: string | undefined;
    generatedAt?: Date;

    constructor(data?: ISelectorGenerationResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.domain = _data["domain"];
            this.selectors = _data["selectors"] ? SelectorSet.fromJS(_data["selectors"]) : <any>undefined;
            this.confidence = _data["confidence"];
            this.notes = _data["notes"];
            this.generatedAt = _data["generatedAt"] ? new Date(_data["generatedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): SelectorGenerationResult {
        data = typeof data === 'object' ? data : {};
        let result = new SelectorGenerationResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["domain"] = this.domain;
        data["selectors"] = this.selectors ? this.selectors.toJSON() : <any>undefined;
        data["confidence"] = this.confidence;
        data["notes"] = this.notes;
        data["generatedAt"] = this.generatedAt ? this.generatedAt.toISOString() : <any>undefined;
        return data;
    }
}

export interface ISelectorGenerationResult {
    domain?: string | undefined;
    selectors?: SelectorSet;
    confidence?: number;
    notes?: string | undefined;
    generatedAt?: Date;
}

export class SelectorGenerationResultApiResponse implements ISelectorGenerationResultApiResponse {
    success?: boolean;
    data?: SelectorGenerationResult;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: ISelectorGenerationResultApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"] ? SelectorGenerationResult.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): SelectorGenerationResultApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SelectorGenerationResultApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface ISelectorGenerationResultApiResponse {
    success?: boolean;
    data?: SelectorGenerationResult;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class SelectorImprovementRequest implements ISelectorImprovementRequest {
    htmlContent!: string;
    currentSelectors!: SelectorSet;
    testResult!: SelectorTestResult;

    constructor(data?: ISelectorImprovementRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.currentSelectors = new SelectorSet();
            this.testResult = new SelectorTestResult();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.htmlContent = _data["htmlContent"];
            this.currentSelectors = _data["currentSelectors"] ? SelectorSet.fromJS(_data["currentSelectors"]) : new SelectorSet();
            this.testResult = _data["testResult"] ? SelectorTestResult.fromJS(_data["testResult"]) : new SelectorTestResult();
        }
    }

    static fromJS(data: any): SelectorImprovementRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SelectorImprovementRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["htmlContent"] = this.htmlContent;
        data["currentSelectors"] = this.currentSelectors ? this.currentSelectors.toJSON() : <any>undefined;
        data["testResult"] = this.testResult ? this.testResult.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISelectorImprovementRequest {
    htmlContent: string;
    currentSelectors: SelectorSet;
    testResult: SelectorTestResult;
}

export class SelectorSet implements ISelectorSet {
    domain?: string | undefined;
    productNameSelectors?: string[] | undefined;
    priceSelectors?: string[] | undefined;
    imageSelectors?: string[] | undefined;
    descriptionSelectors?: string[] | undefined;
    manufacturerSelectors?: string[] | undefined;
    modelNumberSelectors?: string[] | undefined;
    specificationSelectors?: string[] | undefined;
    createdAt?: Date;
    updatedAt?: Date;

    constructor(data?: ISelectorSet) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.domain = _data["domain"];
            if (Array.isArray(_data["productNameSelectors"])) {
                this.productNameSelectors = [] as any;
                for (let item of _data["productNameSelectors"])
                    this.productNameSelectors!.push(item);
            }
            if (Array.isArray(_data["priceSelectors"])) {
                this.priceSelectors = [] as any;
                for (let item of _data["priceSelectors"])
                    this.priceSelectors!.push(item);
            }
            if (Array.isArray(_data["imageSelectors"])) {
                this.imageSelectors = [] as any;
                for (let item of _data["imageSelectors"])
                    this.imageSelectors!.push(item);
            }
            if (Array.isArray(_data["descriptionSelectors"])) {
                this.descriptionSelectors = [] as any;
                for (let item of _data["descriptionSelectors"])
                    this.descriptionSelectors!.push(item);
            }
            if (Array.isArray(_data["manufacturerSelectors"])) {
                this.manufacturerSelectors = [] as any;
                for (let item of _data["manufacturerSelectors"])
                    this.manufacturerSelectors!.push(item);
            }
            if (Array.isArray(_data["modelNumberSelectors"])) {
                this.modelNumberSelectors = [] as any;
                for (let item of _data["modelNumberSelectors"])
                    this.modelNumberSelectors!.push(item);
            }
            if (Array.isArray(_data["specificationSelectors"])) {
                this.specificationSelectors = [] as any;
                for (let item of _data["specificationSelectors"])
                    this.specificationSelectors!.push(item);
            }
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): SelectorSet {
        data = typeof data === 'object' ? data : {};
        let result = new SelectorSet();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["domain"] = this.domain;
        if (Array.isArray(this.productNameSelectors)) {
            data["productNameSelectors"] = [];
            for (let item of this.productNameSelectors)
                data["productNameSelectors"].push(item);
        }
        if (Array.isArray(this.priceSelectors)) {
            data["priceSelectors"] = [];
            for (let item of this.priceSelectors)
                data["priceSelectors"].push(item);
        }
        if (Array.isArray(this.imageSelectors)) {
            data["imageSelectors"] = [];
            for (let item of this.imageSelectors)
                data["imageSelectors"].push(item);
        }
        if (Array.isArray(this.descriptionSelectors)) {
            data["descriptionSelectors"] = [];
            for (let item of this.descriptionSelectors)
                data["descriptionSelectors"].push(item);
        }
        if (Array.isArray(this.manufacturerSelectors)) {
            data["manufacturerSelectors"] = [];
            for (let item of this.manufacturerSelectors)
                data["manufacturerSelectors"].push(item);
        }
        if (Array.isArray(this.modelNumberSelectors)) {
            data["modelNumberSelectors"] = [];
            for (let item of this.modelNumberSelectors)
                data["modelNumberSelectors"].push(item);
        }
        if (Array.isArray(this.specificationSelectors)) {
            data["specificationSelectors"] = [];
            for (let item of this.specificationSelectors)
                data["specificationSelectors"].push(item);
        }
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        return data;
    }
}

export interface ISelectorSet {
    domain?: string | undefined;
    productNameSelectors?: string[] | undefined;
    priceSelectors?: string[] | undefined;
    imageSelectors?: string[] | undefined;
    descriptionSelectors?: string[] | undefined;
    manufacturerSelectors?: string[] | undefined;
    modelNumberSelectors?: string[] | undefined;
    specificationSelectors?: string[] | undefined;
    createdAt?: Date;
    updatedAt?: Date;
}

export class SelectorSuggestion implements ISelectorSuggestion {
    field?: string | undefined;
    currentSelector?: string | undefined;
    suggestedSelector?: string | undefined;
    reason?: string | undefined;
    priority?: string | undefined;

    constructor(data?: ISelectorSuggestion) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.field = _data["field"];
            this.currentSelector = _data["currentSelector"];
            this.suggestedSelector = _data["suggestedSelector"];
            this.reason = _data["reason"];
            this.priority = _data["priority"];
        }
    }

    static fromJS(data: any): SelectorSuggestion {
        data = typeof data === 'object' ? data : {};
        let result = new SelectorSuggestion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        data["currentSelector"] = this.currentSelector;
        data["suggestedSelector"] = this.suggestedSelector;
        data["reason"] = this.reason;
        data["priority"] = this.priority;
        return data;
    }
}

export interface ISelectorSuggestion {
    field?: string | undefined;
    currentSelector?: string | undefined;
    suggestedSelector?: string | undefined;
    reason?: string | undefined;
    priority?: string | undefined;
}

export class SelectorSuggestionListApiResponse implements ISelectorSuggestionListApiResponse {
    success?: boolean;
    data?: SelectorSuggestion[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: ISelectorSuggestionListApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(SelectorSuggestion.fromJS(item));
            }
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): SelectorSuggestionListApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SelectorSuggestionListApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : <any>undefined);
        }
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface ISelectorSuggestionListApiResponse {
    success?: boolean;
    data?: SelectorSuggestion[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class SelectorTestResult implements ISelectorTestResult {
    domain?: string | undefined;
    results?: { [key: string]: FieldTestResult; } | undefined;
    overallScore?: number;
    issues?: string[] | undefined;
    testedAt?: Date;

    constructor(data?: ISelectorTestResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.domain = _data["domain"];
            if (_data["results"]) {
                this.results = {} as any;
                for (let key in _data["results"]) {
                    if (_data["results"].hasOwnProperty(key))
                        (<any>this.results)![key] = _data["results"][key] ? FieldTestResult.fromJS(_data["results"][key]) : new FieldTestResult();
                }
            }
            this.overallScore = _data["overallScore"];
            if (Array.isArray(_data["issues"])) {
                this.issues = [] as any;
                for (let item of _data["issues"])
                    this.issues!.push(item);
            }
            this.testedAt = _data["testedAt"] ? new Date(_data["testedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): SelectorTestResult {
        data = typeof data === 'object' ? data : {};
        let result = new SelectorTestResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["domain"] = this.domain;
        if (this.results) {
            data["results"] = {};
            for (let key in this.results) {
                if (this.results.hasOwnProperty(key))
                    (<any>data["results"])[key] = this.results[key] ? this.results[key].toJSON() : <any>undefined;
            }
        }
        data["overallScore"] = this.overallScore;
        if (Array.isArray(this.issues)) {
            data["issues"] = [];
            for (let item of this.issues)
                data["issues"].push(item);
        }
        data["testedAt"] = this.testedAt ? this.testedAt.toISOString() : <any>undefined;
        return data;
    }
}

export interface ISelectorTestResult {
    domain?: string | undefined;
    results?: { [key: string]: FieldTestResult; } | undefined;
    overallScore?: number;
    issues?: string[] | undefined;
    testedAt?: Date;
}

export class SelectorTestResultApiResponse implements ISelectorTestResultApiResponse {
    success?: boolean;
    data?: SelectorTestResult;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: ISelectorTestResultApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"] ? SelectorTestResult.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): SelectorTestResultApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SelectorTestResultApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface ISelectorTestResultApiResponse {
    success?: boolean;
    data?: SelectorTestResult;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class SellerPerformanceMetricDto implements ISellerPerformanceMetricDto {
    sellerName?: string | undefined;
    totalRuns?: number;
    successfulRuns?: number;
    successRate?: number;
    averageResponseTime?: string | undefined;
    averageDuration?: string | undefined;

    constructor(data?: ISellerPerformanceMetricDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sellerName = _data["sellerName"];
            this.totalRuns = _data["totalRuns"];
            this.successfulRuns = _data["successfulRuns"];
            this.successRate = _data["successRate"];
            this.averageResponseTime = _data["averageResponseTime"];
            this.averageDuration = _data["averageDuration"];
        }
    }

    static fromJS(data: any): SellerPerformanceMetricDto {
        data = typeof data === 'object' ? data : {};
        let result = new SellerPerformanceMetricDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sellerName"] = this.sellerName;
        data["totalRuns"] = this.totalRuns;
        data["successfulRuns"] = this.successfulRuns;
        data["successRate"] = this.successRate;
        data["averageResponseTime"] = this.averageResponseTime;
        data["averageDuration"] = this.averageDuration;
        return data;
    }
}

export interface ISellerPerformanceMetricDto {
    sellerName?: string | undefined;
    totalRuns?: number;
    successfulRuns?: number;
    successRate?: number;
    averageResponseTime?: string | undefined;
    averageDuration?: string | undefined;
}

export class SellerPerformanceMetricDtoIEnumerableApiResponse implements ISellerPerformanceMetricDtoIEnumerableApiResponse {
    success?: boolean;
    data?: SellerPerformanceMetricDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: ISellerPerformanceMetricDtoIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(SellerPerformanceMetricDto.fromJS(item));
            }
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): SellerPerformanceMetricDtoIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SellerPerformanceMetricDtoIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : <any>undefined);
        }
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface ISellerPerformanceMetricDtoIEnumerableApiResponse {
    success?: boolean;
    data?: SellerPerformanceMetricDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class SimilarProductResult implements ISimilarProductResult {
    productId?: string;
    productName?: string | undefined;
    similarityScore?: number;
    matchingMethod?: string | undefined;
    matchingFields?: string[] | undefined;
    matchMetadata?: { [key: string]: any; } | undefined;

    constructor(data?: ISimilarProductResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.productName = _data["productName"];
            this.similarityScore = _data["similarityScore"];
            this.matchingMethod = _data["matchingMethod"];
            if (Array.isArray(_data["matchingFields"])) {
                this.matchingFields = [] as any;
                for (let item of _data["matchingFields"])
                    this.matchingFields!.push(item);
            }
            if (_data["matchMetadata"]) {
                this.matchMetadata = {} as any;
                for (let key in _data["matchMetadata"]) {
                    if (_data["matchMetadata"].hasOwnProperty(key))
                        (<any>this.matchMetadata)![key] = _data["matchMetadata"][key];
                }
            }
        }
    }

    static fromJS(data: any): SimilarProductResult {
        data = typeof data === 'object' ? data : {};
        let result = new SimilarProductResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["productName"] = this.productName;
        data["similarityScore"] = this.similarityScore;
        data["matchingMethod"] = this.matchingMethod;
        if (Array.isArray(this.matchingFields)) {
            data["matchingFields"] = [];
            for (let item of this.matchingFields)
                data["matchingFields"].push(item);
        }
        if (this.matchMetadata) {
            data["matchMetadata"] = {};
            for (let key in this.matchMetadata) {
                if (this.matchMetadata.hasOwnProperty(key))
                    (<any>data["matchMetadata"])[key] = (<any>this.matchMetadata)[key];
            }
        }
        return data;
    }
}

export interface ISimilarProductResult {
    productId?: string;
    productName?: string | undefined;
    similarityScore?: number;
    matchingMethod?: string | undefined;
    matchingFields?: string[] | undefined;
    matchMetadata?: { [key: string]: any; } | undefined;
}

export class SimilarProductResultListApiResponse implements ISimilarProductResultListApiResponse {
    success?: boolean;
    data?: SimilarProductResult[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: ISimilarProductResultListApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(SimilarProductResult.fromJS(item));
            }
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): SimilarProductResultListApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SimilarProductResultListApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : <any>undefined);
        }
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface ISimilarProductResultListApiResponse {
    success?: boolean;
    data?: SimilarProductResult[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class SiteConfigurationDto implements ISiteConfigurationDto {
    id?: string;
    domain?: string | undefined;
    siteName?: string | undefined;
    selectors?: SelectorSet;
    isActive?: boolean;
    notes?: string | undefined;
    testHtml?: string | undefined;
    createdAt?: Date;
    updatedAt?: Date;
    createdByUserId?: string | undefined;
    updatedByUserId?: string | undefined;

    constructor(data?: ISiteConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.domain = _data["domain"];
            this.siteName = _data["siteName"];
            this.selectors = _data["selectors"] ? SelectorSet.fromJS(_data["selectors"]) : <any>undefined;
            this.isActive = _data["isActive"];
            this.notes = _data["notes"];
            this.testHtml = _data["testHtml"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.createdByUserId = _data["createdByUserId"];
            this.updatedByUserId = _data["updatedByUserId"];
        }
    }

    static fromJS(data: any): SiteConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new SiteConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["domain"] = this.domain;
        data["siteName"] = this.siteName;
        data["selectors"] = this.selectors ? this.selectors.toJSON() : <any>undefined;
        data["isActive"] = this.isActive;
        data["notes"] = this.notes;
        data["testHtml"] = this.testHtml;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["createdByUserId"] = this.createdByUserId;
        data["updatedByUserId"] = this.updatedByUserId;
        return data;
    }
}

export interface ISiteConfigurationDto {
    id?: string;
    domain?: string | undefined;
    siteName?: string | undefined;
    selectors?: SelectorSet;
    isActive?: boolean;
    notes?: string | undefined;
    testHtml?: string | undefined;
    createdAt?: Date;
    updatedAt?: Date;
    createdByUserId?: string | undefined;
    updatedByUserId?: string | undefined;
}

export class SiteConfigurationDtoApiResponse implements ISiteConfigurationDtoApiResponse {
    success?: boolean;
    data?: SiteConfigurationDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: ISiteConfigurationDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"] ? SiteConfigurationDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): SiteConfigurationDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SiteConfigurationDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface ISiteConfigurationDtoApiResponse {
    success?: boolean;
    data?: SiteConfigurationDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class SiteConfigurationDtoListApiResponse implements ISiteConfigurationDtoListApiResponse {
    success?: boolean;
    data?: SiteConfigurationDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: ISiteConfigurationDtoListApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(SiteConfigurationDto.fromJS(item));
            }
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): SiteConfigurationDtoListApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SiteConfigurationDtoListApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : <any>undefined);
        }
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface ISiteConfigurationDtoListApiResponse {
    success?: boolean;
    data?: SiteConfigurationDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class SiteConfigurationDtoPagedResponse implements ISiteConfigurationDtoPagedResponse {
    success?: boolean;
    data?: SiteConfigurationDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
    pagination?: PaginationMeta;

    constructor(data?: ISiteConfigurationDtoPagedResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(SiteConfigurationDto.fromJS(item));
            }
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
            this.pagination = _data["pagination"] ? PaginationMeta.fromJS(_data["pagination"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SiteConfigurationDtoPagedResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SiteConfigurationDtoPagedResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : <any>undefined);
        }
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        data["pagination"] = this.pagination ? this.pagination.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISiteConfigurationDtoPagedResponse {
    success?: boolean;
    data?: SiteConfigurationDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
    pagination?: PaginationMeta;
}

export class StringApiResponse implements IStringApiResponse {
    success?: boolean;
    data?: string | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IStringApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"];
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): StringApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new StringApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IStringApiResponse {
    success?: boolean;
    data?: string | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class TestSelectorsRequest implements ITestSelectorsRequest {
    htmlContent!: string;
    selectors!: SelectorSet;

    constructor(data?: ITestSelectorsRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.selectors = new SelectorSet();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.htmlContent = _data["htmlContent"];
            this.selectors = _data["selectors"] ? SelectorSet.fromJS(_data["selectors"]) : new SelectorSet();
        }
    }

    static fromJS(data: any): TestSelectorsRequest {
        data = typeof data === 'object' ? data : {};
        let result = new TestSelectorsRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["htmlContent"] = this.htmlContent;
        data["selectors"] = this.selectors ? this.selectors.toJSON() : <any>undefined;
        return data;
    }
}

export interface ITestSelectorsRequest {
    htmlContent: string;
    selectors: SelectorSet;
}

export class UpdateAlertRuleDto implements IUpdateAlertRuleDto {
    conditionType?: string | undefined;
    thresholdValue?: number | undefined;
    percentageValue?: number | undefined;
    specificSellerName?: string | undefined;
    notificationFrequencyMinutes?: number | undefined;
    isActive?: boolean | undefined;

    constructor(data?: IUpdateAlertRuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.conditionType = _data["conditionType"];
            this.thresholdValue = _data["thresholdValue"];
            this.percentageValue = _data["percentageValue"];
            this.specificSellerName = _data["specificSellerName"];
            this.notificationFrequencyMinutes = _data["notificationFrequencyMinutes"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): UpdateAlertRuleDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAlertRuleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["conditionType"] = this.conditionType;
        data["thresholdValue"] = this.thresholdValue;
        data["percentageValue"] = this.percentageValue;
        data["specificSellerName"] = this.specificSellerName;
        data["notificationFrequencyMinutes"] = this.notificationFrequencyMinutes;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IUpdateAlertRuleDto {
    conditionType?: string | undefined;
    thresholdValue?: number | undefined;
    percentageValue?: number | undefined;
    specificSellerName?: string | undefined;
    notificationFrequencyMinutes?: number | undefined;
    isActive?: boolean | undefined;
}

export class UpdateCategoryDto implements IUpdateCategoryDto {
    name?: string | undefined;
    slug?: string | undefined;
    description?: string | undefined;

    constructor(data?: IUpdateCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): UpdateCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["description"] = this.description;
        return data;
    }
}

export interface IUpdateCategoryDto {
    name?: string | undefined;
    slug?: string | undefined;
    description?: string | undefined;
}

export class UpdateProductDto implements IUpdateProductDto {
    name?: string | undefined;
    manufacturer?: string | undefined;
    modelNumber?: string | undefined;
    sku?: string | undefined;
    categoryId?: string | undefined;
    description?: string | undefined;
    specifications?: { [key: string]: any; } | undefined;
    isActive?: boolean | undefined;

    constructor(data?: IUpdateProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.manufacturer = _data["manufacturer"];
            this.modelNumber = _data["modelNumber"];
            this.sku = _data["sku"];
            this.categoryId = _data["categoryId"];
            this.description = _data["description"];
            if (_data["specifications"]) {
                this.specifications = {} as any;
                for (let key in _data["specifications"]) {
                    if (_data["specifications"].hasOwnProperty(key))
                        (<any>this.specifications)![key] = _data["specifications"][key];
                }
            }
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): UpdateProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["manufacturer"] = this.manufacturer;
        data["modelNumber"] = this.modelNumber;
        data["sku"] = this.sku;
        data["categoryId"] = this.categoryId;
        data["description"] = this.description;
        if (this.specifications) {
            data["specifications"] = {};
            for (let key in this.specifications) {
                if (this.specifications.hasOwnProperty(key))
                    (<any>data["specifications"])[key] = (<any>this.specifications)[key];
            }
        }
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IUpdateProductDto {
    name?: string | undefined;
    manufacturer?: string | undefined;
    modelNumber?: string | undefined;
    sku?: string | undefined;
    categoryId?: string | undefined;
    description?: string | undefined;
    specifications?: { [key: string]: any; } | undefined;
    isActive?: boolean | undefined;
}

export class UpdateProductSellerMappingDto implements IUpdateProductSellerMappingDto {
    sellerName?: string | undefined;
    exactProductUrl?: string | undefined;
    isActiveForScraping?: boolean | undefined;
    scrapingFrequencyOverride?: string | undefined;
    siteConfigId?: string | undefined;

    constructor(data?: IUpdateProductSellerMappingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sellerName = _data["sellerName"];
            this.exactProductUrl = _data["exactProductUrl"];
            this.isActiveForScraping = _data["isActiveForScraping"];
            this.scrapingFrequencyOverride = _data["scrapingFrequencyOverride"];
            this.siteConfigId = _data["siteConfigId"];
        }
    }

    static fromJS(data: any): UpdateProductSellerMappingDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductSellerMappingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sellerName"] = this.sellerName;
        data["exactProductUrl"] = this.exactProductUrl;
        data["isActiveForScraping"] = this.isActiveForScraping;
        data["scrapingFrequencyOverride"] = this.scrapingFrequencyOverride;
        data["siteConfigId"] = this.siteConfigId;
        return data;
    }
}

export interface IUpdateProductSellerMappingDto {
    sellerName?: string | undefined;
    exactProductUrl?: string | undefined;
    isActiveForScraping?: boolean | undefined;
    scrapingFrequencyOverride?: string | undefined;
    siteConfigId?: string | undefined;
}

export class UpdateScraperSiteConfigurationDto implements IUpdateScraperSiteConfigurationDto {
    siteDomain?: string | undefined;
    productNameSelector?: string | undefined;
    priceSelector?: string | undefined;
    stockSelector?: string | undefined;
    sellerNameOnPageSelector?: string | undefined;
    defaultUserAgent?: string | undefined;
    additionalHeaders?: { [key: string]: string; } | undefined;
    isEnabled?: boolean | undefined;

    constructor(data?: IUpdateScraperSiteConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.siteDomain = _data["siteDomain"];
            this.productNameSelector = _data["productNameSelector"];
            this.priceSelector = _data["priceSelector"];
            this.stockSelector = _data["stockSelector"];
            this.sellerNameOnPageSelector = _data["sellerNameOnPageSelector"];
            this.defaultUserAgent = _data["defaultUserAgent"];
            if (_data["additionalHeaders"]) {
                this.additionalHeaders = {} as any;
                for (let key in _data["additionalHeaders"]) {
                    if (_data["additionalHeaders"].hasOwnProperty(key))
                        (<any>this.additionalHeaders)![key] = _data["additionalHeaders"][key];
                }
            }
            this.isEnabled = _data["isEnabled"];
        }
    }

    static fromJS(data: any): UpdateScraperSiteConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateScraperSiteConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["siteDomain"] = this.siteDomain;
        data["productNameSelector"] = this.productNameSelector;
        data["priceSelector"] = this.priceSelector;
        data["stockSelector"] = this.stockSelector;
        data["sellerNameOnPageSelector"] = this.sellerNameOnPageSelector;
        data["defaultUserAgent"] = this.defaultUserAgent;
        if (this.additionalHeaders) {
            data["additionalHeaders"] = {};
            for (let key in this.additionalHeaders) {
                if (this.additionalHeaders.hasOwnProperty(key))
                    (<any>data["additionalHeaders"])[key] = (<any>this.additionalHeaders)[key];
            }
        }
        data["isEnabled"] = this.isEnabled;
        return data;
    }
}

export interface IUpdateScraperSiteConfigurationDto {
    siteDomain?: string | undefined;
    productNameSelector?: string | undefined;
    priceSelector?: string | undefined;
    stockSelector?: string | undefined;
    sellerNameOnPageSelector?: string | undefined;
    defaultUserAgent?: string | undefined;
    additionalHeaders?: { [key: string]: string; } | undefined;
    isEnabled?: boolean | undefined;
}

export class UpdateUserDto implements IUpdateUserDto {
    email?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    roles?: string[] | undefined;
    isActive?: boolean | undefined;

    constructor(data?: IUpdateUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): UpdateUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IUpdateUserDto {
    email?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    roles?: string[] | undefined;
    isActive?: boolean | undefined;
}

export class UserDto implements IUserDto {
    userId?: string;
    email?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    fullName?: string | undefined;
    isActive?: boolean;
    createdAt?: Date;
    updatedAt?: Date;
    roles?: string[] | undefined;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.email = _data["email"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.fullName = _data["fullName"];
            this.isActive = _data["isActive"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["email"] = this.email;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["fullName"] = this.fullName;
        data["isActive"] = this.isActive;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data;
    }
}

export interface IUserDto {
    userId?: string;
    email?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    fullName?: string | undefined;
    isActive?: boolean;
    createdAt?: Date;
    updatedAt?: Date;
    roles?: string[] | undefined;
}

export class UserDtoApiResponse implements IUserDtoApiResponse {
    success?: boolean;
    data?: UserDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IUserDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"] ? UserDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): UserDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UserDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IUserDtoApiResponse {
    success?: boolean;
    data?: UserDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class UserDtoPagedResponse implements IUserDtoPagedResponse {
    success?: boolean;
    data?: UserDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
    pagination?: PaginationMeta;

    constructor(data?: IUserDtoPagedResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(UserDto.fromJS(item));
            }
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
            this.pagination = _data["pagination"] ? PaginationMeta.fromJS(_data["pagination"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UserDtoPagedResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UserDtoPagedResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : <any>undefined);
        }
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        data["pagination"] = this.pagination ? this.pagination.toJSON() : <any>undefined;
        return data;
    }
}

export interface IUserDtoPagedResponse {
    success?: boolean;
    data?: UserDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
    pagination?: PaginationMeta;
}

export class UtilitiesExampleRequest implements IUtilitiesExampleRequest {
    text?: string | undefined;
    email?: string | undefined;

    constructor(data?: IUtilitiesExampleRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.text = _data["text"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): UtilitiesExampleRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UtilitiesExampleRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["text"] = this.text;
        data["email"] = this.email;
        return data;
    }
}

export interface IUtilitiesExampleRequest {
    text?: string | undefined;
    email?: string | undefined;
}

export class ValidationExampleRequest implements IValidationExampleRequest {
    email?: string | undefined;
    phone?: string | undefined;
    website?: string | undefined;

    constructor(data?: IValidationExampleRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.phone = _data["phone"];
            this.website = _data["website"];
        }
    }

    static fromJS(data: any): ValidationExampleRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationExampleRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["website"] = this.website;
        return data;
    }
}

export interface IValidationExampleRequest {
    email?: string | undefined;
    phone?: string | undefined;
    website?: string | undefined;
}

export enum WorkflowAction {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    return _observableThrow(new ApiException(message, status, response, headers, result));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}