//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.4.0.0 (NJsonSchema v11.3.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable({
    providedIn: 'root'
})
export class TechTickerApiClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return OK
     */
    usersGET(page: number | undefined, pageSize: number | undefined): Observable<UserDtoPagedResponse> {
        let url_ = this.baseUrl + "/api/Admin/users?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUsersGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUsersGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDtoPagedResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDtoPagedResponse>;
        }));
    }

    protected processUsersGET(response: HttpResponseBase): Observable<UserDtoPagedResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDtoPagedResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    usersPOST(body: CreateUserDto | undefined): Observable<UserDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Admin/users";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUsersPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUsersPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDtoApiResponse>;
        }));
    }

    protected processUsersPOST(response: HttpResponseBase): Observable<UserDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    usersGET2(userId: string): Observable<UserDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Admin/users/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUsersGET2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUsersGET2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDtoApiResponse>;
        }));
    }

    protected processUsersGET2(response: HttpResponseBase): Observable<UserDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    usersPUT(userId: string, body: UpdateUserDto | undefined): Observable<UserDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Admin/users/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUsersPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUsersPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDtoApiResponse>;
        }));
    }

    protected processUsersPUT(response: HttpResponseBase): Observable<UserDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    usersDELETE(userId: string): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/api/Admin/users/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUsersDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUsersDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processUsersDELETE(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param userId (optional) 
     * @param productId (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return OK
     */
    alerts(userId: string | undefined, productId: string | undefined, page: number | undefined, pageSize: number | undefined): Observable<AlertRuleDtoPagedResponse> {
        let url_ = this.baseUrl + "/api/Admin/alerts?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (productId === null)
            throw new Error("The parameter 'productId' cannot be null.");
        else if (productId !== undefined)
            url_ += "productId=" + encodeURIComponent("" + productId) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAlerts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAlerts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AlertRuleDtoPagedResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AlertRuleDtoPagedResponse>;
        }));
    }

    protected processAlerts(response: HttpResponseBase): Observable<AlertRuleDtoPagedResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AlertRuleDtoPagedResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    alertsPOST(body: CreateAlertRuleDto | undefined): Observable<AlertRuleDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Alerts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAlertsPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAlertsPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AlertRuleDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AlertRuleDtoApiResponse>;
        }));
    }

    protected processAlertsPOST(response: HttpResponseBase): Observable<AlertRuleDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AlertRuleDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    alertsGET(): Observable<AlertRuleDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Alerts";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAlertsGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAlertsGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AlertRuleDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AlertRuleDtoIEnumerableApiResponse>;
        }));
    }

    protected processAlertsGET(response: HttpResponseBase): Observable<AlertRuleDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AlertRuleDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    product(productId: string): Observable<AlertRuleDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Alerts/product/{productId}";
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProduct(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AlertRuleDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AlertRuleDtoIEnumerableApiResponse>;
        }));
    }

    protected processProduct(response: HttpResponseBase): Observable<AlertRuleDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AlertRuleDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    alertsPUT(alertRuleId: string, body: UpdateAlertRuleDto | undefined): Observable<AlertRuleDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Alerts/{alertRuleId}";
        if (alertRuleId === undefined || alertRuleId === null)
            throw new Error("The parameter 'alertRuleId' must be defined.");
        url_ = url_.replace("{alertRuleId}", encodeURIComponent("" + alertRuleId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAlertsPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAlertsPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AlertRuleDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AlertRuleDtoApiResponse>;
        }));
    }

    protected processAlertsPUT(response: HttpResponseBase): Observable<AlertRuleDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AlertRuleDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    alertsDELETE(alertRuleId: string): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/api/Alerts/{alertRuleId}";
        if (alertRuleId === undefined || alertRuleId === null)
            throw new Error("The parameter 'alertRuleId' must be defined.");
        url_ = url_.replace("{alertRuleId}", encodeURIComponent("" + alertRuleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAlertsDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAlertsDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processAlertsDELETE(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    register(body: RegisterUserDto | undefined): Observable<UserDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Auth/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDtoApiResponse>;
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<UserDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    login(body: LoginUserDto | undefined): Observable<LoginResponseDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Auth/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LoginResponseDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LoginResponseDtoApiResponse>;
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<LoginResponseDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoginResponseDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    me(): Observable<UserDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Auth/me";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMe(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMe(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDtoApiResponse>;
        }));
    }

    protected processMe(response: HttpResponseBase): Observable<UserDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    categoriesPOST(body: CreateCategoryDto | undefined): Observable<CategoryDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Categories";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCategoriesPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCategoriesPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CategoryDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CategoryDtoApiResponse>;
        }));
    }

    protected processCategoriesPOST(response: HttpResponseBase): Observable<CategoryDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CategoryDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    categoriesGET(): Observable<CategoryDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Categories";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCategoriesGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCategoriesGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CategoryDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CategoryDtoIEnumerableApiResponse>;
        }));
    }

    protected processCategoriesGET(response: HttpResponseBase): Observable<CategoryDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CategoryDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    categoriesGET2(categoryIdOrSlug: string): Observable<CategoryDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Categories/{categoryIdOrSlug}";
        if (categoryIdOrSlug === undefined || categoryIdOrSlug === null)
            throw new Error("The parameter 'categoryIdOrSlug' must be defined.");
        url_ = url_.replace("{categoryIdOrSlug}", encodeURIComponent("" + categoryIdOrSlug));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCategoriesGET2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCategoriesGET2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CategoryDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CategoryDtoApiResponse>;
        }));
    }

    protected processCategoriesGET2(response: HttpResponseBase): Observable<CategoryDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CategoryDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    categoriesPUT(categoryId: string, body: UpdateCategoryDto | undefined): Observable<CategoryDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Categories/{categoryId}";
        if (categoryId === undefined || categoryId === null)
            throw new Error("The parameter 'categoryId' must be defined.");
        url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCategoriesPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCategoriesPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CategoryDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CategoryDtoApiResponse>;
        }));
    }

    protected processCategoriesPUT(response: HttpResponseBase): Observable<CategoryDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CategoryDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    categoriesDELETE(categoryId: string): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/api/Categories/{categoryId}";
        if (categoryId === undefined || categoryId === null)
            throw new Error("The parameter 'categoryId' must be defined.");
        url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCategoriesDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCategoriesDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processCategoriesDELETE(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    stats(): Observable<DashboardStatsDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Dashboard/stats";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStats(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DashboardStatsDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DashboardStatsDtoApiResponse>;
        }));
    }

    protected processStats(response: HttpResponseBase): Observable<DashboardStatsDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DashboardStatsDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    success(): Observable<ObjectApiResponse> {
        let url_ = this.baseUrl + "/api/Example/success";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSuccess(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSuccess(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResponse>;
        }));
    }

    protected processSuccess(response: HttpResponseBase): Observable<ObjectApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param skip (optional) 
     * @param take (optional) 
     * @return OK
     */
    paginated(pageNumber: number | undefined, pageSize: number | undefined, skip: number | undefined, take: number | undefined): Observable<ObjectPagedResponse> {
        let url_ = this.baseUrl + "/api/Example/paginated?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPaginated(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPaginated(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectPagedResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectPagedResponse>;
        }));
    }

    protected processPaginated(response: HttpResponseBase): Observable<ObjectPagedResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectPagedResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    result(id: number): Observable<ObjectApiResponse> {
        let url_ = this.baseUrl + "/api/Example/result/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResult(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResult(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResponse>;
        }));
    }

    protected processResult(response: HttpResponseBase): Observable<ObjectApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    error(type: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Example/error/{type}";
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined.");
        url_ = url_.replace("{type}", encodeURIComponent("" + type));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processError(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processError(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processError(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    validate(body: ValidationExampleRequest | undefined): Observable<StringApiResponse> {
        let url_ = this.baseUrl + "/api/Example/validate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StringApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StringApiResponse>;
        }));
    }

    protected processValidate(response: HttpResponseBase): Observable<StringApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    utilities(body: UtilitiesExampleRequest | undefined): Observable<ObjectApiResponse> {
        let url_ = this.baseUrl + "/api/Example/utilities";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUtilities(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUtilities(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResponse>;
        }));
    }

    protected processUtilities(response: HttpResponseBase): Observable<ObjectApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    mappingsPOST(body: CreateProductSellerMappingDto | undefined): Observable<ProductSellerMappingDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Mappings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMappingsPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMappingsPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductSellerMappingDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductSellerMappingDtoApiResponse>;
        }));
    }

    protected processMappingsPOST(response: HttpResponseBase): Observable<ProductSellerMappingDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductSellerMappingDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param canonicalProductId (optional) 
     * @return OK
     */
    mappingsGET(canonicalProductId: string | undefined): Observable<ProductSellerMappingDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Mappings?";
        if (canonicalProductId === null)
            throw new Error("The parameter 'canonicalProductId' cannot be null.");
        else if (canonicalProductId !== undefined)
            url_ += "canonicalProductId=" + encodeURIComponent("" + canonicalProductId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMappingsGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMappingsGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductSellerMappingDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductSellerMappingDtoIEnumerableApiResponse>;
        }));
    }

    protected processMappingsGET(response: HttpResponseBase): Observable<ProductSellerMappingDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductSellerMappingDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    active(): Observable<ProductSellerMappingDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Mappings/active";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActive(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActive(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductSellerMappingDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductSellerMappingDtoIEnumerableApiResponse>;
        }));
    }

    protected processActive(response: HttpResponseBase): Observable<ProductSellerMappingDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductSellerMappingDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    mappingsPUT(mappingId: string, body: UpdateProductSellerMappingDto | undefined): Observable<ProductSellerMappingDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Mappings/{mappingId}";
        if (mappingId === undefined || mappingId === null)
            throw new Error("The parameter 'mappingId' must be defined.");
        url_ = url_.replace("{mappingId}", encodeURIComponent("" + mappingId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMappingsPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMappingsPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductSellerMappingDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductSellerMappingDtoApiResponse>;
        }));
    }

    protected processMappingsPUT(response: HttpResponseBase): Observable<ProductSellerMappingDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductSellerMappingDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    mappingsDELETE(mappingId: string): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/api/Mappings/{mappingId}";
        if (mappingId === undefined || mappingId === null)
            throw new Error("The parameter 'mappingId' must be defined.");
        url_ = url_.replace("{mappingId}", encodeURIComponent("" + mappingId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMappingsDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMappingsDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processMappingsDELETE(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    productsPOST(body: CreateProductDto | undefined): Observable<ProductDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Products";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProductsPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProductsPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductDtoApiResponse>;
        }));
    }

    protected processProductsPOST(response: HttpResponseBase): Observable<ProductDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param categoryId (optional) 
     * @param search (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return OK
     */
    productsGET(categoryId: string | undefined, search: string | undefined, page: number | undefined, pageSize: number | undefined): Observable<ProductDtoPagedResponse> {
        let url_ = this.baseUrl + "/api/Products?";
        if (categoryId === null)
            throw new Error("The parameter 'categoryId' cannot be null.");
        else if (categoryId !== undefined)
            url_ += "categoryId=" + encodeURIComponent("" + categoryId) + "&";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProductsGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProductsGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductDtoPagedResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductDtoPagedResponse>;
        }));
    }

    protected processProductsGET(response: HttpResponseBase): Observable<ProductDtoPagedResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductDtoPagedResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    productsGET2(productId: string): Observable<ProductDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Products/{productId}";
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProductsGET2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProductsGET2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductDtoApiResponse>;
        }));
    }

    protected processProductsGET2(response: HttpResponseBase): Observable<ProductDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    productsPUT(productId: string, body: UpdateProductDto | undefined): Observable<ProductDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Products/{productId}";
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProductsPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProductsPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductDtoApiResponse>;
        }));
    }

    protected processProductsPUT(response: HttpResponseBase): Observable<ProductDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    productsDELETE(productId: string): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/api/Products/{productId}";
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProductsDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProductsDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processProductsDELETE(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param sellerName (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param limit (optional) 
     * @return OK
     */
    priceHistory(productId: string, sellerName: string | undefined, startDate: Date | undefined, endDate: Date | undefined, limit: number | undefined): Observable<PriceHistoryDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Products/{productId}/price-history?";
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        if (sellerName === null)
            throw new Error("The parameter 'sellerName' cannot be null.");
        else if (sellerName !== undefined)
            url_ += "sellerName=" + encodeURIComponent("" + sellerName) + "&";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPriceHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPriceHistory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PriceHistoryDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PriceHistoryDtoIEnumerableApiResponse>;
        }));
    }

    protected processPriceHistory(response: HttpResponseBase): Observable<PriceHistoryDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PriceHistoryDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    public(): Observable<ObjectApiResponse> {
        let url_ = this.baseUrl + "/api/Sample/public";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPublic(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPublic(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResponse>;
        }));
    }

    protected processPublic(response: HttpResponseBase): Observable<ObjectApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    dataGET(): Observable<ObjectApiResponse> {
        let url_ = this.baseUrl + "/api/Sample/data";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDataGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDataGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResponse>;
        }));
    }

    protected processDataGET(response: HttpResponseBase): Observable<ObjectApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    dataPOST(body: any | undefined): Observable<ObjectApiResponse> {
        let url_ = this.baseUrl + "/api/Sample/data";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDataPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDataPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResponse>;
        }));
    }

    protected processDataPOST(response: HttpResponseBase): Observable<ObjectApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    admin(): Observable<ObjectApiResponse> {
        let url_ = this.baseUrl + "/api/Sample/admin";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdmin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdmin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResponse>;
        }));
    }

    protected processAdmin(response: HttpResponseBase): Observable<ObjectApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    dataGET2(userId: string): Observable<ObjectApiResponse> {
        let url_ = this.baseUrl + "/api/Sample/users/{userId}/data";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDataGET2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDataGET2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResponse>;
        }));
    }

    protected processDataGET2(response: HttpResponseBase): Observable<ObjectApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    internal(): Observable<ObjectApiResponse> {
        let url_ = this.baseUrl + "/api/Sample/internal";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInternal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInternal(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResponse>;
        }));
    }

    protected processInternal(response: HttpResponseBase): Observable<ObjectApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    custom(): Observable<ObjectApiResponse> {
        let url_ = this.baseUrl + "/api/Sample/custom";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCustom(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCustom(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResponse>;
        }));
    }

    protected processCustom(response: HttpResponseBase): Observable<ObjectApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    manualAuth(): Observable<ObjectApiResponse> {
        let url_ = this.baseUrl + "/api/Sample/manual-auth";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processManualAuth(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processManualAuth(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResponse>;
        }));
    }

    protected processManualAuth(response: HttpResponseBase): Observable<ObjectApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    siteConfigsPOST(body: CreateScraperSiteConfigurationDto | undefined): Observable<ScraperSiteConfigurationDtoApiResponse> {
        let url_ = this.baseUrl + "/api/site-configs";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSiteConfigsPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSiteConfigsPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ScraperSiteConfigurationDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ScraperSiteConfigurationDtoApiResponse>;
        }));
    }

    protected processSiteConfigsPOST(response: HttpResponseBase): Observable<ScraperSiteConfigurationDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ScraperSiteConfigurationDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param domain (optional) 
     * @return OK
     */
    siteConfigsGET(domain: string | undefined): Observable<ScraperSiteConfigurationDtoApiResponse> {
        let url_ = this.baseUrl + "/api/site-configs?";
        if (domain === null)
            throw new Error("The parameter 'domain' cannot be null.");
        else if (domain !== undefined)
            url_ += "domain=" + encodeURIComponent("" + domain) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSiteConfigsGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSiteConfigsGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ScraperSiteConfigurationDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ScraperSiteConfigurationDtoApiResponse>;
        }));
    }

    protected processSiteConfigsGET(response: HttpResponseBase): Observable<ScraperSiteConfigurationDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ScraperSiteConfigurationDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    siteConfigsGET2(siteConfigId: string): Observable<ScraperSiteConfigurationDtoApiResponse> {
        let url_ = this.baseUrl + "/api/site-configs/{siteConfigId}";
        if (siteConfigId === undefined || siteConfigId === null)
            throw new Error("The parameter 'siteConfigId' must be defined.");
        url_ = url_.replace("{siteConfigId}", encodeURIComponent("" + siteConfigId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSiteConfigsGET2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSiteConfigsGET2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ScraperSiteConfigurationDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ScraperSiteConfigurationDtoApiResponse>;
        }));
    }

    protected processSiteConfigsGET2(response: HttpResponseBase): Observable<ScraperSiteConfigurationDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ScraperSiteConfigurationDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    siteConfigsPUT(siteConfigId: string, body: UpdateScraperSiteConfigurationDto | undefined): Observable<ScraperSiteConfigurationDtoApiResponse> {
        let url_ = this.baseUrl + "/api/site-configs/{siteConfigId}";
        if (siteConfigId === undefined || siteConfigId === null)
            throw new Error("The parameter 'siteConfigId' must be defined.");
        url_ = url_.replace("{siteConfigId}", encodeURIComponent("" + siteConfigId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSiteConfigsPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSiteConfigsPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ScraperSiteConfigurationDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ScraperSiteConfigurationDtoApiResponse>;
        }));
    }

    protected processSiteConfigsPUT(response: HttpResponseBase): Observable<ScraperSiteConfigurationDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ScraperSiteConfigurationDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    siteConfigsDELETE(siteConfigId: string): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/api/site-configs/{siteConfigId}";
        if (siteConfigId === undefined || siteConfigId === null)
            throw new Error("The parameter 'siteConfigId' must be defined.");
        url_ = url_.replace("{siteConfigId}", encodeURIComponent("" + siteConfigId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSiteConfigsDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSiteConfigsDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processSiteConfigsDELETE(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class AlertRuleDto implements IAlertRuleDto {
    alertRuleId?: string;
    userId?: string;
    canonicalProductId?: string;
    conditionType?: string | undefined;
    thresholdValue?: number | undefined;
    percentageValue?: number | undefined;
    specificSellerName?: string | undefined;
    notificationFrequencyMinutes?: number;
    isActive?: boolean;
    lastNotifiedAt?: Date | undefined;
    createdAt?: Date;
    updatedAt?: Date;
    ruleDescription?: string | undefined;
    user?: UserDto;
    product?: ProductDto;

    constructor(data?: IAlertRuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alertRuleId = _data["alertRuleId"];
            this.userId = _data["userId"];
            this.canonicalProductId = _data["canonicalProductId"];
            this.conditionType = _data["conditionType"];
            this.thresholdValue = _data["thresholdValue"];
            this.percentageValue = _data["percentageValue"];
            this.specificSellerName = _data["specificSellerName"];
            this.notificationFrequencyMinutes = _data["notificationFrequencyMinutes"];
            this.isActive = _data["isActive"];
            this.lastNotifiedAt = _data["lastNotifiedAt"] ? new Date(_data["lastNotifiedAt"].toString()) : <any>undefined;
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.ruleDescription = _data["ruleDescription"];
            this.user = _data["user"] ? UserDto.fromJS(_data["user"]) : <any>undefined;
            this.product = _data["product"] ? ProductDto.fromJS(_data["product"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AlertRuleDto {
        data = typeof data === 'object' ? data : {};
        let result = new AlertRuleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["alertRuleId"] = this.alertRuleId;
        data["userId"] = this.userId;
        data["canonicalProductId"] = this.canonicalProductId;
        data["conditionType"] = this.conditionType;
        data["thresholdValue"] = this.thresholdValue;
        data["percentageValue"] = this.percentageValue;
        data["specificSellerName"] = this.specificSellerName;
        data["notificationFrequencyMinutes"] = this.notificationFrequencyMinutes;
        data["isActive"] = this.isActive;
        data["lastNotifiedAt"] = this.lastNotifiedAt ? this.lastNotifiedAt.toISOString() : <any>undefined;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["ruleDescription"] = this.ruleDescription;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        return data;
    }
}

export interface IAlertRuleDto {
    alertRuleId?: string;
    userId?: string;
    canonicalProductId?: string;
    conditionType?: string | undefined;
    thresholdValue?: number | undefined;
    percentageValue?: number | undefined;
    specificSellerName?: string | undefined;
    notificationFrequencyMinutes?: number;
    isActive?: boolean;
    lastNotifiedAt?: Date | undefined;
    createdAt?: Date;
    updatedAt?: Date;
    ruleDescription?: string | undefined;
    user?: UserDto;
    product?: ProductDto;
}

export class AlertRuleDtoApiResponse implements IAlertRuleDtoApiResponse {
    success?: boolean;
    data?: AlertRuleDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IAlertRuleDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"] ? AlertRuleDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): AlertRuleDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AlertRuleDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IAlertRuleDtoApiResponse {
    success?: boolean;
    data?: AlertRuleDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class AlertRuleDtoIEnumerableApiResponse implements IAlertRuleDtoIEnumerableApiResponse {
    success?: boolean;
    data?: AlertRuleDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IAlertRuleDtoIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(AlertRuleDto.fromJS(item));
            }
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): AlertRuleDtoIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AlertRuleDtoIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : <any>undefined);
        }
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IAlertRuleDtoIEnumerableApiResponse {
    success?: boolean;
    data?: AlertRuleDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class AlertRuleDtoPagedResponse implements IAlertRuleDtoPagedResponse {
    success?: boolean;
    data?: AlertRuleDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
    pagination?: PaginationMeta;

    constructor(data?: IAlertRuleDtoPagedResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(AlertRuleDto.fromJS(item));
            }
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
            this.pagination = _data["pagination"] ? PaginationMeta.fromJS(_data["pagination"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AlertRuleDtoPagedResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AlertRuleDtoPagedResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : <any>undefined);
        }
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        data["pagination"] = this.pagination ? this.pagination.toJSON() : <any>undefined;
        return data;
    }
}

export interface IAlertRuleDtoPagedResponse {
    success?: boolean;
    data?: AlertRuleDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
    pagination?: PaginationMeta;
}

export class ApiResponse implements IApiResponse {
    success?: boolean;
    data?: any | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"];
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): ApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IApiResponse {
    success?: boolean;
    data?: any | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class CategoryDto implements ICategoryDto {
    categoryId?: string;
    name?: string | undefined;
    slug?: string | undefined;
    description?: string | undefined;
    createdAt?: Date;
    updatedAt?: Date;

    constructor(data?: ICategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.categoryId = _data["categoryId"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.description = _data["description"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["categoryId"] = this.categoryId;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["description"] = this.description;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        return data;
    }
}

export interface ICategoryDto {
    categoryId?: string;
    name?: string | undefined;
    slug?: string | undefined;
    description?: string | undefined;
    createdAt?: Date;
    updatedAt?: Date;
}

export class CategoryDtoApiResponse implements ICategoryDtoApiResponse {
    success?: boolean;
    data?: CategoryDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: ICategoryDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"] ? CategoryDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): CategoryDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface ICategoryDtoApiResponse {
    success?: boolean;
    data?: CategoryDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class CategoryDtoIEnumerableApiResponse implements ICategoryDtoIEnumerableApiResponse {
    success?: boolean;
    data?: CategoryDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: ICategoryDtoIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(CategoryDto.fromJS(item));
            }
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): CategoryDtoIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryDtoIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : <any>undefined);
        }
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface ICategoryDtoIEnumerableApiResponse {
    success?: boolean;
    data?: CategoryDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class CreateAlertRuleDto implements ICreateAlertRuleDto {
    canonicalProductId!: string;
    conditionType!: string;
    thresholdValue?: number | undefined;
    percentageValue?: number | undefined;
    specificSellerName?: string | undefined;
    notificationFrequencyMinutes?: number;

    constructor(data?: ICreateAlertRuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.canonicalProductId = _data["canonicalProductId"];
            this.conditionType = _data["conditionType"];
            this.thresholdValue = _data["thresholdValue"];
            this.percentageValue = _data["percentageValue"];
            this.specificSellerName = _data["specificSellerName"];
            this.notificationFrequencyMinutes = _data["notificationFrequencyMinutes"];
        }
    }

    static fromJS(data: any): CreateAlertRuleDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAlertRuleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canonicalProductId"] = this.canonicalProductId;
        data["conditionType"] = this.conditionType;
        data["thresholdValue"] = this.thresholdValue;
        data["percentageValue"] = this.percentageValue;
        data["specificSellerName"] = this.specificSellerName;
        data["notificationFrequencyMinutes"] = this.notificationFrequencyMinutes;
        return data;
    }
}

export interface ICreateAlertRuleDto {
    canonicalProductId: string;
    conditionType: string;
    thresholdValue?: number | undefined;
    percentageValue?: number | undefined;
    specificSellerName?: string | undefined;
    notificationFrequencyMinutes?: number;
}

export class CreateCategoryDto implements ICreateCategoryDto {
    name!: string;
    slug?: string | undefined;
    description?: string | undefined;

    constructor(data?: ICreateCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): CreateCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["description"] = this.description;
        return data;
    }
}

export interface ICreateCategoryDto {
    name: string;
    slug?: string | undefined;
    description?: string | undefined;
}

export class CreateProductDto implements ICreateProductDto {
    name!: string;
    manufacturer?: string | undefined;
    modelNumber?: string | undefined;
    sku?: string | undefined;
    categoryId!: string;
    description?: string | undefined;
    specifications?: { [key: string]: any; } | undefined;

    constructor(data?: ICreateProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.manufacturer = _data["manufacturer"];
            this.modelNumber = _data["modelNumber"];
            this.sku = _data["sku"];
            this.categoryId = _data["categoryId"];
            this.description = _data["description"];
            if (_data["specifications"]) {
                this.specifications = {} as any;
                for (let key in _data["specifications"]) {
                    if (_data["specifications"].hasOwnProperty(key))
                        (<any>this.specifications)![key] = _data["specifications"][key];
                }
            }
        }
    }

    static fromJS(data: any): CreateProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["manufacturer"] = this.manufacturer;
        data["modelNumber"] = this.modelNumber;
        data["sku"] = this.sku;
        data["categoryId"] = this.categoryId;
        data["description"] = this.description;
        if (this.specifications) {
            data["specifications"] = {};
            for (let key in this.specifications) {
                if (this.specifications.hasOwnProperty(key))
                    (<any>data["specifications"])[key] = (<any>this.specifications)[key];
            }
        }
        return data;
    }
}

export interface ICreateProductDto {
    name: string;
    manufacturer?: string | undefined;
    modelNumber?: string | undefined;
    sku?: string | undefined;
    categoryId: string;
    description?: string | undefined;
    specifications?: { [key: string]: any; } | undefined;
}

export class CreateProductSellerMappingDto implements ICreateProductSellerMappingDto {
    canonicalProductId!: string;
    sellerName!: string;
    exactProductUrl!: string;
    isActiveForScraping?: boolean;
    scrapingFrequencyOverride?: string | undefined;
    siteConfigId?: string | undefined;

    constructor(data?: ICreateProductSellerMappingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.canonicalProductId = _data["canonicalProductId"];
            this.sellerName = _data["sellerName"];
            this.exactProductUrl = _data["exactProductUrl"];
            this.isActiveForScraping = _data["isActiveForScraping"];
            this.scrapingFrequencyOverride = _data["scrapingFrequencyOverride"];
            this.siteConfigId = _data["siteConfigId"];
        }
    }

    static fromJS(data: any): CreateProductSellerMappingDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductSellerMappingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canonicalProductId"] = this.canonicalProductId;
        data["sellerName"] = this.sellerName;
        data["exactProductUrl"] = this.exactProductUrl;
        data["isActiveForScraping"] = this.isActiveForScraping;
        data["scrapingFrequencyOverride"] = this.scrapingFrequencyOverride;
        data["siteConfigId"] = this.siteConfigId;
        return data;
    }
}

export interface ICreateProductSellerMappingDto {
    canonicalProductId: string;
    sellerName: string;
    exactProductUrl: string;
    isActiveForScraping?: boolean;
    scrapingFrequencyOverride?: string | undefined;
    siteConfigId?: string | undefined;
}

export class CreateScraperSiteConfigurationDto implements ICreateScraperSiteConfigurationDto {
    siteDomain!: string;
    productNameSelector!: string;
    priceSelector!: string;
    stockSelector!: string;
    sellerNameOnPageSelector?: string | undefined;
    defaultUserAgent?: string | undefined;
    additionalHeaders?: { [key: string]: string; } | undefined;
    isEnabled?: boolean;

    constructor(data?: ICreateScraperSiteConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.siteDomain = _data["siteDomain"];
            this.productNameSelector = _data["productNameSelector"];
            this.priceSelector = _data["priceSelector"];
            this.stockSelector = _data["stockSelector"];
            this.sellerNameOnPageSelector = _data["sellerNameOnPageSelector"];
            this.defaultUserAgent = _data["defaultUserAgent"];
            if (_data["additionalHeaders"]) {
                this.additionalHeaders = {} as any;
                for (let key in _data["additionalHeaders"]) {
                    if (_data["additionalHeaders"].hasOwnProperty(key))
                        (<any>this.additionalHeaders)![key] = _data["additionalHeaders"][key];
                }
            }
            this.isEnabled = _data["isEnabled"];
        }
    }

    static fromJS(data: any): CreateScraperSiteConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateScraperSiteConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["siteDomain"] = this.siteDomain;
        data["productNameSelector"] = this.productNameSelector;
        data["priceSelector"] = this.priceSelector;
        data["stockSelector"] = this.stockSelector;
        data["sellerNameOnPageSelector"] = this.sellerNameOnPageSelector;
        data["defaultUserAgent"] = this.defaultUserAgent;
        if (this.additionalHeaders) {
            data["additionalHeaders"] = {};
            for (let key in this.additionalHeaders) {
                if (this.additionalHeaders.hasOwnProperty(key))
                    (<any>data["additionalHeaders"])[key] = (<any>this.additionalHeaders)[key];
            }
        }
        data["isEnabled"] = this.isEnabled;
        return data;
    }
}

export interface ICreateScraperSiteConfigurationDto {
    siteDomain: string;
    productNameSelector: string;
    priceSelector: string;
    stockSelector: string;
    sellerNameOnPageSelector?: string | undefined;
    defaultUserAgent?: string | undefined;
    additionalHeaders?: { [key: string]: string; } | undefined;
    isEnabled?: boolean;
}

export class CreateUserDto implements ICreateUserDto {
    email!: string;
    password!: string;
    firstName?: string | undefined;
    lastName?: string | undefined;
    roles?: string[] | undefined;

    constructor(data?: ICreateUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data;
    }
}

export interface ICreateUserDto {
    email: string;
    password: string;
    firstName?: string | undefined;
    lastName?: string | undefined;
    roles?: string[] | undefined;
}

export class DashboardStatsDto implements IDashboardStatsDto {
    totalProducts?: number;
    totalCategories?: number;
    activeMappings?: number;
    activeAlerts?: number;
    totalUsers?: number | undefined;

    constructor(data?: IDashboardStatsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalProducts = _data["totalProducts"];
            this.totalCategories = _data["totalCategories"];
            this.activeMappings = _data["activeMappings"];
            this.activeAlerts = _data["activeAlerts"];
            this.totalUsers = _data["totalUsers"];
        }
    }

    static fromJS(data: any): DashboardStatsDto {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardStatsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalProducts"] = this.totalProducts;
        data["totalCategories"] = this.totalCategories;
        data["activeMappings"] = this.activeMappings;
        data["activeAlerts"] = this.activeAlerts;
        data["totalUsers"] = this.totalUsers;
        return data;
    }
}

export interface IDashboardStatsDto {
    totalProducts?: number;
    totalCategories?: number;
    activeMappings?: number;
    activeAlerts?: number;
    totalUsers?: number | undefined;
}

export class DashboardStatsDtoApiResponse implements IDashboardStatsDtoApiResponse {
    success?: boolean;
    data?: DashboardStatsDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IDashboardStatsDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"] ? DashboardStatsDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): DashboardStatsDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardStatsDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IDashboardStatsDtoApiResponse {
    success?: boolean;
    data?: DashboardStatsDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class LoginResponseDto implements ILoginResponseDto {
    token?: string | undefined;
    userId?: string;
    email?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    roles?: string[] | undefined;

    constructor(data?: ILoginResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
            this.userId = _data["userId"];
            this.email = _data["email"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
        }
    }

    static fromJS(data: any): LoginResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new LoginResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        data["userId"] = this.userId;
        data["email"] = this.email;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data;
    }
}

export interface ILoginResponseDto {
    token?: string | undefined;
    userId?: string;
    email?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    roles?: string[] | undefined;
}

export class LoginResponseDtoApiResponse implements ILoginResponseDtoApiResponse {
    success?: boolean;
    data?: LoginResponseDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: ILoginResponseDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"] ? LoginResponseDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): LoginResponseDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new LoginResponseDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface ILoginResponseDtoApiResponse {
    success?: boolean;
    data?: LoginResponseDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class LoginUserDto implements ILoginUserDto {
    email!: string;
    password!: string;

    constructor(data?: ILoginUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): LoginUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new LoginUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        return data;
    }
}

export interface ILoginUserDto {
    email: string;
    password: string;
}

export class ObjectApiResponse implements IObjectApiResponse {
    success?: boolean;
    data?: any | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IObjectApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"];
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): ObjectApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ObjectApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IObjectApiResponse {
    success?: boolean;
    data?: any | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class ObjectPagedResponse implements IObjectPagedResponse {
    success?: boolean;
    data?: any[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
    pagination?: PaginationMeta;

    constructor(data?: IObjectPagedResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(item);
            }
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
            this.pagination = _data["pagination"] ? PaginationMeta.fromJS(_data["pagination"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ObjectPagedResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ObjectPagedResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item);
        }
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        data["pagination"] = this.pagination ? this.pagination.toJSON() : <any>undefined;
        return data;
    }
}

export interface IObjectPagedResponse {
    success?: boolean;
    data?: any[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
    pagination?: PaginationMeta;
}

export class PaginationMeta implements IPaginationMeta {
    pageNumber?: number;
    pageSize?: number;
    totalCount?: number;
    readonly totalPages?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;
    readonly firstItemOnPage?: number;
    readonly lastItemOnPage?: number;

    constructor(data?: IPaginationMeta) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
            this.totalCount = _data["totalCount"];
            (<any>this).totalPages = _data["totalPages"];
            (<any>this).hasPreviousPage = _data["hasPreviousPage"];
            (<any>this).hasNextPage = _data["hasNextPage"];
            (<any>this).firstItemOnPage = _data["firstItemOnPage"];
            (<any>this).lastItemOnPage = _data["lastItemOnPage"];
        }
    }

    static fromJS(data: any): PaginationMeta {
        data = typeof data === 'object' ? data : {};
        let result = new PaginationMeta();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        data["totalCount"] = this.totalCount;
        data["totalPages"] = this.totalPages;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        data["firstItemOnPage"] = this.firstItemOnPage;
        data["lastItemOnPage"] = this.lastItemOnPage;
        return data;
    }
}

export interface IPaginationMeta {
    pageNumber?: number;
    pageSize?: number;
    totalCount?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    firstItemOnPage?: number;
    lastItemOnPage?: number;
}

export class PriceHistoryDto implements IPriceHistoryDto {
    timestamp?: Date;
    price?: number;
    stockStatus?: string | undefined;
    sourceUrl?: string | undefined;
    scrapedProductNameOnPage?: string | undefined;

    constructor(data?: IPriceHistoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.price = _data["price"];
            this.stockStatus = _data["stockStatus"];
            this.sourceUrl = _data["sourceUrl"];
            this.scrapedProductNameOnPage = _data["scrapedProductNameOnPage"];
        }
    }

    static fromJS(data: any): PriceHistoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new PriceHistoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["price"] = this.price;
        data["stockStatus"] = this.stockStatus;
        data["sourceUrl"] = this.sourceUrl;
        data["scrapedProductNameOnPage"] = this.scrapedProductNameOnPage;
        return data;
    }
}

export interface IPriceHistoryDto {
    timestamp?: Date;
    price?: number;
    stockStatus?: string | undefined;
    sourceUrl?: string | undefined;
    scrapedProductNameOnPage?: string | undefined;
}

export class PriceHistoryDtoIEnumerableApiResponse implements IPriceHistoryDtoIEnumerableApiResponse {
    success?: boolean;
    data?: PriceHistoryDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IPriceHistoryDtoIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(PriceHistoryDto.fromJS(item));
            }
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): PriceHistoryDtoIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PriceHistoryDtoIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : <any>undefined);
        }
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IPriceHistoryDtoIEnumerableApiResponse {
    success?: boolean;
    data?: PriceHistoryDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class ProductDto implements IProductDto {
    productId?: string;
    name?: string | undefined;
    manufacturer?: string | undefined;
    modelNumber?: string | undefined;
    sku?: string | undefined;
    categoryId?: string;
    description?: string | undefined;
    specifications?: { [key: string]: any; } | undefined;
    isActive?: boolean;
    createdAt?: Date;
    updatedAt?: Date;
    category?: CategoryDto;

    constructor(data?: IProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.name = _data["name"];
            this.manufacturer = _data["manufacturer"];
            this.modelNumber = _data["modelNumber"];
            this.sku = _data["sku"];
            this.categoryId = _data["categoryId"];
            this.description = _data["description"];
            if (_data["specifications"]) {
                this.specifications = {} as any;
                for (let key in _data["specifications"]) {
                    if (_data["specifications"].hasOwnProperty(key))
                        (<any>this.specifications)![key] = _data["specifications"][key];
                }
            }
            this.isActive = _data["isActive"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.category = _data["category"] ? CategoryDto.fromJS(_data["category"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["name"] = this.name;
        data["manufacturer"] = this.manufacturer;
        data["modelNumber"] = this.modelNumber;
        data["sku"] = this.sku;
        data["categoryId"] = this.categoryId;
        data["description"] = this.description;
        if (this.specifications) {
            data["specifications"] = {};
            for (let key in this.specifications) {
                if (this.specifications.hasOwnProperty(key))
                    (<any>data["specifications"])[key] = (<any>this.specifications)[key];
            }
        }
        data["isActive"] = this.isActive;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["category"] = this.category ? this.category.toJSON() : <any>undefined;
        return data;
    }
}

export interface IProductDto {
    productId?: string;
    name?: string | undefined;
    manufacturer?: string | undefined;
    modelNumber?: string | undefined;
    sku?: string | undefined;
    categoryId?: string;
    description?: string | undefined;
    specifications?: { [key: string]: any; } | undefined;
    isActive?: boolean;
    createdAt?: Date;
    updatedAt?: Date;
    category?: CategoryDto;
}

export class ProductDtoApiResponse implements IProductDtoApiResponse {
    success?: boolean;
    data?: ProductDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IProductDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"] ? ProductDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): ProductDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ProductDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IProductDtoApiResponse {
    success?: boolean;
    data?: ProductDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class ProductDtoPagedResponse implements IProductDtoPagedResponse {
    success?: boolean;
    data?: ProductDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
    pagination?: PaginationMeta;

    constructor(data?: IProductDtoPagedResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(ProductDto.fromJS(item));
            }
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
            this.pagination = _data["pagination"] ? PaginationMeta.fromJS(_data["pagination"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProductDtoPagedResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ProductDtoPagedResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : <any>undefined);
        }
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        data["pagination"] = this.pagination ? this.pagination.toJSON() : <any>undefined;
        return data;
    }
}

export interface IProductDtoPagedResponse {
    success?: boolean;
    data?: ProductDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
    pagination?: PaginationMeta;
}

export class ProductSellerMappingDto implements IProductSellerMappingDto {
    mappingId?: string;
    canonicalProductId?: string;
    sellerName?: string | undefined;
    exactProductUrl?: string | undefined;
    isActiveForScraping?: boolean;
    scrapingFrequencyOverride?: string | undefined;
    siteConfigId?: string | undefined;
    lastScrapedAt?: Date | undefined;
    nextScrapeAt?: Date | undefined;
    lastScrapeStatus?: string | undefined;
    lastScrapeErrorCode?: string | undefined;
    consecutiveFailureCount?: number;
    createdAt?: Date;
    updatedAt?: Date;
    product?: ProductDto;
    siteConfiguration?: ScraperSiteConfigurationDto;

    constructor(data?: IProductSellerMappingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.mappingId = _data["mappingId"];
            this.canonicalProductId = _data["canonicalProductId"];
            this.sellerName = _data["sellerName"];
            this.exactProductUrl = _data["exactProductUrl"];
            this.isActiveForScraping = _data["isActiveForScraping"];
            this.scrapingFrequencyOverride = _data["scrapingFrequencyOverride"];
            this.siteConfigId = _data["siteConfigId"];
            this.lastScrapedAt = _data["lastScrapedAt"] ? new Date(_data["lastScrapedAt"].toString()) : <any>undefined;
            this.nextScrapeAt = _data["nextScrapeAt"] ? new Date(_data["nextScrapeAt"].toString()) : <any>undefined;
            this.lastScrapeStatus = _data["lastScrapeStatus"];
            this.lastScrapeErrorCode = _data["lastScrapeErrorCode"];
            this.consecutiveFailureCount = _data["consecutiveFailureCount"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.product = _data["product"] ? ProductDto.fromJS(_data["product"]) : <any>undefined;
            this.siteConfiguration = _data["siteConfiguration"] ? ScraperSiteConfigurationDto.fromJS(_data["siteConfiguration"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProductSellerMappingDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductSellerMappingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mappingId"] = this.mappingId;
        data["canonicalProductId"] = this.canonicalProductId;
        data["sellerName"] = this.sellerName;
        data["exactProductUrl"] = this.exactProductUrl;
        data["isActiveForScraping"] = this.isActiveForScraping;
        data["scrapingFrequencyOverride"] = this.scrapingFrequencyOverride;
        data["siteConfigId"] = this.siteConfigId;
        data["lastScrapedAt"] = this.lastScrapedAt ? this.lastScrapedAt.toISOString() : <any>undefined;
        data["nextScrapeAt"] = this.nextScrapeAt ? this.nextScrapeAt.toISOString() : <any>undefined;
        data["lastScrapeStatus"] = this.lastScrapeStatus;
        data["lastScrapeErrorCode"] = this.lastScrapeErrorCode;
        data["consecutiveFailureCount"] = this.consecutiveFailureCount;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        data["siteConfiguration"] = this.siteConfiguration ? this.siteConfiguration.toJSON() : <any>undefined;
        return data;
    }
}

export interface IProductSellerMappingDto {
    mappingId?: string;
    canonicalProductId?: string;
    sellerName?: string | undefined;
    exactProductUrl?: string | undefined;
    isActiveForScraping?: boolean;
    scrapingFrequencyOverride?: string | undefined;
    siteConfigId?: string | undefined;
    lastScrapedAt?: Date | undefined;
    nextScrapeAt?: Date | undefined;
    lastScrapeStatus?: string | undefined;
    lastScrapeErrorCode?: string | undefined;
    consecutiveFailureCount?: number;
    createdAt?: Date;
    updatedAt?: Date;
    product?: ProductDto;
    siteConfiguration?: ScraperSiteConfigurationDto;
}

export class ProductSellerMappingDtoApiResponse implements IProductSellerMappingDtoApiResponse {
    success?: boolean;
    data?: ProductSellerMappingDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IProductSellerMappingDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"] ? ProductSellerMappingDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): ProductSellerMappingDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ProductSellerMappingDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IProductSellerMappingDtoApiResponse {
    success?: boolean;
    data?: ProductSellerMappingDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class ProductSellerMappingDtoIEnumerableApiResponse implements IProductSellerMappingDtoIEnumerableApiResponse {
    success?: boolean;
    data?: ProductSellerMappingDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IProductSellerMappingDtoIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(ProductSellerMappingDto.fromJS(item));
            }
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): ProductSellerMappingDtoIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ProductSellerMappingDtoIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : <any>undefined);
        }
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IProductSellerMappingDtoIEnumerableApiResponse {
    success?: boolean;
    data?: ProductSellerMappingDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class RegisterUserDto implements IRegisterUserDto {
    email!: string;
    password!: string;
    firstName?: string | undefined;
    lastName?: string | undefined;

    constructor(data?: IRegisterUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
        }
    }

    static fromJS(data: any): RegisterUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        return data;
    }
}

export interface IRegisterUserDto {
    email: string;
    password: string;
    firstName?: string | undefined;
    lastName?: string | undefined;
}

export class ScraperSiteConfigurationDto implements IScraperSiteConfigurationDto {
    siteConfigId?: string;
    siteDomain?: string | undefined;
    productNameSelector?: string | undefined;
    priceSelector?: string | undefined;
    stockSelector?: string | undefined;
    sellerNameOnPageSelector?: string | undefined;
    defaultUserAgent?: string | undefined;
    additionalHeaders?: { [key: string]: string; } | undefined;
    isEnabled?: boolean;
    createdAt?: Date;
    updatedAt?: Date;

    constructor(data?: IScraperSiteConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.siteConfigId = _data["siteConfigId"];
            this.siteDomain = _data["siteDomain"];
            this.productNameSelector = _data["productNameSelector"];
            this.priceSelector = _data["priceSelector"];
            this.stockSelector = _data["stockSelector"];
            this.sellerNameOnPageSelector = _data["sellerNameOnPageSelector"];
            this.defaultUserAgent = _data["defaultUserAgent"];
            if (_data["additionalHeaders"]) {
                this.additionalHeaders = {} as any;
                for (let key in _data["additionalHeaders"]) {
                    if (_data["additionalHeaders"].hasOwnProperty(key))
                        (<any>this.additionalHeaders)![key] = _data["additionalHeaders"][key];
                }
            }
            this.isEnabled = _data["isEnabled"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ScraperSiteConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ScraperSiteConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["siteConfigId"] = this.siteConfigId;
        data["siteDomain"] = this.siteDomain;
        data["productNameSelector"] = this.productNameSelector;
        data["priceSelector"] = this.priceSelector;
        data["stockSelector"] = this.stockSelector;
        data["sellerNameOnPageSelector"] = this.sellerNameOnPageSelector;
        data["defaultUserAgent"] = this.defaultUserAgent;
        if (this.additionalHeaders) {
            data["additionalHeaders"] = {};
            for (let key in this.additionalHeaders) {
                if (this.additionalHeaders.hasOwnProperty(key))
                    (<any>data["additionalHeaders"])[key] = (<any>this.additionalHeaders)[key];
            }
        }
        data["isEnabled"] = this.isEnabled;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        return data;
    }
}

export interface IScraperSiteConfigurationDto {
    siteConfigId?: string;
    siteDomain?: string | undefined;
    productNameSelector?: string | undefined;
    priceSelector?: string | undefined;
    stockSelector?: string | undefined;
    sellerNameOnPageSelector?: string | undefined;
    defaultUserAgent?: string | undefined;
    additionalHeaders?: { [key: string]: string; } | undefined;
    isEnabled?: boolean;
    createdAt?: Date;
    updatedAt?: Date;
}

export class ScraperSiteConfigurationDtoApiResponse implements IScraperSiteConfigurationDtoApiResponse {
    success?: boolean;
    data?: ScraperSiteConfigurationDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IScraperSiteConfigurationDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"] ? ScraperSiteConfigurationDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): ScraperSiteConfigurationDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ScraperSiteConfigurationDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IScraperSiteConfigurationDtoApiResponse {
    success?: boolean;
    data?: ScraperSiteConfigurationDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class StringApiResponse implements IStringApiResponse {
    success?: boolean;
    data?: string | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IStringApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"];
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): StringApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new StringApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IStringApiResponse {
    success?: boolean;
    data?: string | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class UpdateAlertRuleDto implements IUpdateAlertRuleDto {
    conditionType?: string | undefined;
    thresholdValue?: number | undefined;
    percentageValue?: number | undefined;
    specificSellerName?: string | undefined;
    notificationFrequencyMinutes?: number | undefined;
    isActive?: boolean | undefined;

    constructor(data?: IUpdateAlertRuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.conditionType = _data["conditionType"];
            this.thresholdValue = _data["thresholdValue"];
            this.percentageValue = _data["percentageValue"];
            this.specificSellerName = _data["specificSellerName"];
            this.notificationFrequencyMinutes = _data["notificationFrequencyMinutes"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): UpdateAlertRuleDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAlertRuleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["conditionType"] = this.conditionType;
        data["thresholdValue"] = this.thresholdValue;
        data["percentageValue"] = this.percentageValue;
        data["specificSellerName"] = this.specificSellerName;
        data["notificationFrequencyMinutes"] = this.notificationFrequencyMinutes;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IUpdateAlertRuleDto {
    conditionType?: string | undefined;
    thresholdValue?: number | undefined;
    percentageValue?: number | undefined;
    specificSellerName?: string | undefined;
    notificationFrequencyMinutes?: number | undefined;
    isActive?: boolean | undefined;
}

export class UpdateCategoryDto implements IUpdateCategoryDto {
    name?: string | undefined;
    slug?: string | undefined;
    description?: string | undefined;

    constructor(data?: IUpdateCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): UpdateCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["description"] = this.description;
        return data;
    }
}

export interface IUpdateCategoryDto {
    name?: string | undefined;
    slug?: string | undefined;
    description?: string | undefined;
}

export class UpdateProductDto implements IUpdateProductDto {
    name?: string | undefined;
    manufacturer?: string | undefined;
    modelNumber?: string | undefined;
    sku?: string | undefined;
    categoryId?: string | undefined;
    description?: string | undefined;
    specifications?: { [key: string]: any; } | undefined;
    isActive?: boolean | undefined;

    constructor(data?: IUpdateProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.manufacturer = _data["manufacturer"];
            this.modelNumber = _data["modelNumber"];
            this.sku = _data["sku"];
            this.categoryId = _data["categoryId"];
            this.description = _data["description"];
            if (_data["specifications"]) {
                this.specifications = {} as any;
                for (let key in _data["specifications"]) {
                    if (_data["specifications"].hasOwnProperty(key))
                        (<any>this.specifications)![key] = _data["specifications"][key];
                }
            }
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): UpdateProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["manufacturer"] = this.manufacturer;
        data["modelNumber"] = this.modelNumber;
        data["sku"] = this.sku;
        data["categoryId"] = this.categoryId;
        data["description"] = this.description;
        if (this.specifications) {
            data["specifications"] = {};
            for (let key in this.specifications) {
                if (this.specifications.hasOwnProperty(key))
                    (<any>data["specifications"])[key] = (<any>this.specifications)[key];
            }
        }
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IUpdateProductDto {
    name?: string | undefined;
    manufacturer?: string | undefined;
    modelNumber?: string | undefined;
    sku?: string | undefined;
    categoryId?: string | undefined;
    description?: string | undefined;
    specifications?: { [key: string]: any; } | undefined;
    isActive?: boolean | undefined;
}

export class UpdateProductSellerMappingDto implements IUpdateProductSellerMappingDto {
    sellerName?: string | undefined;
    exactProductUrl?: string | undefined;
    isActiveForScraping?: boolean | undefined;
    scrapingFrequencyOverride?: string | undefined;
    siteConfigId?: string | undefined;

    constructor(data?: IUpdateProductSellerMappingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sellerName = _data["sellerName"];
            this.exactProductUrl = _data["exactProductUrl"];
            this.isActiveForScraping = _data["isActiveForScraping"];
            this.scrapingFrequencyOverride = _data["scrapingFrequencyOverride"];
            this.siteConfigId = _data["siteConfigId"];
        }
    }

    static fromJS(data: any): UpdateProductSellerMappingDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductSellerMappingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sellerName"] = this.sellerName;
        data["exactProductUrl"] = this.exactProductUrl;
        data["isActiveForScraping"] = this.isActiveForScraping;
        data["scrapingFrequencyOverride"] = this.scrapingFrequencyOverride;
        data["siteConfigId"] = this.siteConfigId;
        return data;
    }
}

export interface IUpdateProductSellerMappingDto {
    sellerName?: string | undefined;
    exactProductUrl?: string | undefined;
    isActiveForScraping?: boolean | undefined;
    scrapingFrequencyOverride?: string | undefined;
    siteConfigId?: string | undefined;
}

export class UpdateScraperSiteConfigurationDto implements IUpdateScraperSiteConfigurationDto {
    siteDomain?: string | undefined;
    productNameSelector?: string | undefined;
    priceSelector?: string | undefined;
    stockSelector?: string | undefined;
    sellerNameOnPageSelector?: string | undefined;
    defaultUserAgent?: string | undefined;
    additionalHeaders?: { [key: string]: string; } | undefined;
    isEnabled?: boolean | undefined;

    constructor(data?: IUpdateScraperSiteConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.siteDomain = _data["siteDomain"];
            this.productNameSelector = _data["productNameSelector"];
            this.priceSelector = _data["priceSelector"];
            this.stockSelector = _data["stockSelector"];
            this.sellerNameOnPageSelector = _data["sellerNameOnPageSelector"];
            this.defaultUserAgent = _data["defaultUserAgent"];
            if (_data["additionalHeaders"]) {
                this.additionalHeaders = {} as any;
                for (let key in _data["additionalHeaders"]) {
                    if (_data["additionalHeaders"].hasOwnProperty(key))
                        (<any>this.additionalHeaders)![key] = _data["additionalHeaders"][key];
                }
            }
            this.isEnabled = _data["isEnabled"];
        }
    }

    static fromJS(data: any): UpdateScraperSiteConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateScraperSiteConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["siteDomain"] = this.siteDomain;
        data["productNameSelector"] = this.productNameSelector;
        data["priceSelector"] = this.priceSelector;
        data["stockSelector"] = this.stockSelector;
        data["sellerNameOnPageSelector"] = this.sellerNameOnPageSelector;
        data["defaultUserAgent"] = this.defaultUserAgent;
        if (this.additionalHeaders) {
            data["additionalHeaders"] = {};
            for (let key in this.additionalHeaders) {
                if (this.additionalHeaders.hasOwnProperty(key))
                    (<any>data["additionalHeaders"])[key] = (<any>this.additionalHeaders)[key];
            }
        }
        data["isEnabled"] = this.isEnabled;
        return data;
    }
}

export interface IUpdateScraperSiteConfigurationDto {
    siteDomain?: string | undefined;
    productNameSelector?: string | undefined;
    priceSelector?: string | undefined;
    stockSelector?: string | undefined;
    sellerNameOnPageSelector?: string | undefined;
    defaultUserAgent?: string | undefined;
    additionalHeaders?: { [key: string]: string; } | undefined;
    isEnabled?: boolean | undefined;
}

export class UpdateUserDto implements IUpdateUserDto {
    email?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    roles?: string[] | undefined;
    isActive?: boolean | undefined;

    constructor(data?: IUpdateUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): UpdateUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IUpdateUserDto {
    email?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    roles?: string[] | undefined;
    isActive?: boolean | undefined;
}

export class UserDto implements IUserDto {
    userId?: string;
    email?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    fullName?: string | undefined;
    isActive?: boolean;
    createdAt?: Date;
    updatedAt?: Date;
    roles?: string[] | undefined;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.email = _data["email"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.fullName = _data["fullName"];
            this.isActive = _data["isActive"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["email"] = this.email;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["fullName"] = this.fullName;
        data["isActive"] = this.isActive;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data;
    }
}

export interface IUserDto {
    userId?: string;
    email?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    fullName?: string | undefined;
    isActive?: boolean;
    createdAt?: Date;
    updatedAt?: Date;
    roles?: string[] | undefined;
}

export class UserDtoApiResponse implements IUserDtoApiResponse {
    success?: boolean;
    data?: UserDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IUserDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"] ? UserDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): UserDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UserDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IUserDtoApiResponse {
    success?: boolean;
    data?: UserDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class UserDtoPagedResponse implements IUserDtoPagedResponse {
    success?: boolean;
    data?: UserDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
    pagination?: PaginationMeta;

    constructor(data?: IUserDtoPagedResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(UserDto.fromJS(item));
            }
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
            this.pagination = _data["pagination"] ? PaginationMeta.fromJS(_data["pagination"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UserDtoPagedResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UserDtoPagedResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : <any>undefined);
        }
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        data["pagination"] = this.pagination ? this.pagination.toJSON() : <any>undefined;
        return data;
    }
}

export interface IUserDtoPagedResponse {
    success?: boolean;
    data?: UserDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
    pagination?: PaginationMeta;
}

export class UtilitiesExampleRequest implements IUtilitiesExampleRequest {
    text?: string | undefined;
    email?: string | undefined;

    constructor(data?: IUtilitiesExampleRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.text = _data["text"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): UtilitiesExampleRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UtilitiesExampleRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["text"] = this.text;
        data["email"] = this.email;
        return data;
    }
}

export interface IUtilitiesExampleRequest {
    text?: string | undefined;
    email?: string | undefined;
}

export class ValidationExampleRequest implements IValidationExampleRequest {
    email?: string | undefined;
    phone?: string | undefined;
    website?: string | undefined;

    constructor(data?: IValidationExampleRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.phone = _data["phone"];
            this.website = _data["website"];
        }
    }

    static fromJS(data: any): ValidationExampleRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationExampleRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["website"] = this.website;
        return data;
    }
}

export interface IValidationExampleRequest {
    email?: string | undefined;
    phone?: string | undefined;
    website?: string | undefined;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    return _observableThrow(new ApiException(message, status, response, headers, result));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}