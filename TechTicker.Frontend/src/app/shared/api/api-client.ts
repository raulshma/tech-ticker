//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.4.0.0 (NJsonSchema v11.3.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable({
    providedIn: 'root'
})
export class TechTickerApiClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return OK
     */
    getAllUsers(page: number | undefined, pageSize: number | undefined): Observable<UserDtoPagedResponse> {
        let url_ = this.baseUrl + "/api/Admin/users?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUsers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDtoPagedResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDtoPagedResponse>;
        }));
    }

    protected processGetAllUsers(response: HttpResponseBase): Observable<UserDtoPagedResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDtoPagedResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createUser(body: CreateUserDto | undefined): Observable<UserDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Admin/users";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDtoApiResponse>;
        }));
    }

    protected processCreateUser(response: HttpResponseBase): Observable<UserDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getUserById(userId: string): Observable<UserDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Admin/users/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDtoApiResponse>;
        }));
    }

    protected processGetUserById(response: HttpResponseBase): Observable<UserDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    updateUser(userId: string, body: UpdateUserDto | undefined): Observable<UserDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Admin/users/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDtoApiResponse>;
        }));
    }

    protected processUpdateUser(response: HttpResponseBase): Observable<UserDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    deleteUser(userId: string): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/api/Admin/users/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processDeleteUser(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param userId (optional) 
     * @param productId (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return OK
     */
    adminGetAllAlerts(userId: string | undefined, productId: string | undefined, page: number | undefined, pageSize: number | undefined): Observable<AlertRuleDtoPagedResponse> {
        let url_ = this.baseUrl + "/api/Admin/alerts?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (productId === null)
            throw new Error("The parameter 'productId' cannot be null.");
        else if (productId !== undefined)
            url_ += "productId=" + encodeURIComponent("" + productId) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminGetAllAlerts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminGetAllAlerts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AlertRuleDtoPagedResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AlertRuleDtoPagedResponse>;
        }));
    }

    protected processAdminGetAllAlerts(response: HttpResponseBase): Observable<AlertRuleDtoPagedResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AlertRuleDtoPagedResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getAllConfigurations(): Observable<AiConfigurationDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/ai-configurations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllConfigurations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllConfigurations(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AiConfigurationDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AiConfigurationDtoIEnumerableApiResponse>;
        }));
    }

    protected processGetAllConfigurations(response: HttpResponseBase): Observable<AiConfigurationDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AiConfigurationDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createConfiguration(body: CreateAiConfigurationDto | undefined): Observable<AiConfigurationDtoApiResponse> {
        let url_ = this.baseUrl + "/api/ai-configurations";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateConfiguration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateConfiguration(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AiConfigurationDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AiConfigurationDtoApiResponse>;
        }));
    }

    protected processCreateConfiguration(response: HttpResponseBase): Observable<AiConfigurationDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AiConfigurationDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getActiveConfigurations(): Observable<AiConfigurationDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/ai-configurations/active";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActiveConfigurations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActiveConfigurations(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AiConfigurationDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AiConfigurationDtoIEnumerableApiResponse>;
        }));
    }

    protected processGetActiveConfigurations(response: HttpResponseBase): Observable<AiConfigurationDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AiConfigurationDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getConfigurationById(id: string): Observable<AiConfigurationDtoApiResponse> {
        let url_ = this.baseUrl + "/api/ai-configurations/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetConfigurationById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConfigurationById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AiConfigurationDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AiConfigurationDtoApiResponse>;
        }));
    }

    protected processGetConfigurationById(response: HttpResponseBase): Observable<AiConfigurationDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AiConfigurationDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    updateConfiguration(id: string, body: UpdateAiConfigurationDto | undefined): Observable<AiConfigurationDtoApiResponse> {
        let url_ = this.baseUrl + "/api/ai-configurations/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateConfiguration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateConfiguration(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AiConfigurationDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AiConfigurationDtoApiResponse>;
        }));
    }

    protected processUpdateConfiguration(response: HttpResponseBase): Observable<AiConfigurationDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AiConfigurationDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    deleteConfiguration(id: string): Observable<BooleanApiResponse> {
        let url_ = this.baseUrl + "/api/ai-configurations/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteConfiguration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteConfiguration(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponse>;
        }));
    }

    protected processDeleteConfiguration(response: HttpResponseBase): Observable<BooleanApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getDefaultConfiguration(): Observable<AiConfigurationDtoApiResponse> {
        let url_ = this.baseUrl + "/api/ai-configurations/default";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDefaultConfiguration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDefaultConfiguration(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AiConfigurationDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AiConfigurationDtoApiResponse>;
        }));
    }

    protected processGetDefaultConfiguration(response: HttpResponseBase): Observable<AiConfigurationDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AiConfigurationDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    setDefaultConfiguration(id: string): Observable<BooleanApiResponse> {
        let url_ = this.baseUrl + "/api/ai-configurations/{id}/set-default";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetDefaultConfiguration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetDefaultConfiguration(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponse>;
        }));
    }

    protected processSetDefaultConfiguration(response: HttpResponseBase): Observable<BooleanApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    testConfiguration(id: string): Observable<BooleanApiResponse> {
        let url_ = this.baseUrl + "/api/ai-configurations/{id}/test";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestConfiguration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestConfiguration(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponse>;
        }));
    }

    protected processTestConfiguration(response: HttpResponseBase): Observable<BooleanApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    getAvailableModels(provider: string, body: ProviderModelsRequestDto | undefined): Observable<AiProviderModelsDtoApiResponse> {
        let url_ = this.baseUrl + "/api/ai-configurations/models/{provider}";
        if (provider === undefined || provider === null)
            throw new Error("The parameter 'provider' must be defined.");
        url_ = url_.replace("{provider}", encodeURIComponent("" + provider));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAvailableModels(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAvailableModels(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AiProviderModelsDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AiProviderModelsDtoApiResponse>;
        }));
    }

    protected processGetAvailableModels(response: HttpResponseBase): Observable<AiProviderModelsDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AiProviderModelsDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    generateBrowserActions(body: BrowserActionGenerationRequestDto | undefined): Observable<BrowserActionGenerationResponseDtoApiResponse> {
        let url_ = this.baseUrl + "/api/ai-configurations/generate-browser-actions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerateBrowserActions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerateBrowserActions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BrowserActionGenerationResponseDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BrowserActionGenerationResponseDtoApiResponse>;
        }));
    }

    protected processGenerateBrowserActions(response: HttpResponseBase): Observable<BrowserActionGenerationResponseDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BrowserActionGenerationResponseDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    generateGenericResponse(body: GenericAiRequestDto | undefined): Observable<GenericAiResponseDtoApiResponse> {
        let url_ = this.baseUrl + "/api/ai-configurations/generate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerateGenericResponse(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerateGenericResponse(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GenericAiResponseDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GenericAiResponseDtoApiResponse>;
        }));
    }

    protected processGenerateGenericResponse(response: HttpResponseBase): Observable<GenericAiResponseDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GenericAiResponseDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    checkAiAvailability(): Observable<BooleanApiResponse> {
        let url_ = this.baseUrl + "/api/ai-configurations/availability";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckAiAvailability(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckAiAvailability(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponse>;
        }));
    }

    protected processCheckAiAvailability(response: HttpResponseBase): Observable<BooleanApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return OK
     */
    getSystemPerformance(startDate: Date | undefined, endDate: Date | undefined): Observable<AlertSystemPerformanceDtoApiResponse> {
        let url_ = this.baseUrl + "/api/alert-performance/system?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSystemPerformance(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSystemPerformance(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AlertSystemPerformanceDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AlertSystemPerformanceDtoApiResponse>;
        }));
    }

    protected processGetSystemPerformance(response: HttpResponseBase): Observable<AlertSystemPerformanceDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AlertSystemPerformanceDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getAlertRulePerformance(alertRuleId: string): Observable<AlertRulePerformanceAnalysisDtoApiResponse> {
        let url_ = this.baseUrl + "/api/alert-performance/alert-rule/{alertRuleId}";
        if (alertRuleId === undefined || alertRuleId === null)
            throw new Error("The parameter 'alertRuleId' must be defined.");
        url_ = url_.replace("{alertRuleId}", encodeURIComponent("" + alertRuleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAlertRulePerformance(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAlertRulePerformance(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AlertRulePerformanceAnalysisDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AlertRulePerformanceAnalysisDtoApiResponse>;
        }));
    }

    protected processGetAlertRulePerformance(response: HttpResponseBase): Observable<AlertRulePerformanceAnalysisDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AlertRulePerformanceAnalysisDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getRealTimeMonitoring(): Observable<RealTimeAlertMonitoringDtoApiResponse> {
        let url_ = this.baseUrl + "/api/alert-performance/real-time";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRealTimeMonitoring(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRealTimeMonitoring(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RealTimeAlertMonitoringDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RealTimeAlertMonitoringDtoApiResponse>;
        }));
    }

    protected processGetRealTimeMonitoring(response: HttpResponseBase): Observable<RealTimeAlertMonitoringDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RealTimeAlertMonitoringDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param intervalHours (optional) 
     * @return OK
     */
    getPerformanceTrends(startDate: Date | undefined, endDate: Date | undefined, intervalHours: number | undefined): Observable<AlertPerformanceTrendDtoListApiResponse> {
        let url_ = this.baseUrl + "/api/alert-performance/trends?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        if (intervalHours === null)
            throw new Error("The parameter 'intervalHours' cannot be null.");
        else if (intervalHours !== undefined)
            url_ += "intervalHours=" + encodeURIComponent("" + intervalHours) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPerformanceTrends(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPerformanceTrends(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AlertPerformanceTrendDtoListApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AlertPerformanceTrendDtoListApiResponse>;
        }));
    }

    protected processGetPerformanceTrends(response: HttpResponseBase): Observable<AlertPerformanceTrendDtoListApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AlertPerformanceTrendDtoListApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getSystemHealth(): Observable<AlertSystemHealthDtoApiResponse> {
        let url_ = this.baseUrl + "/api/alert-performance/health";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSystemHealth(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSystemHealth(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AlertSystemHealthDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AlertSystemHealthDtoApiResponse>;
        }));
    }

    protected processGetSystemHealth(response: HttpResponseBase): Observable<AlertSystemHealthDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AlertSystemHealthDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param count (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return OK
     */
    getTopPerformingAlertRules(count: number | undefined, startDate: Date | undefined, endDate: Date | undefined): Observable<AlertRulePerformanceAnalysisDtoListApiResponse> {
        let url_ = this.baseUrl + "/api/alert-performance/top-performers?";
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTopPerformingAlertRules(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTopPerformingAlertRules(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AlertRulePerformanceAnalysisDtoListApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AlertRulePerformanceAnalysisDtoListApiResponse>;
        }));
    }

    protected processGetTopPerformingAlertRules(response: HttpResponseBase): Observable<AlertRulePerformanceAnalysisDtoListApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AlertRulePerformanceAnalysisDtoListApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param count (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return OK
     */
    getPoorlyPerformingAlertRules(count: number | undefined, startDate: Date | undefined, endDate: Date | undefined): Observable<AlertRulePerformanceAnalysisDtoListApiResponse> {
        let url_ = this.baseUrl + "/api/alert-performance/poor-performers?";
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPoorlyPerformingAlertRules(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPoorlyPerformingAlertRules(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AlertRulePerformanceAnalysisDtoListApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AlertRulePerformanceAnalysisDtoListApiResponse>;
        }));
    }

    protected processGetPoorlyPerformingAlertRules(response: HttpResponseBase): Observable<AlertRulePerformanceAnalysisDtoListApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AlertRulePerformanceAnalysisDtoListApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return OK
     */
    generatePerformanceReport(startDate: Date | undefined, endDate: Date | undefined): Observable<AlertPerformanceReportDtoApiResponse> {
        let url_ = this.baseUrl + "/api/alert-performance/report?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGeneratePerformanceReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGeneratePerformanceReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AlertPerformanceReportDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AlertPerformanceReportDtoApiResponse>;
        }));
    }

    protected processGeneratePerformanceReport(response: HttpResponseBase): Observable<AlertPerformanceReportDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AlertPerformanceReportDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return OK
     */
    getNotificationChannelStats(startDate: Date | undefined, endDate: Date | undefined): Observable<StringNotificationChannelStatsDtoDictionaryApiResponse> {
        let url_ = this.baseUrl + "/api/alert-performance/notification-channels?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNotificationChannelStats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNotificationChannelStats(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StringNotificationChannelStatsDtoDictionaryApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StringNotificationChannelStatsDtoDictionaryApiResponse>;
        }));
    }

    protected processGetNotificationChannelStats(response: HttpResponseBase): Observable<StringNotificationChannelStatsDtoDictionaryApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringNotificationChannelStatsDtoDictionaryApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    recordSystemEvent(body: SystemEventRequestDto | undefined): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/api/alert-performance/system-event";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRecordSystemEvent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRecordSystemEvent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processRecordSystemEvent(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createAlert(body: CreateAlertRuleDto | undefined): Observable<AlertRuleDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Alerts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateAlert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateAlert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AlertRuleDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AlertRuleDtoApiResponse>;
        }));
    }

    protected processCreateAlert(response: HttpResponseBase): Observable<AlertRuleDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AlertRuleDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getUserAlerts(): Observable<AlertRuleDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Alerts";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserAlerts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserAlerts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AlertRuleDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AlertRuleDtoIEnumerableApiResponse>;
        }));
    }

    protected processGetUserAlerts(response: HttpResponseBase): Observable<AlertRuleDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AlertRuleDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getProductAlerts(productId: string): Observable<AlertRuleDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Alerts/product/{productId}";
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductAlerts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductAlerts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AlertRuleDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AlertRuleDtoIEnumerableApiResponse>;
        }));
    }

    protected processGetProductAlerts(response: HttpResponseBase): Observable<AlertRuleDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AlertRuleDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    updateAlert(alertRuleId: string, body: UpdateAlertRuleDto | undefined): Observable<AlertRuleDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Alerts/{alertRuleId}";
        if (alertRuleId === undefined || alertRuleId === null)
            throw new Error("The parameter 'alertRuleId' must be defined.");
        url_ = url_.replace("{alertRuleId}", encodeURIComponent("" + alertRuleId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAlert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAlert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AlertRuleDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AlertRuleDtoApiResponse>;
        }));
    }

    protected processUpdateAlert(response: HttpResponseBase): Observable<AlertRuleDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AlertRuleDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    deleteAlert(alertRuleId: string): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/api/Alerts/{alertRuleId}";
        if (alertRuleId === undefined || alertRuleId === null)
            throw new Error("The parameter 'alertRuleId' must be defined.");
        url_ = url_.replace("{alertRuleId}", encodeURIComponent("" + alertRuleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAlert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAlert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processDeleteAlert(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param userId (optional) 
     * @param productId (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return OK
     */
    alertsAdminGetAll(userId: string | undefined, productId: string | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<AlertRuleDtoPagedResponse> {
        let url_ = this.baseUrl + "/api/Alerts/admin?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (productId === null)
            throw new Error("The parameter 'productId' cannot be null.");
        else if (productId !== undefined)
            url_ += "productId=" + encodeURIComponent("" + productId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAlertsAdminGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAlertsAdminGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AlertRuleDtoPagedResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AlertRuleDtoPagedResponse>;
        }));
    }

    protected processAlertsAdminGetAll(response: HttpResponseBase): Observable<AlertRuleDtoPagedResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AlertRuleDtoPagedResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getAlertById(alertRuleId: string): Observable<AlertRuleDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Alerts/admin/{alertRuleId}";
        if (alertRuleId === undefined || alertRuleId === null)
            throw new Error("The parameter 'alertRuleId' must be defined.");
        url_ = url_.replace("{alertRuleId}", encodeURIComponent("" + alertRuleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAlertById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAlertById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AlertRuleDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AlertRuleDtoApiResponse>;
        }));
    }

    protected processGetAlertById(response: HttpResponseBase): Observable<AlertRuleDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AlertRuleDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    adminUpdateAlert(alertRuleId: string, body: UpdateAlertRuleDto | undefined): Observable<AlertRuleDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Alerts/admin/{alertRuleId}";
        if (alertRuleId === undefined || alertRuleId === null)
            throw new Error("The parameter 'alertRuleId' must be defined.");
        url_ = url_.replace("{alertRuleId}", encodeURIComponent("" + alertRuleId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminUpdateAlert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminUpdateAlert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AlertRuleDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AlertRuleDtoApiResponse>;
        }));
    }

    protected processAdminUpdateAlert(response: HttpResponseBase): Observable<AlertRuleDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AlertRuleDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    adminDeleteAlert(alertRuleId: string): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/api/Alerts/admin/{alertRuleId}";
        if (alertRuleId === undefined || alertRuleId === null)
            throw new Error("The parameter 'alertRuleId' must be defined.");
        url_ = url_.replace("{alertRuleId}", encodeURIComponent("" + alertRuleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminDeleteAlert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminDeleteAlert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processAdminDeleteAlert(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    bulkOperation(body: AlertBulkOperationRequestDto | undefined): Observable<AlertBulkOperationResultDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Alerts/admin/bulk-operation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBulkOperation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBulkOperation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AlertBulkOperationResultDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AlertBulkOperationResultDtoApiResponse>;
        }));
    }

    protected processBulkOperation(response: HttpResponseBase): Observable<AlertBulkOperationResultDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AlertBulkOperationResultDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    bulkOperationWithFilters(body: AlertBulkOperationWithFiltersRequestDto | undefined): Observable<AlertBulkOperationResultDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Alerts/admin/bulk-operation-filtered";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBulkOperationWithFilters(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBulkOperationWithFilters(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AlertBulkOperationResultDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AlertBulkOperationResultDtoApiResponse>;
        }));
    }

    protected processBulkOperationWithFilters(response: HttpResponseBase): Observable<AlertBulkOperationResultDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AlertBulkOperationResultDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    previewBulkOperation(body: AlertBulkOperationWithFiltersRequestDto | undefined): Observable<AlertBulkOperationPreviewDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Alerts/admin/bulk-operation-preview";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPreviewBulkOperation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPreviewBulkOperation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AlertBulkOperationPreviewDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AlertBulkOperationPreviewDtoApiResponse>;
        }));
    }

    protected processPreviewBulkOperation(response: HttpResponseBase): Observable<AlertBulkOperationPreviewDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AlertBulkOperationPreviewDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    bulkEnable(body: string[] | undefined): Observable<AlertBulkOperationResultDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Alerts/bulk-enable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBulkEnable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBulkEnable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AlertBulkOperationResultDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AlertBulkOperationResultDtoApiResponse>;
        }));
    }

    protected processBulkEnable(response: HttpResponseBase): Observable<AlertBulkOperationResultDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AlertBulkOperationResultDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    bulkDisable(body: string[] | undefined): Observable<AlertBulkOperationResultDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Alerts/bulk-disable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBulkDisable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBulkDisable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AlertBulkOperationResultDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AlertBulkOperationResultDtoApiResponse>;
        }));
    }

    protected processBulkDisable(response: HttpResponseBase): Observable<AlertBulkOperationResultDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AlertBulkOperationResultDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    testAlertRule(alertRuleId: string, body: TestPricePointDto | undefined): Observable<AlertTestResultDtoApiResponse> {
        let url_ = this.baseUrl + "/api/alert-testing/{alertRuleId}/test-point";
        if (alertRuleId === undefined || alertRuleId === null)
            throw new Error("The parameter 'alertRuleId' must be defined.");
        url_ = url_.replace("{alertRuleId}", encodeURIComponent("" + alertRuleId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestAlertRule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestAlertRule(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AlertTestResultDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AlertTestResultDtoApiResponse>;
        }));
    }

    protected processTestAlertRule(response: HttpResponseBase): Observable<AlertTestResultDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AlertTestResultDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    testAlertRuleAgainstHistory(body: AlertTestRequestDto | undefined): Observable<AlertTestResultDtoApiResponse> {
        let url_ = this.baseUrl + "/api/alert-testing/test-history";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestAlertRuleAgainstHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestAlertRuleAgainstHistory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AlertTestResultDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AlertTestResultDtoApiResponse>;
        }));
    }

    protected processTestAlertRuleAgainstHistory(response: HttpResponseBase): Observable<AlertTestResultDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AlertTestResultDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    simulateAlertRule(body: AlertRuleSimulationRequestDto | undefined): Observable<AlertTestResultDtoApiResponse> {
        let url_ = this.baseUrl + "/api/alert-testing/simulate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSimulateAlertRule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSimulateAlertRule(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AlertTestResultDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AlertTestResultDtoApiResponse>;
        }));
    }

    protected processSimulateAlertRule(response: HttpResponseBase): Observable<AlertTestResultDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AlertTestResultDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return OK
     */
    getAlertRulePerformance2(alertRuleId: string, startDate: Date | undefined, endDate: Date | undefined): Observable<AlertPerformanceMetricsDtoApiResponse> {
        let url_ = this.baseUrl + "/api/alert-testing/{alertRuleId}/performance?";
        if (alertRuleId === undefined || alertRuleId === null)
            throw new Error("The parameter 'alertRuleId' must be defined.");
        url_ = url_.replace("{alertRuleId}", encodeURIComponent("" + alertRuleId));
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAlertRulePerformance2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAlertRulePerformance2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AlertPerformanceMetricsDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AlertPerformanceMetricsDtoApiResponse>;
        }));
    }

    protected processGetAlertRulePerformance2(response: HttpResponseBase): Observable<AlertPerformanceMetricsDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AlertPerformanceMetricsDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    validateAlertRule(body: TestAlertRuleDto | undefined): Observable<AlertRuleValidationResultDtoApiResponse> {
        let url_ = this.baseUrl + "/api/alert-testing/validate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidateAlertRule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidateAlertRule(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AlertRuleValidationResultDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AlertRuleValidationResultDtoApiResponse>;
        }));
    }

    protected processValidateAlertRule(response: HttpResponseBase): Observable<AlertRuleValidationResultDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AlertRuleValidationResultDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    testAllAlertRulesForProduct(productId: string, body: TestPricePointDto | undefined): Observable<AlertTestResultDtoListApiResponse> {
        let url_ = this.baseUrl + "/api/alert-testing/admin/test-all/{productId}";
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestAllAlertRulesForProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestAllAlertRulesForProduct(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AlertTestResultDtoListApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AlertTestResultDtoListApiResponse>;
        }));
    }

    protected processTestAllAlertRulesForProduct(response: HttpResponseBase): Observable<AlertTestResultDtoListApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AlertTestResultDtoListApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return OK
     */
    getAlertTestingStatistics(startDate: Date | undefined, endDate: Date | undefined): Observable<AlertTestingStatsDtoApiResponse> {
        let url_ = this.baseUrl + "/api/alert-testing/admin/statistics?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAlertTestingStatistics(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAlertTestingStatistics(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AlertTestingStatsDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AlertTestingStatsDtoApiResponse>;
        }));
    }

    protected processGetAlertTestingStatistics(response: HttpResponseBase): Observable<AlertTestingStatsDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AlertTestingStatsDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    register(body: RegisterUserDto | undefined): Observable<UserDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Auth/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDtoApiResponse>;
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<UserDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    login(body: LoginUserDto | undefined): Observable<LoginResponseDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Auth/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LoginResponseDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LoginResponseDtoApiResponse>;
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<LoginResponseDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoginResponseDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getCurrentUser(): Observable<UserDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Auth/me";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDtoApiResponse>;
        }));
    }

    protected processGetCurrentUser(response: HttpResponseBase): Observable<UserDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    startTestSession(body: BrowserAutomationTestRequestDto | undefined): Observable<BrowserTestSessionDtoApiResponse> {
        let url_ = this.baseUrl + "/api/browser-automation/test/start";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStartTestSession(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStartTestSession(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BrowserTestSessionDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BrowserTestSessionDtoApiResponse>;
        }));
    }

    protected processStartTestSession(response: HttpResponseBase): Observable<BrowserTestSessionDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BrowserTestSessionDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    stopTestSession(sessionId: string): Observable<BrowserAutomationTestResultDtoApiResponse> {
        let url_ = this.baseUrl + "/api/browser-automation/test/{sessionId}/stop";
        if (sessionId === undefined || sessionId === null)
            throw new Error("The parameter 'sessionId' must be defined.");
        url_ = url_.replace("{sessionId}", encodeURIComponent("" + sessionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStopTestSession(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStopTestSession(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BrowserAutomationTestResultDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BrowserAutomationTestResultDtoApiResponse>;
        }));
    }

    protected processStopTestSession(response: HttpResponseBase): Observable<BrowserAutomationTestResultDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BrowserAutomationTestResultDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getTestSessionStatus(sessionId: string): Observable<TestSessionStatusDtoApiResponse> {
        let url_ = this.baseUrl + "/api/browser-automation/test/{sessionId}/status";
        if (sessionId === undefined || sessionId === null)
            throw new Error("The parameter 'sessionId' must be defined.");
        url_ = url_.replace("{sessionId}", encodeURIComponent("" + sessionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTestSessionStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTestSessionStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TestSessionStatusDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TestSessionStatusDtoApiResponse>;
        }));
    }

    protected processGetTestSessionStatus(response: HttpResponseBase): Observable<TestSessionStatusDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TestSessionStatusDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getTestSessionResults(sessionId: string): Observable<BrowserAutomationTestResultDtoApiResponse> {
        let url_ = this.baseUrl + "/api/browser-automation/test/{sessionId}/results";
        if (sessionId === undefined || sessionId === null)
            throw new Error("The parameter 'sessionId' must be defined.");
        url_ = url_.replace("{sessionId}", encodeURIComponent("" + sessionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTestSessionResults(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTestSessionResults(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BrowserAutomationTestResultDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BrowserAutomationTestResultDtoApiResponse>;
        }));
    }

    protected processGetTestSessionResults(response: HttpResponseBase): Observable<BrowserAutomationTestResultDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BrowserAutomationTestResultDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getTestSessionScreenshot(sessionId: string): Observable<StringApiResponse> {
        let url_ = this.baseUrl + "/api/browser-automation/test/{sessionId}/screenshot";
        if (sessionId === undefined || sessionId === null)
            throw new Error("The parameter 'sessionId' must be defined.");
        url_ = url_.replace("{sessionId}", encodeURIComponent("" + sessionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTestSessionScreenshot(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTestSessionScreenshot(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StringApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StringApiResponse>;
        }));
    }

    protected processGetTestSessionScreenshot(response: HttpResponseBase): Observable<StringApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getTestSessionScreenshotImage(sessionId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/browser-automation/test/{sessionId}/screenshot/image";
        if (sessionId === undefined || sessionId === null)
            throw new Error("The parameter 'sessionId' must be defined.");
        url_ = url_.replace("{sessionId}", encodeURIComponent("" + sessionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTestSessionScreenshotImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTestSessionScreenshotImage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetTestSessionScreenshotImage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getActiveTestSessions(): Observable<BrowserTestSessionDtoListApiResponse> {
        let url_ = this.baseUrl + "/api/browser-automation/test/sessions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActiveTestSessions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActiveTestSessions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BrowserTestSessionDtoListApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BrowserTestSessionDtoListApiResponse>;
        }));
    }

    protected processGetActiveTestSessions(response: HttpResponseBase): Observable<BrowserTestSessionDtoListApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BrowserTestSessionDtoListApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    validateProfile(body: ProfileValidationRequestDto | undefined): Observable<ProfileValidationResultDtoApiResponse> {
        let url_ = this.baseUrl + "/api/browser-automation/test/validate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidateProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidateProfile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProfileValidationResultDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProfileValidationResultDtoApiResponse>;
        }));
    }

    protected processValidateProfile(response: HttpResponseBase): Observable<ProfileValidationResultDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProfileValidationResultDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createCategory(body: CreateCategoryDto | undefined): Observable<CategoryDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Categories";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateCategory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CategoryDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CategoryDtoApiResponse>;
        }));
    }

    protected processCreateCategory(response: HttpResponseBase): Observable<CategoryDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CategoryDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getCategories(): Observable<CategoryDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Categories";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCategories(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CategoryDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CategoryDtoIEnumerableApiResponse>;
        }));
    }

    protected processGetCategories(response: HttpResponseBase): Observable<CategoryDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CategoryDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getCategoryByIdOrSlug(categoryIdOrSlug: string): Observable<CategoryDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Categories/{categoryIdOrSlug}";
        if (categoryIdOrSlug === undefined || categoryIdOrSlug === null)
            throw new Error("The parameter 'categoryIdOrSlug' must be defined.");
        url_ = url_.replace("{categoryIdOrSlug}", encodeURIComponent("" + categoryIdOrSlug));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCategoryByIdOrSlug(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCategoryByIdOrSlug(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CategoryDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CategoryDtoApiResponse>;
        }));
    }

    protected processGetCategoryByIdOrSlug(response: HttpResponseBase): Observable<CategoryDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CategoryDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    updateCategory(categoryId: string, body: UpdateCategoryDto | undefined): Observable<CategoryDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Categories/{categoryId}";
        if (categoryId === undefined || categoryId === null)
            throw new Error("The parameter 'categoryId' must be defined.");
        url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCategory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CategoryDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CategoryDtoApiResponse>;
        }));
    }

    protected processUpdateCategory(response: HttpResponseBase): Observable<CategoryDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CategoryDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    deleteCategory(categoryId: string): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/api/Categories/{categoryId}";
        if (categoryId === undefined || categoryId === null)
            throw new Error("The parameter 'categoryId' must be defined.");
        url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCategory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processDeleteCategory(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getDashboardStats(): Observable<DashboardStatsDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Dashboard/stats";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDashboardStats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDashboardStats(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DashboardStatsDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DashboardStatsDtoApiResponse>;
        }));
    }

    protected processGetDashboardStats(response: HttpResponseBase): Observable<DashboardStatsDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DashboardStatsDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getSuccessExample(): Observable<ObjectApiResponse> {
        let url_ = this.baseUrl + "/api/Example/success";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSuccessExample(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSuccessExample(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResponse>;
        }));
    }

    protected processGetSuccessExample(response: HttpResponseBase): Observable<ObjectApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param skip (optional) 
     * @param take (optional) 
     * @return OK
     */
    getPaginatedExample(pageNumber: number | undefined, pageSize: number | undefined, skip: number | undefined, take: number | undefined): Observable<ObjectPagedResponse> {
        let url_ = this.baseUrl + "/api/Example/paginated?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaginatedExample(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaginatedExample(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectPagedResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectPagedResponse>;
        }));
    }

    protected processGetPaginatedExample(response: HttpResponseBase): Observable<ObjectPagedResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectPagedResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getResultExample(id: number): Observable<ObjectApiResponse> {
        let url_ = this.baseUrl + "/api/Example/result/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetResultExample(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetResultExample(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResponse>;
        }));
    }

    protected processGetResultExample(response: HttpResponseBase): Observable<ObjectApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getErrorExample(type: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Example/error/{type}";
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined.");
        url_ = url_.replace("{type}", encodeURIComponent("" + type));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetErrorExample(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetErrorExample(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetErrorExample(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    validateExample(body: ValidationExampleRequest | undefined): Observable<StringApiResponse> {
        let url_ = this.baseUrl + "/api/Example/validate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidateExample(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidateExample(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StringApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StringApiResponse>;
        }));
    }

    protected processValidateExample(response: HttpResponseBase): Observable<StringApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    utilitiesExample(body: UtilitiesExampleRequest | undefined): Observable<ObjectApiResponse> {
        let url_ = this.baseUrl + "/api/Example/utilities";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUtilitiesExample(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUtilitiesExample(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResponse>;
        }));
    }

    protected processUtilitiesExample(response: HttpResponseBase): Observable<ObjectApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createMapping(body: CreateProductSellerMappingDto | undefined): Observable<ProductSellerMappingDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Mappings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateMapping(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateMapping(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductSellerMappingDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductSellerMappingDtoApiResponse>;
        }));
    }

    protected processCreateMapping(response: HttpResponseBase): Observable<ProductSellerMappingDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductSellerMappingDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param canonicalProductId (optional) 
     * @param isActiveForScraping (optional) 
     * @return OK
     */
    getMappings(canonicalProductId: string | undefined, isActiveForScraping: boolean | undefined): Observable<ProductSellerMappingDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Mappings?";
        if (canonicalProductId === null)
            throw new Error("The parameter 'canonicalProductId' cannot be null.");
        else if (canonicalProductId !== undefined)
            url_ += "canonicalProductId=" + encodeURIComponent("" + canonicalProductId) + "&";
        if (isActiveForScraping === null)
            throw new Error("The parameter 'isActiveForScraping' cannot be null.");
        else if (isActiveForScraping !== undefined)
            url_ += "isActiveForScraping=" + encodeURIComponent("" + isActiveForScraping) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMappings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMappings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductSellerMappingDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductSellerMappingDtoIEnumerableApiResponse>;
        }));
    }

    protected processGetMappings(response: HttpResponseBase): Observable<ProductSellerMappingDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductSellerMappingDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getActiveMappings(): Observable<ProductSellerMappingDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Mappings/active";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActiveMappings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActiveMappings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductSellerMappingDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductSellerMappingDtoIEnumerableApiResponse>;
        }));
    }

    protected processGetActiveMappings(response: HttpResponseBase): Observable<ProductSellerMappingDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductSellerMappingDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    updateMapping(mappingId: string, body: UpdateProductSellerMappingDto | undefined): Observable<ProductSellerMappingDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Mappings/{mappingId}";
        if (mappingId === undefined || mappingId === null)
            throw new Error("The parameter 'mappingId' must be defined.");
        url_ = url_.replace("{mappingId}", encodeURIComponent("" + mappingId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateMapping(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMapping(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductSellerMappingDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductSellerMappingDtoApiResponse>;
        }));
    }

    protected processUpdateMapping(response: HttpResponseBase): Observable<ProductSellerMappingDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductSellerMappingDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    deleteMapping(mappingId: string): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/api/Mappings/{mappingId}";
        if (mappingId === undefined || mappingId === null)
            throw new Error("The parameter 'mappingId' must be defined.");
        url_ = url_.replace("{mappingId}", encodeURIComponent("" + mappingId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteMapping(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMapping(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processDeleteMapping(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    triggerManualScraping(mappingId: string): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/api/Mappings/{mappingId}/scrape-now";
        if (mappingId === undefined || mappingId === null)
            throw new Error("The parameter 'mappingId' must be defined.");
        url_ = url_.replace("{mappingId}", encodeURIComponent("" + mappingId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTriggerManualScraping(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTriggerManualScraping(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processTriggerManualScraping(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getNotificationPreferences(): Observable<UserNotificationPreferencesDtoApiResponse> {
        let url_ = this.baseUrl + "/api/NotificationPreferences";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNotificationPreferences(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNotificationPreferences(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserNotificationPreferencesDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserNotificationPreferencesDtoApiResponse>;
        }));
    }

    protected processGetNotificationPreferences(response: HttpResponseBase): Observable<UserNotificationPreferencesDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserNotificationPreferencesDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    updateNotificationPreferences(body: UpdateUserNotificationPreferencesDto | undefined): Observable<UserNotificationPreferencesDtoApiResponse> {
        let url_ = this.baseUrl + "/api/NotificationPreferences";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateNotificationPreferences(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateNotificationPreferences(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserNotificationPreferencesDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserNotificationPreferencesDtoApiResponse>;
        }));
    }

    protected processUpdateNotificationPreferences(response: HttpResponseBase): Observable<UserNotificationPreferencesDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserNotificationPreferencesDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getAvailableProductsForNotification(): Observable<NotificationProductSelectionDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/NotificationPreferences/products";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAvailableProductsForNotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAvailableProductsForNotification(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NotificationProductSelectionDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NotificationProductSelectionDtoIEnumerableApiResponse>;
        }));
    }

    protected processGetAvailableProductsForNotification(response: HttpResponseBase): Observable<NotificationProductSelectionDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NotificationProductSelectionDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    testDiscordWebhook(body: TestDiscordWebhookDto | undefined): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/api/NotificationPreferences/test-webhook";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestDiscordWebhook(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestDiscordWebhook(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processTestDiscordWebhook(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getNotificationPreferencesSummary(): Observable<NotificationPreferencesSummaryDtoApiResponse> {
        let url_ = this.baseUrl + "/api/NotificationPreferences/summary";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNotificationPreferencesSummary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNotificationPreferencesSummary(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NotificationPreferencesSummaryDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NotificationPreferencesSummaryDtoApiResponse>;
        }));
    }

    protected processGetNotificationPreferencesSummary(response: HttpResponseBase): Observable<NotificationPreferencesSummaryDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NotificationPreferencesSummaryDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getAllPermissions(): Observable<PermissionDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Permission";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPermissions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PermissionDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PermissionDtoIEnumerableApiResponse>;
        }));
    }

    protected processGetAllPermissions(response: HttpResponseBase): Observable<PermissionDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermissionDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createPermission(body: CreatePermissionDto | undefined): Observable<PermissionDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Permission";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePermission(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePermission(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PermissionDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PermissionDtoApiResponse>;
        }));
    }

    protected processCreatePermission(response: HttpResponseBase): Observable<PermissionDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermissionDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getPermissionsByCategory(category: string): Observable<PermissionDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Permission/category/{category}";
        if (category === undefined || category === null)
            throw new Error("The parameter 'category' must be defined.");
        url_ = url_.replace("{category}", encodeURIComponent("" + category));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPermissionsByCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPermissionsByCategory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PermissionDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PermissionDtoIEnumerableApiResponse>;
        }));
    }

    protected processGetPermissionsByCategory(response: HttpResponseBase): Observable<PermissionDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermissionDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getPermissionById(id: string): Observable<PermissionDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Permission/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPermissionById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPermissionById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PermissionDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PermissionDtoApiResponse>;
        }));
    }

    protected processGetPermissionById(response: HttpResponseBase): Observable<PermissionDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermissionDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    updatePermission(id: string, body: UpdatePermissionDto | undefined): Observable<PermissionDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Permission/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePermission(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePermission(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PermissionDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PermissionDtoApiResponse>;
        }));
    }

    protected processUpdatePermission(response: HttpResponseBase): Observable<PermissionDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermissionDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    deletePermission(id: string): Observable<BooleanApiResponse> {
        let url_ = this.baseUrl + "/api/Permission/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePermission(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePermission(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponse>;
        }));
    }

    protected processDeletePermission(response: HttpResponseBase): Observable<BooleanApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getRolePermissions(roleId: string): Observable<PermissionDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Permission/role/{roleId}";
        if (roleId === undefined || roleId === null)
            throw new Error("The parameter 'roleId' must be defined.");
        url_ = url_.replace("{roleId}", encodeURIComponent("" + roleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRolePermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRolePermissions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PermissionDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PermissionDtoIEnumerableApiResponse>;
        }));
    }

    protected processGetRolePermissions(response: HttpResponseBase): Observable<PermissionDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermissionDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getRolePermissionsByName(roleName: string): Observable<PermissionDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Permission/role/name/{roleName}";
        if (roleName === undefined || roleName === null)
            throw new Error("The parameter 'roleName' must be defined.");
        url_ = url_.replace("{roleName}", encodeURIComponent("" + roleName));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRolePermissionsByName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRolePermissionsByName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PermissionDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PermissionDtoIEnumerableApiResponse>;
        }));
    }

    protected processGetRolePermissionsByName(response: HttpResponseBase): Observable<PermissionDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermissionDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    assignPermissionToRole(roleId: string, permissionId: string): Observable<BooleanApiResponse> {
        let url_ = this.baseUrl + "/api/Permission/role/{roleId}/permission/{permissionId}";
        if (roleId === undefined || roleId === null)
            throw new Error("The parameter 'roleId' must be defined.");
        url_ = url_.replace("{roleId}", encodeURIComponent("" + roleId));
        if (permissionId === undefined || permissionId === null)
            throw new Error("The parameter 'permissionId' must be defined.");
        url_ = url_.replace("{permissionId}", encodeURIComponent("" + permissionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssignPermissionToRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssignPermissionToRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponse>;
        }));
    }

    protected processAssignPermissionToRole(response: HttpResponseBase): Observable<BooleanApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    removePermissionFromRole(roleId: string, permissionId: string): Observable<BooleanApiResponse> {
        let url_ = this.baseUrl + "/api/Permission/role/{roleId}/permission/{permissionId}";
        if (roleId === undefined || roleId === null)
            throw new Error("The parameter 'roleId' must be defined.");
        url_ = url_.replace("{roleId}", encodeURIComponent("" + roleId));
        if (permissionId === undefined || permissionId === null)
            throw new Error("The parameter 'permissionId' must be defined.");
        url_ = url_.replace("{permissionId}", encodeURIComponent("" + permissionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemovePermissionFromRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemovePermissionFromRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponse>;
        }));
    }

    protected processRemovePermissionFromRole(response: HttpResponseBase): Observable<BooleanApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getUserPermissions(userId: string): Observable<PermissionDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Permission/user/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserPermissions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PermissionDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PermissionDtoIEnumerableApiResponse>;
        }));
    }

    protected processGetUserPermissions(response: HttpResponseBase): Observable<PermissionDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermissionDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    checkUserPermission(userId: string, permissionName: string): Observable<BooleanApiResponse> {
        let url_ = this.baseUrl + "/api/Permission/user/{userId}/check/{permissionName}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (permissionName === undefined || permissionName === null)
            throw new Error("The parameter 'permissionName' must be defined.");
        url_ = url_.replace("{permissionName}", encodeURIComponent("" + permissionName));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckUserPermission(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckUserPermission(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponse>;
        }));
    }

    protected processCheckUserPermission(response: HttpResponseBase): Observable<BooleanApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    bulkAssignPermissionsToRole(roleId: string, body: string[] | undefined): Observable<BooleanApiResponse> {
        let url_ = this.baseUrl + "/api/Permission/role/{roleId}/permissions/bulk";
        if (roleId === undefined || roleId === null)
            throw new Error("The parameter 'roleId' must be defined.");
        url_ = url_.replace("{roleId}", encodeURIComponent("" + roleId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBulkAssignPermissionsToRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBulkAssignPermissionsToRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponse>;
        }));
    }

    protected processBulkAssignPermissionsToRole(response: HttpResponseBase): Observable<BooleanApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getPermissionCategories(): Observable<StringStringArrayDictionaryApiResponse> {
        let url_ = this.baseUrl + "/api/Permission/categories";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPermissionCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPermissionCategories(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StringStringArrayDictionaryApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StringStringArrayDictionaryApiResponse>;
        }));
    }

    protected processGetPermissionCategories(response: HttpResponseBase): Observable<StringStringArrayDictionaryApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringStringArrayDictionaryApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    assignPermissionToUser(userId: string, permissionId: string): Observable<BooleanApiResponse> {
        let url_ = this.baseUrl + "/api/Permission/user/{userId}/permission/{permissionId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (permissionId === undefined || permissionId === null)
            throw new Error("The parameter 'permissionId' must be defined.");
        url_ = url_.replace("{permissionId}", encodeURIComponent("" + permissionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssignPermissionToUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssignPermissionToUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponse>;
        }));
    }

    protected processAssignPermissionToUser(response: HttpResponseBase): Observable<BooleanApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    removePermissionFromUser(userId: string, permissionId: string): Observable<BooleanApiResponse> {
        let url_ = this.baseUrl + "/api/Permission/user/{userId}/permission/{permissionId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (permissionId === undefined || permissionId === null)
            throw new Error("The parameter 'permissionId' must be defined.");
        url_ = url_.replace("{permissionId}", encodeURIComponent("" + permissionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemovePermissionFromUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemovePermissionFromUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponse>;
        }));
    }

    protected processRemovePermissionFromUser(response: HttpResponseBase): Observable<BooleanApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    bulkAssignPermissionsToUser(userId: string, body: string[] | undefined): Observable<BooleanApiResponse> {
        let url_ = this.baseUrl + "/api/Permission/user/{userId}/permissions/bulk";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBulkAssignPermissionsToUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBulkAssignPermissionsToUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponse>;
        }));
    }

    protected processBulkAssignPermissionsToUser(response: HttpResponseBase): Observable<BooleanApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getAssignablePermissions(): Observable<PermissionDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Permission/assignable";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssignablePermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssignablePermissions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PermissionDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PermissionDtoIEnumerableApiResponse>;
        }));
    }

    protected processGetAssignablePermissions(response: HttpResponseBase): Observable<PermissionDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermissionDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    compareProducts(body: CompareProductsRequestDto | undefined): Observable<ProductComparisonResultDtoApiResponse> {
        let url_ = this.baseUrl + "/api/product-comparison/compare";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCompareProducts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCompareProducts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductComparisonResultDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductComparisonResultDtoApiResponse>;
        }));
    }

    protected processCompareProducts(response: HttpResponseBase): Observable<ProductComparisonResultDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductComparisonResultDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ApiResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ApiResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = ApiResponse.fromJS(resultData422);
            return throwException("Unprocessable Content", status, _responseText, _headers, result422);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    validateProductsForComparison(productId1: string, productId2: string): Observable<BooleanApiResponse> {
        let url_ = this.baseUrl + "/api/product-comparison/validate?";
        if (productId1 === undefined || productId1 === null)
            throw new Error("The parameter 'productId1' must be defined and cannot be null.");
        else
            url_ += "productId1=" + encodeURIComponent("" + productId1) + "&";
        if (productId2 === undefined || productId2 === null)
            throw new Error("The parameter 'productId2' must be defined and cannot be null.");
        else
            url_ += "productId2=" + encodeURIComponent("" + productId2) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidateProductsForComparison(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidateProductsForComparison(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponse>;
        }));
    }

    protected processValidateProductsForComparison(response: HttpResponseBase): Observable<BooleanApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ApiResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ApiResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param search (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return OK
     */
    getComparableProducts(id: string, search: string | undefined, page: number | undefined, pageSize: number | undefined): Observable<ProductDtoPagedResponseApiResponse> {
        let url_ = this.baseUrl + "/api/product-comparison/comparable-products/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetComparableProducts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetComparableProducts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductDtoPagedResponseApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductDtoPagedResponseApiResponse>;
        }));
    }

    protected processGetComparableProducts(response: HttpResponseBase): Observable<ProductDtoPagedResponseApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductDtoPagedResponseApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ApiResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ApiResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createProduct(body: CreateProductDto | undefined): Observable<ProductDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Products";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateProduct(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductDtoApiResponse>;
        }));
    }

    protected processCreateProduct(response: HttpResponseBase): Observable<ProductDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param categoryId (optional) 
     * @param search (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return OK
     */
    getProducts(categoryId: string | undefined, search: string | undefined, page: number | undefined, pageSize: number | undefined): Observable<ProductDtoPagedResponse> {
        let url_ = this.baseUrl + "/api/Products?";
        if (categoryId === null)
            throw new Error("The parameter 'categoryId' cannot be null.");
        else if (categoryId !== undefined)
            url_ += "categoryId=" + encodeURIComponent("" + categoryId) + "&";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProducts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProducts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductDtoPagedResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductDtoPagedResponse>;
        }));
    }

    protected processGetProducts(response: HttpResponseBase): Observable<ProductDtoPagedResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductDtoPagedResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getProductById(productId: string): Observable<ProductDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Products/{productId}";
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductDtoApiResponse>;
        }));
    }

    protected processGetProductById(response: HttpResponseBase): Observable<ProductDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    updateProduct(productId: string, body: UpdateProductDto | undefined): Observable<ProductDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Products/{productId}";
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateProduct(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductDtoApiResponse>;
        }));
    }

    protected processUpdateProduct(response: HttpResponseBase): Observable<ProductDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    deleteProduct(productId: string): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/api/Products/{productId}";
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteProduct(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processDeleteProduct(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param sellerName (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param limit (optional) 
     * @return OK
     */
    getPriceHistory(productId: string, sellerName: string | undefined, startDate: Date | undefined, endDate: Date | undefined, limit: number | undefined): Observable<PriceHistoryDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Products/{productId}/price-history?";
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        if (sellerName === null)
            throw new Error("The parameter 'sellerName' cannot be null.");
        else if (sellerName !== undefined)
            url_ += "sellerName=" + encodeURIComponent("" + sellerName) + "&";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPriceHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPriceHistory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PriceHistoryDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PriceHistoryDtoIEnumerableApiResponse>;
        }));
    }

    protected processGetPriceHistory(response: HttpResponseBase): Observable<PriceHistoryDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PriceHistoryDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getCurrentPrices(productId: string): Observable<CurrentPriceDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Products/{productId}/current-prices";
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentPrices(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentPrices(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CurrentPriceDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CurrentPriceDtoIEnumerableApiResponse>;
        }));
    }

    protected processGetCurrentPrices(response: HttpResponseBase): Observable<CurrentPriceDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CurrentPriceDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param categoryId (optional) 
     * @param search (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return OK
     */
    getProductsCatalog(categoryId: string | undefined, search: string | undefined, page: number | undefined, pageSize: number | undefined): Observable<ProductWithCurrentPricesDtoPagedResponse> {
        let url_ = this.baseUrl + "/api/Products/catalog?";
        if (categoryId === null)
            throw new Error("The parameter 'categoryId' cannot be null.");
        else if (categoryId !== undefined)
            url_ += "categoryId=" + encodeURIComponent("" + categoryId) + "&";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductsCatalog(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductsCatalog(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductWithCurrentPricesDtoPagedResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductWithCurrentPricesDtoPagedResponse>;
        }));
    }

    protected processGetProductsCatalog(response: HttpResponseBase): Observable<ProductWithCurrentPricesDtoPagedResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductWithCurrentPricesDtoPagedResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getProductCatalogDetail(productId: string): Observable<ProductWithCurrentPricesDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Products/catalog/{productId}";
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductCatalogDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductCatalogDetail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductWithCurrentPricesDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductWithCurrentPricesDtoApiResponse>;
        }));
    }

    protected processGetProductCatalogDetail(response: HttpResponseBase): Observable<ProductWithCurrentPricesDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductWithCurrentPricesDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getAllProxies(): Observable<ProxyConfigurationDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/proxies";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProxies(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProxies(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProxyConfigurationDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProxyConfigurationDtoIEnumerableApiResponse>;
        }));
    }

    protected processGetAllProxies(response: HttpResponseBase): Observable<ProxyConfigurationDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProxyConfigurationDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createProxy(body: CreateProxyConfigurationDto | undefined): Observable<ProxyConfigurationDtoApiResponse> {
        let url_ = this.baseUrl + "/api/proxies";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateProxy(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateProxy(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProxyConfigurationDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProxyConfigurationDtoApiResponse>;
        }));
    }

    protected processCreateProxy(response: HttpResponseBase): Observable<ProxyConfigurationDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProxyConfigurationDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getProxyById(id: string): Observable<ProxyConfigurationDtoApiResponse> {
        let url_ = this.baseUrl + "/api/proxies/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProxyById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProxyById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProxyConfigurationDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProxyConfigurationDtoApiResponse>;
        }));
    }

    protected processGetProxyById(response: HttpResponseBase): Observable<ProxyConfigurationDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProxyConfigurationDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    updateProxy(id: string, body: UpdateProxyConfigurationDto | undefined): Observable<ProxyConfigurationDtoApiResponse> {
        let url_ = this.baseUrl + "/api/proxies/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateProxy(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateProxy(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProxyConfigurationDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProxyConfigurationDtoApiResponse>;
        }));
    }

    protected processUpdateProxy(response: HttpResponseBase): Observable<ProxyConfigurationDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProxyConfigurationDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    deleteProxy(id: string): Observable<BooleanApiResponse> {
        let url_ = this.baseUrl + "/api/proxies/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteProxy(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteProxy(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponse>;
        }));
    }

    protected processDeleteProxy(response: HttpResponseBase): Observable<BooleanApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getActiveProxies(): Observable<ProxyConfigurationDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/proxies/active";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActiveProxies(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActiveProxies(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProxyConfigurationDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProxyConfigurationDtoIEnumerableApiResponse>;
        }));
    }

    protected processGetActiveProxies(response: HttpResponseBase): Observable<ProxyConfigurationDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProxyConfigurationDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getHealthyProxies(): Observable<ProxyConfigurationDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/proxies/healthy";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHealthyProxies(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHealthyProxies(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProxyConfigurationDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProxyConfigurationDtoIEnumerableApiResponse>;
        }));
    }

    protected processGetHealthyProxies(response: HttpResponseBase): Observable<ProxyConfigurationDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProxyConfigurationDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getProxiesByType(proxyType: string): Observable<ProxyConfigurationDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/proxies/by-type/{proxyType}";
        if (proxyType === undefined || proxyType === null)
            throw new Error("The parameter 'proxyType' must be defined.");
        url_ = url_.replace("{proxyType}", encodeURIComponent("" + proxyType));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProxiesByType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProxiesByType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProxyConfigurationDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProxyConfigurationDtoIEnumerableApiResponse>;
        }));
    }

    protected processGetProxiesByType(response: HttpResponseBase): Observable<ProxyConfigurationDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProxyConfigurationDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param testUrl (optional) 
     * @param timeoutSeconds (optional) 
     * @return OK
     */
    testProxy(id: string, testUrl: string | undefined, timeoutSeconds: number | undefined): Observable<ProxyTestResultDtoApiResponse> {
        let url_ = this.baseUrl + "/api/proxies/{id}/test?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (testUrl === null)
            throw new Error("The parameter 'testUrl' cannot be null.");
        else if (testUrl !== undefined)
            url_ += "testUrl=" + encodeURIComponent("" + testUrl) + "&";
        if (timeoutSeconds === null)
            throw new Error("The parameter 'timeoutSeconds' cannot be null.");
        else if (timeoutSeconds !== undefined)
            url_ += "timeoutSeconds=" + encodeURIComponent("" + timeoutSeconds) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestProxy(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestProxy(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProxyTestResultDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProxyTestResultDtoApiResponse>;
        }));
    }

    protected processTestProxy(response: HttpResponseBase): Observable<ProxyTestResultDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProxyTestResultDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    bulkTestProxies(body: BulkProxyTestDto | undefined): Observable<ProxyTestResultDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/proxies/test-bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBulkTestProxies(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBulkTestProxies(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProxyTestResultDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProxyTestResultDtoIEnumerableApiResponse>;
        }));
    }

    protected processBulkTestProxies(response: HttpResponseBase): Observable<ProxyTestResultDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProxyTestResultDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param testUrl (optional) 
     * @param timeoutSeconds (optional) 
     * @param body (optional) 
     * @return OK
     */
    testProxyConfiguration(testUrl: string | undefined, timeoutSeconds: number | undefined, body: CreateProxyConfigurationDto | undefined): Observable<ProxyTestResultDtoApiResponse> {
        let url_ = this.baseUrl + "/api/proxies/test-configuration?";
        if (testUrl === null)
            throw new Error("The parameter 'testUrl' cannot be null.");
        else if (testUrl !== undefined)
            url_ += "testUrl=" + encodeURIComponent("" + testUrl) + "&";
        if (timeoutSeconds === null)
            throw new Error("The parameter 'timeoutSeconds' cannot be null.");
        else if (timeoutSeconds !== undefined)
            url_ += "timeoutSeconds=" + encodeURIComponent("" + timeoutSeconds) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestProxyConfiguration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestProxyConfiguration(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProxyTestResultDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProxyTestResultDtoApiResponse>;
        }));
    }

    protected processTestProxyConfiguration(response: HttpResponseBase): Observable<ProxyTestResultDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProxyTestResultDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    validateProxyImport(body: BulkProxyImportDto | undefined): Observable<BulkProxyImportValidationDtoApiResponse> {
        let url_ = this.baseUrl + "/api/proxies/validate-import";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidateProxyImport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidateProxyImport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BulkProxyImportValidationDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BulkProxyImportValidationDtoApiResponse>;
        }));
    }

    protected processValidateProxyImport(response: HttpResponseBase): Observable<BulkProxyImportValidationDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BulkProxyImportValidationDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    bulkImportProxies(body: BulkProxyImportDto | undefined): Observable<BulkProxyImportResultDtoApiResponse> {
        let url_ = this.baseUrl + "/api/proxies/import-bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBulkImportProxies(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBulkImportProxies(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BulkProxyImportResultDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BulkProxyImportResultDtoApiResponse>;
        }));
    }

    protected processBulkImportProxies(response: HttpResponseBase): Observable<BulkProxyImportResultDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BulkProxyImportResultDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    parseProxyText(body: ProxyTextParseDto | undefined): Observable<ProxyImportItemDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/proxies/parse-text";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processParseProxyText(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processParseProxyText(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProxyImportItemDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProxyImportItemDtoIEnumerableApiResponse>;
        }));
    }

    protected processParseProxyText(response: HttpResponseBase): Observable<ProxyImportItemDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProxyImportItemDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getProxyStats(): Observable<ProxyStatsDtoApiResponse> {
        let url_ = this.baseUrl + "/api/proxies/stats";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProxyStats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProxyStats(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProxyStatsDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProxyStatsDtoApiResponse>;
        }));
    }

    protected processGetProxyStats(response: HttpResponseBase): Observable<ProxyStatsDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProxyStatsDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    setProxyActiveStatus(id: string, body: boolean | undefined): Observable<BooleanApiResponse> {
        let url_ = this.baseUrl + "/api/proxies/{id}/active";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetProxyActiveStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetProxyActiveStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponse>;
        }));
    }

    protected processSetProxyActiveStatus(response: HttpResponseBase): Observable<BooleanApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    bulkSetProxyActiveStatus(body: BulkProxyActiveStatusDto | undefined): Observable<BooleanApiResponse> {
        let url_ = this.baseUrl + "/api/proxies/bulk-active";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBulkSetProxyActiveStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBulkSetProxyActiveStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponse>;
        }));
    }

    protected processBulkSetProxyActiveStatus(response: HttpResponseBase): Observable<BooleanApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    updateProxyUsage(body: ProxyUsageUpdateDto | undefined): Observable<BooleanApiResponse> {
        let url_ = this.baseUrl + "/api/proxies/usage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateProxyUsage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateProxyUsage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponse>;
        }));
    }

    protected processUpdateProxyUsage(response: HttpResponseBase): Observable<BooleanApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getAllRoles(): Observable<RoleInfoDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Roles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleInfoDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleInfoDtoIEnumerableApiResponse>;
        }));
    }

    protected processGetAllRoles(response: HttpResponseBase): Observable<RoleInfoDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleInfoDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createRole(body: CreateRoleDto | undefined): Observable<RoleInfoDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Roles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleInfoDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleInfoDtoApiResponse>;
        }));
    }

    protected processCreateRole(response: HttpResponseBase): Observable<RoleInfoDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleInfoDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getRoleById(roleId: string): Observable<RoleInfoDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Roles/{roleId}";
        if (roleId === undefined || roleId === null)
            throw new Error("The parameter 'roleId' must be defined.");
        url_ = url_.replace("{roleId}", encodeURIComponent("" + roleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoleById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoleById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleInfoDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleInfoDtoApiResponse>;
        }));
    }

    protected processGetRoleById(response: HttpResponseBase): Observable<RoleInfoDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleInfoDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    deleteRole(roleId: string): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/api/Roles/{roleId}";
        if (roleId === undefined || roleId === null)
            throw new Error("The parameter 'roleId' must be defined.");
        url_ = url_.replace("{roleId}", encodeURIComponent("" + roleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processDeleteRole(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getUsersInRole(roleName: string): Observable<UserRoleInfoDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Roles/{roleName}/users";
        if (roleName === undefined || roleName === null)
            throw new Error("The parameter 'roleName' must be defined.");
        url_ = url_.replace("{roleName}", encodeURIComponent("" + roleName));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsersInRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsersInRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserRoleInfoDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserRoleInfoDtoIEnumerableApiResponse>;
        }));
    }

    protected processGetUsersInRole(response: HttpResponseBase): Observable<UserRoleInfoDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserRoleInfoDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getPublicData(): Observable<ObjectApiResponse> {
        let url_ = this.baseUrl + "/api/Sample/public";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPublicData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPublicData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResponse>;
        }));
    }

    protected processGetPublicData(response: HttpResponseBase): Observable<ObjectApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getData(): Observable<ObjectApiResponse> {
        let url_ = this.baseUrl + "/api/Sample/data";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResponse>;
        }));
    }

    protected processGetData(response: HttpResponseBase): Observable<ObjectApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createData(body: any | undefined): Observable<ObjectApiResponse> {
        let url_ = this.baseUrl + "/api/Sample/data";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResponse>;
        }));
    }

    protected processCreateData(response: HttpResponseBase): Observable<ObjectApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getAdminData(): Observable<ObjectApiResponse> {
        let url_ = this.baseUrl + "/api/Sample/admin";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAdminData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAdminData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResponse>;
        }));
    }

    protected processGetAdminData(response: HttpResponseBase): Observable<ObjectApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getUserData(userId: string): Observable<ObjectApiResponse> {
        let url_ = this.baseUrl + "/api/Sample/users/{userId}/data";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResponse>;
        }));
    }

    protected processGetUserData(response: HttpResponseBase): Observable<ObjectApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getInternalData(): Observable<ObjectApiResponse> {
        let url_ = this.baseUrl + "/api/Sample/internal";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInternalData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInternalData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResponse>;
        }));
    }

    protected processGetInternalData(response: HttpResponseBase): Observable<ObjectApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getCustomData(): Observable<ObjectApiResponse> {
        let url_ = this.baseUrl + "/api/Sample/custom";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResponse>;
        }));
    }

    protected processGetCustomData(response: HttpResponseBase): Observable<ObjectApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getDataWithManualAuth(): Observable<ObjectApiResponse> {
        let url_ = this.baseUrl + "/api/Sample/manual-auth";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDataWithManualAuth(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDataWithManualAuth(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResponse>;
        }));
    }

    protected processGetDataWithManualAuth(response: HttpResponseBase): Observable<ObjectApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @param mappingId (optional) 
     * @param status (optional) 
     * @param errorCategory (optional) 
     * @param dateFrom (optional) 
     * @param dateTo (optional) 
     * @param sellerName (optional) 
     * @return OK
     */
    getScraperLogs(page: number | undefined, pageSize: number | undefined, mappingId: string | undefined, status: string | undefined, errorCategory: string | undefined, dateFrom: Date | undefined, dateTo: Date | undefined, sellerName: string | undefined): Observable<ScraperRunLogSummaryDtoPagedResultDtoApiResponse> {
        let url_ = this.baseUrl + "/api/scraper-logs?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (mappingId === null)
            throw new Error("The parameter 'mappingId' cannot be null.");
        else if (mappingId !== undefined)
            url_ += "mappingId=" + encodeURIComponent("" + mappingId) + "&";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        if (errorCategory === null)
            throw new Error("The parameter 'errorCategory' cannot be null.");
        else if (errorCategory !== undefined)
            url_ += "errorCategory=" + encodeURIComponent("" + errorCategory) + "&";
        if (dateFrom === null)
            throw new Error("The parameter 'dateFrom' cannot be null.");
        else if (dateFrom !== undefined)
            url_ += "dateFrom=" + encodeURIComponent(dateFrom ? "" + dateFrom.toISOString() : "") + "&";
        if (dateTo === null)
            throw new Error("The parameter 'dateTo' cannot be null.");
        else if (dateTo !== undefined)
            url_ += "dateTo=" + encodeURIComponent(dateTo ? "" + dateTo.toISOString() : "") + "&";
        if (sellerName === null)
            throw new Error("The parameter 'sellerName' cannot be null.");
        else if (sellerName !== undefined)
            url_ += "sellerName=" + encodeURIComponent("" + sellerName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetScraperLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetScraperLogs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ScraperRunLogSummaryDtoPagedResultDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ScraperRunLogSummaryDtoPagedResultDtoApiResponse>;
        }));
    }

    protected processGetScraperLogs(response: HttpResponseBase): Observable<ScraperRunLogSummaryDtoPagedResultDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ScraperRunLogSummaryDtoPagedResultDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getScraperRunById(runId: string): Observable<ScraperRunLogDtoApiResponse> {
        let url_ = this.baseUrl + "/api/scraper-logs/{runId}";
        if (runId === undefined || runId === null)
            throw new Error("The parameter 'runId' must be defined.");
        url_ = url_.replace("{runId}", encodeURIComponent("" + runId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetScraperRunById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetScraperRunById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ScraperRunLogDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ScraperRunLogDtoApiResponse>;
        }));
    }

    protected processGetScraperRunById(response: HttpResponseBase): Observable<ScraperRunLogDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ScraperRunLogDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return OK
     */
    getScraperLogsByMapping(mappingId: string, page: number | undefined, pageSize: number | undefined): Observable<ScraperRunLogSummaryDtoPagedResultDtoApiResponse> {
        let url_ = this.baseUrl + "/api/scraper-logs/mapping/{mappingId}?";
        if (mappingId === undefined || mappingId === null)
            throw new Error("The parameter 'mappingId' must be defined.");
        url_ = url_.replace("{mappingId}", encodeURIComponent("" + mappingId));
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetScraperLogsByMapping(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetScraperLogsByMapping(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ScraperRunLogSummaryDtoPagedResultDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ScraperRunLogSummaryDtoPagedResultDtoApiResponse>;
        }));
    }

    protected processGetScraperLogsByMapping(response: HttpResponseBase): Observable<ScraperRunLogSummaryDtoPagedResultDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ScraperRunLogSummaryDtoPagedResultDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param count (optional) 
     * @return OK
     */
    getRecentFailures(count: number | undefined): Observable<ScraperRunLogSummaryDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/scraper-logs/recent-failures?";
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecentFailures(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecentFailures(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ScraperRunLogSummaryDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ScraperRunLogSummaryDtoIEnumerableApiResponse>;
        }));
    }

    protected processGetRecentFailures(response: HttpResponseBase): Observable<ScraperRunLogSummaryDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ScraperRunLogSummaryDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param count (optional) 
     * @return OK
     */
    getRecentRunsForMapping(mappingId: string, count: number | undefined): Observable<ScraperRunLogSummaryDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/scraper-logs/mapping/{mappingId}/recent?";
        if (mappingId === undefined || mappingId === null)
            throw new Error("The parameter 'mappingId' must be defined.");
        url_ = url_.replace("{mappingId}", encodeURIComponent("" + mappingId));
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecentRunsForMapping(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecentRunsForMapping(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ScraperRunLogSummaryDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ScraperRunLogSummaryDtoIEnumerableApiResponse>;
        }));
    }

    protected processGetRecentRunsForMapping(response: HttpResponseBase): Observable<ScraperRunLogSummaryDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ScraperRunLogSummaryDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param dateFrom (optional) 
     * @param dateTo (optional) 
     * @param mappingId (optional) 
     * @return OK
     */
    getStatistics(dateFrom: Date | undefined, dateTo: Date | undefined, mappingId: string | undefined): Observable<ScraperRunStatisticsDtoApiResponse> {
        let url_ = this.baseUrl + "/api/scraper-logs/statistics?";
        if (dateFrom === null)
            throw new Error("The parameter 'dateFrom' cannot be null.");
        else if (dateFrom !== undefined)
            url_ += "dateFrom=" + encodeURIComponent(dateFrom ? "" + dateFrom.toISOString() : "") + "&";
        if (dateTo === null)
            throw new Error("The parameter 'dateTo' cannot be null.");
        else if (dateTo !== undefined)
            url_ += "dateTo=" + encodeURIComponent(dateTo ? "" + dateTo.toISOString() : "") + "&";
        if (mappingId === null)
            throw new Error("The parameter 'mappingId' cannot be null.");
        else if (mappingId !== undefined)
            url_ += "mappingId=" + encodeURIComponent("" + mappingId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStatistics(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStatistics(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ScraperRunStatisticsDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ScraperRunStatisticsDtoApiResponse>;
        }));
    }

    protected processGetStatistics(response: HttpResponseBase): Observable<ScraperRunStatisticsDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ScraperRunStatisticsDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getRetryChain(runId: string): Observable<ScraperRunLogDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/scraper-logs/{runId}/retry-chain";
        if (runId === undefined || runId === null)
            throw new Error("The parameter 'runId' must be defined.");
        url_ = url_.replace("{runId}", encodeURIComponent("" + runId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRetryChain(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRetryChain(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ScraperRunLogDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ScraperRunLogDtoIEnumerableApiResponse>;
        }));
    }

    protected processGetRetryChain(response: HttpResponseBase): Observable<ScraperRunLogDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ScraperRunLogDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param dateFrom (optional) 
     * @param dateTo (optional) 
     * @return OK
     */
    getPerformanceMetrics(dateFrom: Date | undefined, dateTo: Date | undefined): Observable<SellerPerformanceMetricDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/scraper-logs/performance-metrics?";
        if (dateFrom === null)
            throw new Error("The parameter 'dateFrom' cannot be null.");
        else if (dateFrom !== undefined)
            url_ += "dateFrom=" + encodeURIComponent(dateFrom ? "" + dateFrom.toISOString() : "") + "&";
        if (dateTo === null)
            throw new Error("The parameter 'dateTo' cannot be null.");
        else if (dateTo !== undefined)
            url_ += "dateTo=" + encodeURIComponent(dateTo ? "" + dateTo.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPerformanceMetrics(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPerformanceMetrics(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SellerPerformanceMetricDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SellerPerformanceMetricDtoIEnumerableApiResponse>;
        }));
    }

    protected processGetPerformanceMetrics(response: HttpResponseBase): Observable<SellerPerformanceMetricDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SellerPerformanceMetricDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getInProgressRuns(): Observable<ScraperRunLogSummaryDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/scraper-logs/in-progress";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInProgressRuns(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInProgressRuns(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ScraperRunLogSummaryDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ScraperRunLogSummaryDtoIEnumerableApiResponse>;
        }));
    }

    protected processGetInProgressRuns(response: HttpResponseBase): Observable<ScraperRunLogSummaryDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ScraperRunLogSummaryDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param daysToKeep (optional) 
     * @return OK
     */
    cleanupOldLogs(daysToKeep: number | undefined): Observable<Int32ApiResponse> {
        let url_ = this.baseUrl + "/api/scraper-logs/cleanup?";
        if (daysToKeep === null)
            throw new Error("The parameter 'daysToKeep' cannot be null.");
        else if (daysToKeep !== undefined)
            url_ += "daysToKeep=" + encodeURIComponent("" + daysToKeep) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCleanupOldLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCleanupOldLogs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Int32ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Int32ApiResponse>;
        }));
    }

    protected processCleanupOldLogs(response: HttpResponseBase): Observable<Int32ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Int32ApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getAllSiteConfigs(): Observable<ScraperSiteConfigurationDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/site-configs/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSiteConfigs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSiteConfigs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ScraperSiteConfigurationDtoIEnumerableApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ScraperSiteConfigurationDtoIEnumerableApiResponse>;
        }));
    }

    protected processGetAllSiteConfigs(response: HttpResponseBase): Observable<ScraperSiteConfigurationDtoIEnumerableApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ScraperSiteConfigurationDtoIEnumerableApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createSiteConfig(body: CreateScraperSiteConfigurationDto | undefined): Observable<ScraperSiteConfigurationDtoApiResponse> {
        let url_ = this.baseUrl + "/api/site-configs";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateSiteConfig(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateSiteConfig(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ScraperSiteConfigurationDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ScraperSiteConfigurationDtoApiResponse>;
        }));
    }

    protected processCreateSiteConfig(response: HttpResponseBase): Observable<ScraperSiteConfigurationDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ScraperSiteConfigurationDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param domain (optional) 
     * @return OK
     */
    getSiteConfigByDomain(domain: string | undefined): Observable<ScraperSiteConfigurationDtoApiResponse> {
        let url_ = this.baseUrl + "/api/site-configs?";
        if (domain === null)
            throw new Error("The parameter 'domain' cannot be null.");
        else if (domain !== undefined)
            url_ += "domain=" + encodeURIComponent("" + domain) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSiteConfigByDomain(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSiteConfigByDomain(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ScraperSiteConfigurationDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ScraperSiteConfigurationDtoApiResponse>;
        }));
    }

    protected processGetSiteConfigByDomain(response: HttpResponseBase): Observable<ScraperSiteConfigurationDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ScraperSiteConfigurationDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getSiteConfig(siteConfigId: string): Observable<ScraperSiteConfigurationDtoApiResponse> {
        let url_ = this.baseUrl + "/api/site-configs/{siteConfigId}";
        if (siteConfigId === undefined || siteConfigId === null)
            throw new Error("The parameter 'siteConfigId' must be defined.");
        url_ = url_.replace("{siteConfigId}", encodeURIComponent("" + siteConfigId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSiteConfig(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSiteConfig(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ScraperSiteConfigurationDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ScraperSiteConfigurationDtoApiResponse>;
        }));
    }

    protected processGetSiteConfig(response: HttpResponseBase): Observable<ScraperSiteConfigurationDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ScraperSiteConfigurationDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    updateSiteConfig(siteConfigId: string, body: UpdateScraperSiteConfigurationDto | undefined): Observable<ScraperSiteConfigurationDtoApiResponse> {
        let url_ = this.baseUrl + "/api/site-configs/{siteConfigId}";
        if (siteConfigId === undefined || siteConfigId === null)
            throw new Error("The parameter 'siteConfigId' must be defined.");
        url_ = url_.replace("{siteConfigId}", encodeURIComponent("" + siteConfigId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSiteConfig(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSiteConfig(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ScraperSiteConfigurationDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ScraperSiteConfigurationDtoApiResponse>;
        }));
    }

    protected processUpdateSiteConfig(response: HttpResponseBase): Observable<ScraperSiteConfigurationDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ScraperSiteConfigurationDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    deleteSiteConfig(siteConfigId: string): Observable<ApiResponse> {
        let url_ = this.baseUrl + "/api/site-configs/{siteConfigId}";
        if (siteConfigId === undefined || siteConfigId === null)
            throw new Error("The parameter 'siteConfigId' must be defined.");
        url_ = url_.replace("{siteConfigId}", encodeURIComponent("" + siteConfigId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteSiteConfig(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteSiteConfig(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResponse>;
        }));
    }

    protected processDeleteSiteConfig(response: HttpResponseBase): Observable<ApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    saveTestResults(sessionId: string, body: SaveTestResultRequestDto | undefined): Observable<StringApiResponse> {
        let url_ = this.baseUrl + "/api/test-results/sessions/{sessionId}/save";
        if (sessionId === undefined || sessionId === null)
            throw new Error("The parameter 'sessionId' must be defined.");
        url_ = url_.replace("{sessionId}", encodeURIComponent("" + sessionId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveTestResults(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveTestResults(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StringApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StringApiResponse>;
        }));
    }

    protected processSaveTestResults(response: HttpResponseBase): Observable<StringApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param searchTerm (optional) 
     * @param tags (optional) 
     * @return OK
     */
    getSavedTestResults(pageNumber: number | undefined, pageSize: number | undefined, searchTerm: string | undefined, tags: string | undefined): Observable<SavedTestResultDtoPagedResponse> {
        let url_ = this.baseUrl + "/api/test-results/saved?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (searchTerm === null)
            throw new Error("The parameter 'searchTerm' cannot be null.");
        else if (searchTerm !== undefined)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        if (tags === null)
            throw new Error("The parameter 'tags' cannot be null.");
        else if (tags !== undefined)
            url_ += "tags=" + encodeURIComponent("" + tags) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSavedTestResults(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSavedTestResults(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SavedTestResultDtoPagedResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SavedTestResultDtoPagedResponse>;
        }));
    }

    protected processGetSavedTestResults(response: HttpResponseBase): Observable<SavedTestResultDtoPagedResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SavedTestResultDtoPagedResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getSavedTestResult(savedResultId: string): Observable<SavedTestResultDetailDtoApiResponse> {
        let url_ = this.baseUrl + "/api/test-results/saved/{savedResultId}";
        if (savedResultId === undefined || savedResultId === null)
            throw new Error("The parameter 'savedResultId' must be defined.");
        url_ = url_.replace("{savedResultId}", encodeURIComponent("" + savedResultId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSavedTestResult(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSavedTestResult(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SavedTestResultDetailDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SavedTestResultDetailDtoApiResponse>;
        }));
    }

    protected processGetSavedTestResult(response: HttpResponseBase): Observable<SavedTestResultDetailDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SavedTestResultDetailDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    deleteSavedTestResult(savedResultId: string): Observable<BooleanApiResponse> {
        let url_ = this.baseUrl + "/api/test-results/saved/{savedResultId}";
        if (savedResultId === undefined || savedResultId === null)
            throw new Error("The parameter 'savedResultId' must be defined.");
        url_ = url_.replace("{savedResultId}", encodeURIComponent("" + savedResultId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteSavedTestResult(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteSavedTestResult(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanApiResponse>;
        }));
    }

    protected processDeleteSavedTestResult(response: HttpResponseBase): Observable<BooleanApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    compareTestResults(body: CompareTestResultsRequestDto | undefined): Observable<TestResultComparisonDtoApiResponse> {
        let url_ = this.baseUrl + "/api/test-results/compare";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCompareTestResults(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCompareTestResults(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TestResultComparisonDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TestResultComparisonDtoApiResponse>;
        }));
    }

    protected processCompareTestResults(response: HttpResponseBase): Observable<TestResultComparisonDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TestResultComparisonDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param profileId (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @return OK
     */
    getTestExecutionTrends(profileId: string | undefined, fromDate: Date | undefined, toDate: Date | undefined): Observable<TestExecutionTrendsDtoApiResponse> {
        let url_ = this.baseUrl + "/api/test-results/trends?";
        if (profileId === null)
            throw new Error("The parameter 'profileId' cannot be null.");
        else if (profileId !== undefined)
            url_ += "profileId=" + encodeURIComponent("" + profileId) + "&";
        if (fromDate === null)
            throw new Error("The parameter 'fromDate' cannot be null.");
        else if (fromDate !== undefined)
            url_ += "fromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toISOString() : "") + "&";
        if (toDate === null)
            throw new Error("The parameter 'toDate' cannot be null.");
        else if (toDate !== undefined)
            url_ += "toDate=" + encodeURIComponent(toDate ? "" + toDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTestExecutionTrends(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTestExecutionTrends(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TestExecutionTrendsDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TestExecutionTrendsDtoApiResponse>;
        }));
    }

    protected processGetTestExecutionTrends(response: HttpResponseBase): Observable<TestExecutionTrendsDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TestExecutionTrendsDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param format (optional) 
     * @return OK
     */
    exportTestResult(savedResultId: string, format: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/test-results/saved/{savedResultId}/export?";
        if (savedResultId === undefined || savedResultId === null)
            throw new Error("The parameter 'savedResultId' must be defined.");
        url_ = url_.replace("{savedResultId}", encodeURIComponent("" + savedResultId));
        if (format === null)
            throw new Error("The parameter 'format' cannot be null.");
        else if (format !== undefined)
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportTestResult(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportTestResult(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processExportTestResult(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param testUrl (optional) 
     * @param profileHash (optional) 
     * @param limit (optional) 
     * @return OK
     */
    getTestHistory(testUrl: string | undefined, profileHash: string | undefined, limit: number | undefined): Observable<TestHistoryEntryDtoListApiResponse> {
        let url_ = this.baseUrl + "/api/test-results/history?";
        if (testUrl === null)
            throw new Error("The parameter 'testUrl' cannot be null.");
        else if (testUrl !== undefined)
            url_ += "testUrl=" + encodeURIComponent("" + testUrl) + "&";
        if (profileHash === null)
            throw new Error("The parameter 'profileHash' cannot be null.");
        else if (profileHash !== undefined)
            url_ += "profileHash=" + encodeURIComponent("" + profileHash) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTestHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTestHistory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TestHistoryEntryDtoListApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TestHistoryEntryDtoListApiResponse>;
        }));
    }

    protected processGetTestHistory(response: HttpResponseBase): Observable<TestHistoryEntryDtoListApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TestHistoryEntryDtoListApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getAvailableTags(): Observable<StringListApiResponse> {
        let url_ = this.baseUrl + "/api/test-results/tags";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAvailableTags(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAvailableTags(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StringListApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StringListApiResponse>;
        }));
    }

    protected processGetAvailableTags(response: HttpResponseBase): Observable<StringListApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringListApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getTestStatistics(): Observable<TestStatisticsApiResponse> {
        let url_ = this.baseUrl + "/api/test-results/statistics";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTestStatistics(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTestStatistics(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TestStatisticsApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TestStatisticsApiResponse>;
        }));
    }

    protected processGetTestStatistics(response: HttpResponseBase): Observable<TestStatisticsApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TestStatisticsApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    bulkDeleteSavedTestResults(body: BulkDeleteTestResultsRequestDto | undefined): Observable<BulkDeleteResultDtoApiResponse> {
        let url_ = this.baseUrl + "/api/test-results/saved/bulk-delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBulkDeleteSavedTestResults(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBulkDeleteSavedTestResults(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BulkDeleteResultDtoApiResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BulkDeleteResultDtoApiResponse>;
        }));
    }

    protected processBulkDeleteSavedTestResults(response: HttpResponseBase): Observable<BulkDeleteResultDtoApiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BulkDeleteResultDtoApiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class ActionExecutionResultDto implements IActionExecutionResultDto {
    actionIndex?: number;
    actionType?: string | undefined;
    selector?: string | undefined;
    value?: string | undefined;
    success?: boolean;
    duration?: number;
    screenshot?: string | undefined;
    error?: string | undefined;
    retryCount?: number;

    constructor(data?: IActionExecutionResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.actionIndex = _data["actionIndex"];
            this.actionType = _data["actionType"];
            this.selector = _data["selector"];
            this.value = _data["value"];
            this.success = _data["success"];
            this.duration = _data["duration"];
            this.screenshot = _data["screenshot"];
            this.error = _data["error"];
            this.retryCount = _data["retryCount"];
        }
    }

    static fromJS(data: any): ActionExecutionResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActionExecutionResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["actionIndex"] = this.actionIndex;
        data["actionType"] = this.actionType;
        data["selector"] = this.selector;
        data["value"] = this.value;
        data["success"] = this.success;
        data["duration"] = this.duration;
        data["screenshot"] = this.screenshot;
        data["error"] = this.error;
        data["retryCount"] = this.retryCount;
        return data;
    }
}

export interface IActionExecutionResultDto {
    actionIndex?: number;
    actionType?: string | undefined;
    selector?: string | undefined;
    value?: string | undefined;
    success?: boolean;
    duration?: number;
    screenshot?: string | undefined;
    error?: string | undefined;
    retryCount?: number;
}

export class AiConfigurationDto implements IAiConfigurationDto {
    aiConfigurationId?: string;
    provider?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    openApiCompatibleUrl?: string | undefined;
    model?: string | undefined;
    inputTokenLimit?: number | undefined;
    outputTokenLimit?: number | undefined;
    capabilities?: string[] | undefined;
    supportedInputTypes?: string[] | undefined;
    supportedOutputTypes?: string[] | undefined;
    rateLimitRpm?: number | undefined;
    rateLimitTpm?: number | undefined;
    rateLimitRpd?: number | undefined;
    isActive?: boolean;
    isDefault?: boolean;
    createdAt?: Date;
    updatedAt?: Date;
    createdBy?: string;
    updatedBy?: string;

    constructor(data?: IAiConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.aiConfigurationId = _data["aiConfigurationId"];
            this.provider = _data["provider"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.openApiCompatibleUrl = _data["openApiCompatibleUrl"];
            this.model = _data["model"];
            this.inputTokenLimit = _data["inputTokenLimit"];
            this.outputTokenLimit = _data["outputTokenLimit"];
            if (Array.isArray(_data["capabilities"])) {
                this.capabilities = [] as any;
                for (let item of _data["capabilities"])
                    this.capabilities!.push(item);
            }
            if (Array.isArray(_data["supportedInputTypes"])) {
                this.supportedInputTypes = [] as any;
                for (let item of _data["supportedInputTypes"])
                    this.supportedInputTypes!.push(item);
            }
            if (Array.isArray(_data["supportedOutputTypes"])) {
                this.supportedOutputTypes = [] as any;
                for (let item of _data["supportedOutputTypes"])
                    this.supportedOutputTypes!.push(item);
            }
            this.rateLimitRpm = _data["rateLimitRpm"];
            this.rateLimitTpm = _data["rateLimitTpm"];
            this.rateLimitRpd = _data["rateLimitRpd"];
            this.isActive = _data["isActive"];
            this.isDefault = _data["isDefault"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.updatedBy = _data["updatedBy"];
        }
    }

    static fromJS(data: any): AiConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new AiConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["aiConfigurationId"] = this.aiConfigurationId;
        data["provider"] = this.provider;
        data["name"] = this.name;
        data["description"] = this.description;
        data["openApiCompatibleUrl"] = this.openApiCompatibleUrl;
        data["model"] = this.model;
        data["inputTokenLimit"] = this.inputTokenLimit;
        data["outputTokenLimit"] = this.outputTokenLimit;
        if (Array.isArray(this.capabilities)) {
            data["capabilities"] = [];
            for (let item of this.capabilities)
                data["capabilities"].push(item);
        }
        if (Array.isArray(this.supportedInputTypes)) {
            data["supportedInputTypes"] = [];
            for (let item of this.supportedInputTypes)
                data["supportedInputTypes"].push(item);
        }
        if (Array.isArray(this.supportedOutputTypes)) {
            data["supportedOutputTypes"] = [];
            for (let item of this.supportedOutputTypes)
                data["supportedOutputTypes"].push(item);
        }
        data["rateLimitRpm"] = this.rateLimitRpm;
        data["rateLimitTpm"] = this.rateLimitTpm;
        data["rateLimitRpd"] = this.rateLimitRpd;
        data["isActive"] = this.isActive;
        data["isDefault"] = this.isDefault;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["updatedBy"] = this.updatedBy;
        return data;
    }
}

export interface IAiConfigurationDto {
    aiConfigurationId?: string;
    provider?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    openApiCompatibleUrl?: string | undefined;
    model?: string | undefined;
    inputTokenLimit?: number | undefined;
    outputTokenLimit?: number | undefined;
    capabilities?: string[] | undefined;
    supportedInputTypes?: string[] | undefined;
    supportedOutputTypes?: string[] | undefined;
    rateLimitRpm?: number | undefined;
    rateLimitTpm?: number | undefined;
    rateLimitRpd?: number | undefined;
    isActive?: boolean;
    isDefault?: boolean;
    createdAt?: Date;
    updatedAt?: Date;
    createdBy?: string;
    updatedBy?: string;
}

export class AiConfigurationDtoApiResponse implements IAiConfigurationDtoApiResponse {
    success?: boolean;
    data?: AiConfigurationDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IAiConfigurationDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"] ? AiConfigurationDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): AiConfigurationDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AiConfigurationDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IAiConfigurationDtoApiResponse {
    success?: boolean;
    data?: AiConfigurationDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class AiConfigurationDtoIEnumerableApiResponse implements IAiConfigurationDtoIEnumerableApiResponse {
    success?: boolean;
    data?: AiConfigurationDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IAiConfigurationDtoIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(AiConfigurationDto.fromJS(item));
            }
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): AiConfigurationDtoIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AiConfigurationDtoIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : <any>undefined);
        }
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IAiConfigurationDtoIEnumerableApiResponse {
    success?: boolean;
    data?: AiConfigurationDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class AiProviderModelsDto implements IAiProviderModelsDto {
    models?: string[] | undefined;
    success?: boolean;
    errorMessage?: string | undefined;

    constructor(data?: IAiProviderModelsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["models"])) {
                this.models = [] as any;
                for (let item of _data["models"])
                    this.models!.push(item);
            }
            this.success = _data["success"];
            this.errorMessage = _data["errorMessage"];
        }
    }

    static fromJS(data: any): AiProviderModelsDto {
        data = typeof data === 'object' ? data : {};
        let result = new AiProviderModelsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.models)) {
            data["models"] = [];
            for (let item of this.models)
                data["models"].push(item);
        }
        data["success"] = this.success;
        data["errorMessage"] = this.errorMessage;
        return data;
    }
}

export interface IAiProviderModelsDto {
    models?: string[] | undefined;
    success?: boolean;
    errorMessage?: string | undefined;
}

export class AiProviderModelsDtoApiResponse implements IAiProviderModelsDtoApiResponse {
    success?: boolean;
    data?: AiProviderModelsDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IAiProviderModelsDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"] ? AiProviderModelsDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): AiProviderModelsDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AiProviderModelsDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IAiProviderModelsDtoApiResponse {
    success?: boolean;
    data?: AiProviderModelsDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class AlertBulkFilterDto implements IAlertBulkFilterDto {
    userId?: string | undefined;
    productId?: string | undefined;
    conditionType?: string | undefined;
    alertType?: string | undefined;
    isActive?: boolean | undefined;
    createdAfter?: Date | undefined;
    createdBefore?: Date | undefined;
    lastNotifiedAfter?: Date | undefined;
    lastNotifiedBefore?: Date | undefined;
    minNotificationFrequency?: number | undefined;
    maxNotificationFrequency?: number | undefined;

    constructor(data?: IAlertBulkFilterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.productId = _data["productId"];
            this.conditionType = _data["conditionType"];
            this.alertType = _data["alertType"];
            this.isActive = _data["isActive"];
            this.createdAfter = _data["createdAfter"] ? new Date(_data["createdAfter"].toString()) : <any>undefined;
            this.createdBefore = _data["createdBefore"] ? new Date(_data["createdBefore"].toString()) : <any>undefined;
            this.lastNotifiedAfter = _data["lastNotifiedAfter"] ? new Date(_data["lastNotifiedAfter"].toString()) : <any>undefined;
            this.lastNotifiedBefore = _data["lastNotifiedBefore"] ? new Date(_data["lastNotifiedBefore"].toString()) : <any>undefined;
            this.minNotificationFrequency = _data["minNotificationFrequency"];
            this.maxNotificationFrequency = _data["maxNotificationFrequency"];
        }
    }

    static fromJS(data: any): AlertBulkFilterDto {
        data = typeof data === 'object' ? data : {};
        let result = new AlertBulkFilterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["productId"] = this.productId;
        data["conditionType"] = this.conditionType;
        data["alertType"] = this.alertType;
        data["isActive"] = this.isActive;
        data["createdAfter"] = this.createdAfter ? this.createdAfter.toISOString() : <any>undefined;
        data["createdBefore"] = this.createdBefore ? this.createdBefore.toISOString() : <any>undefined;
        data["lastNotifiedAfter"] = this.lastNotifiedAfter ? this.lastNotifiedAfter.toISOString() : <any>undefined;
        data["lastNotifiedBefore"] = this.lastNotifiedBefore ? this.lastNotifiedBefore.toISOString() : <any>undefined;
        data["minNotificationFrequency"] = this.minNotificationFrequency;
        data["maxNotificationFrequency"] = this.maxNotificationFrequency;
        return data;
    }
}

export interface IAlertBulkFilterDto {
    userId?: string | undefined;
    productId?: string | undefined;
    conditionType?: string | undefined;
    alertType?: string | undefined;
    isActive?: boolean | undefined;
    createdAfter?: Date | undefined;
    createdBefore?: Date | undefined;
    lastNotifiedAfter?: Date | undefined;
    lastNotifiedBefore?: Date | undefined;
    minNotificationFrequency?: number | undefined;
    maxNotificationFrequency?: number | undefined;
}

export class AlertBulkOperationItemResultDto implements IAlertBulkOperationItemResultDto {
    alertRuleId?: string;
    success?: boolean;
    errorMessage?: string | undefined;
    previousValue?: string | undefined;
    newValue?: string | undefined;

    constructor(data?: IAlertBulkOperationItemResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alertRuleId = _data["alertRuleId"];
            this.success = _data["success"];
            this.errorMessage = _data["errorMessage"];
            this.previousValue = _data["previousValue"];
            this.newValue = _data["newValue"];
        }
    }

    static fromJS(data: any): AlertBulkOperationItemResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new AlertBulkOperationItemResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["alertRuleId"] = this.alertRuleId;
        data["success"] = this.success;
        data["errorMessage"] = this.errorMessage;
        data["previousValue"] = this.previousValue;
        data["newValue"] = this.newValue;
        return data;
    }
}

export interface IAlertBulkOperationItemResultDto {
    alertRuleId?: string;
    success?: boolean;
    errorMessage?: string | undefined;
    previousValue?: string | undefined;
    newValue?: string | undefined;
}

export class AlertBulkOperationPreviewDto implements IAlertBulkOperationPreviewDto {
    filters?: AlertBulkFilterDto;
    operation?: string | undefined;
    totalMatchingRules?: number;
    rulesWouldBeAffected?: number;
    sampleAffectedRules?: AlertRuleDto[] | undefined;
    warnings?: string[] | undefined;
    isSafeToExecute?: boolean;
    safetyMessage?: string | undefined;

    constructor(data?: IAlertBulkOperationPreviewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.filters = _data["filters"] ? AlertBulkFilterDto.fromJS(_data["filters"]) : <any>undefined;
            this.operation = _data["operation"];
            this.totalMatchingRules = _data["totalMatchingRules"];
            this.rulesWouldBeAffected = _data["rulesWouldBeAffected"];
            if (Array.isArray(_data["sampleAffectedRules"])) {
                this.sampleAffectedRules = [] as any;
                for (let item of _data["sampleAffectedRules"])
                    this.sampleAffectedRules!.push(AlertRuleDto.fromJS(item));
            }
            if (Array.isArray(_data["warnings"])) {
                this.warnings = [] as any;
                for (let item of _data["warnings"])
                    this.warnings!.push(item);
            }
            this.isSafeToExecute = _data["isSafeToExecute"];
            this.safetyMessage = _data["safetyMessage"];
        }
    }

    static fromJS(data: any): AlertBulkOperationPreviewDto {
        data = typeof data === 'object' ? data : {};
        let result = new AlertBulkOperationPreviewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filters"] = this.filters ? this.filters.toJSON() : <any>undefined;
        data["operation"] = this.operation;
        data["totalMatchingRules"] = this.totalMatchingRules;
        data["rulesWouldBeAffected"] = this.rulesWouldBeAffected;
        if (Array.isArray(this.sampleAffectedRules)) {
            data["sampleAffectedRules"] = [];
            for (let item of this.sampleAffectedRules)
                data["sampleAffectedRules"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.warnings)) {
            data["warnings"] = [];
            for (let item of this.warnings)
                data["warnings"].push(item);
        }
        data["isSafeToExecute"] = this.isSafeToExecute;
        data["safetyMessage"] = this.safetyMessage;
        return data;
    }
}

export interface IAlertBulkOperationPreviewDto {
    filters?: AlertBulkFilterDto;
    operation?: string | undefined;
    totalMatchingRules?: number;
    rulesWouldBeAffected?: number;
    sampleAffectedRules?: AlertRuleDto[] | undefined;
    warnings?: string[] | undefined;
    isSafeToExecute?: boolean;
    safetyMessage?: string | undefined;
}

export class AlertBulkOperationPreviewDtoApiResponse implements IAlertBulkOperationPreviewDtoApiResponse {
    success?: boolean;
    data?: AlertBulkOperationPreviewDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IAlertBulkOperationPreviewDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"] ? AlertBulkOperationPreviewDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): AlertBulkOperationPreviewDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AlertBulkOperationPreviewDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IAlertBulkOperationPreviewDtoApiResponse {
    success?: boolean;
    data?: AlertBulkOperationPreviewDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class AlertBulkOperationRequestDto implements IAlertBulkOperationRequestDto {
    alertRuleIds!: string[];
    operation!: string;
    newNotificationFrequencyMinutes?: number | undefined;
    newAlertType?: string | undefined;
    reason?: string | undefined;

    constructor(data?: IAlertBulkOperationRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.alertRuleIds = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["alertRuleIds"])) {
                this.alertRuleIds = [] as any;
                for (let item of _data["alertRuleIds"])
                    this.alertRuleIds!.push(item);
            }
            this.operation = _data["operation"];
            this.newNotificationFrequencyMinutes = _data["newNotificationFrequencyMinutes"];
            this.newAlertType = _data["newAlertType"];
            this.reason = _data["reason"];
        }
    }

    static fromJS(data: any): AlertBulkOperationRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new AlertBulkOperationRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.alertRuleIds)) {
            data["alertRuleIds"] = [];
            for (let item of this.alertRuleIds)
                data["alertRuleIds"].push(item);
        }
        data["operation"] = this.operation;
        data["newNotificationFrequencyMinutes"] = this.newNotificationFrequencyMinutes;
        data["newAlertType"] = this.newAlertType;
        data["reason"] = this.reason;
        return data;
    }
}

export interface IAlertBulkOperationRequestDto {
    alertRuleIds: string[];
    operation: string;
    newNotificationFrequencyMinutes?: number | undefined;
    newAlertType?: string | undefined;
    reason?: string | undefined;
}

export class AlertBulkOperationResultDto implements IAlertBulkOperationResultDto {
    operation?: string | undefined;
    totalRequested?: number;
    successfulOperations?: number;
    failedOperations?: number;
    results?: AlertBulkOperationItemResultDto[] | undefined;
    processedAt?: Date;
    reason?: string | undefined;

    constructor(data?: IAlertBulkOperationResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.operation = _data["operation"];
            this.totalRequested = _data["totalRequested"];
            this.successfulOperations = _data["successfulOperations"];
            this.failedOperations = _data["failedOperations"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(AlertBulkOperationItemResultDto.fromJS(item));
            }
            this.processedAt = _data["processedAt"] ? new Date(_data["processedAt"].toString()) : <any>undefined;
            this.reason = _data["reason"];
        }
    }

    static fromJS(data: any): AlertBulkOperationResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new AlertBulkOperationResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["operation"] = this.operation;
        data["totalRequested"] = this.totalRequested;
        data["successfulOperations"] = this.successfulOperations;
        data["failedOperations"] = this.failedOperations;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item ? item.toJSON() : <any>undefined);
        }
        data["processedAt"] = this.processedAt ? this.processedAt.toISOString() : <any>undefined;
        data["reason"] = this.reason;
        return data;
    }
}

export interface IAlertBulkOperationResultDto {
    operation?: string | undefined;
    totalRequested?: number;
    successfulOperations?: number;
    failedOperations?: number;
    results?: AlertBulkOperationItemResultDto[] | undefined;
    processedAt?: Date;
    reason?: string | undefined;
}

export class AlertBulkOperationResultDtoApiResponse implements IAlertBulkOperationResultDtoApiResponse {
    success?: boolean;
    data?: AlertBulkOperationResultDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IAlertBulkOperationResultDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"] ? AlertBulkOperationResultDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): AlertBulkOperationResultDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AlertBulkOperationResultDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IAlertBulkOperationResultDtoApiResponse {
    success?: boolean;
    data?: AlertBulkOperationResultDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class AlertBulkOperationWithFiltersRequestDto implements IAlertBulkOperationWithFiltersRequestDto {
    filters!: AlertBulkFilterDto;
    operation!: string;
    newNotificationFrequencyMinutes?: number | undefined;
    newAlertType?: string | undefined;
    reason?: string | undefined;
    maxAffectedRules?: number;
    previewOnly?: boolean;

    constructor(data?: IAlertBulkOperationWithFiltersRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.filters = new AlertBulkFilterDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.filters = _data["filters"] ? AlertBulkFilterDto.fromJS(_data["filters"]) : new AlertBulkFilterDto();
            this.operation = _data["operation"];
            this.newNotificationFrequencyMinutes = _data["newNotificationFrequencyMinutes"];
            this.newAlertType = _data["newAlertType"];
            this.reason = _data["reason"];
            this.maxAffectedRules = _data["maxAffectedRules"];
            this.previewOnly = _data["previewOnly"];
        }
    }

    static fromJS(data: any): AlertBulkOperationWithFiltersRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new AlertBulkOperationWithFiltersRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filters"] = this.filters ? this.filters.toJSON() : <any>undefined;
        data["operation"] = this.operation;
        data["newNotificationFrequencyMinutes"] = this.newNotificationFrequencyMinutes;
        data["newAlertType"] = this.newAlertType;
        data["reason"] = this.reason;
        data["maxAffectedRules"] = this.maxAffectedRules;
        data["previewOnly"] = this.previewOnly;
        return data;
    }
}

export interface IAlertBulkOperationWithFiltersRequestDto {
    filters: AlertBulkFilterDto;
    operation: string;
    newNotificationFrequencyMinutes?: number | undefined;
    newAlertType?: string | undefined;
    reason?: string | undefined;
    maxAffectedRules?: number;
    previewOnly?: boolean;
}

export class AlertEvaluationMetricsDto implements IAlertEvaluationMetricsDto {
    totalPricePointsProcessed?: number;
    totalAlertsEvaluated?: number;
    totalAlertsTriggered?: number;
    alertTriggerRate?: number;
    averageEvaluationTime?: string;
    maxEvaluationTime?: string;
    minEvaluationTime?: string;
    evaluationErrors?: number;
    errorRate?: number;
    triggersByConditionType?: { [key: string]: number; } | undefined;
    averageEvaluationTimeByCondition?: { [key: string]: string; } | undefined;

    constructor(data?: IAlertEvaluationMetricsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalPricePointsProcessed = _data["totalPricePointsProcessed"];
            this.totalAlertsEvaluated = _data["totalAlertsEvaluated"];
            this.totalAlertsTriggered = _data["totalAlertsTriggered"];
            this.alertTriggerRate = _data["alertTriggerRate"];
            this.averageEvaluationTime = _data["averageEvaluationTime"];
            this.maxEvaluationTime = _data["maxEvaluationTime"];
            this.minEvaluationTime = _data["minEvaluationTime"];
            this.evaluationErrors = _data["evaluationErrors"];
            this.errorRate = _data["errorRate"];
            if (_data["triggersByConditionType"]) {
                this.triggersByConditionType = {} as any;
                for (let key in _data["triggersByConditionType"]) {
                    if (_data["triggersByConditionType"].hasOwnProperty(key))
                        (<any>this.triggersByConditionType)![key] = _data["triggersByConditionType"][key];
                }
            }
            if (_data["averageEvaluationTimeByCondition"]) {
                this.averageEvaluationTimeByCondition = {} as any;
                for (let key in _data["averageEvaluationTimeByCondition"]) {
                    if (_data["averageEvaluationTimeByCondition"].hasOwnProperty(key))
                        (<any>this.averageEvaluationTimeByCondition)![key] = _data["averageEvaluationTimeByCondition"][key];
                }
            }
        }
    }

    static fromJS(data: any): AlertEvaluationMetricsDto {
        data = typeof data === 'object' ? data : {};
        let result = new AlertEvaluationMetricsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalPricePointsProcessed"] = this.totalPricePointsProcessed;
        data["totalAlertsEvaluated"] = this.totalAlertsEvaluated;
        data["totalAlertsTriggered"] = this.totalAlertsTriggered;
        data["alertTriggerRate"] = this.alertTriggerRate;
        data["averageEvaluationTime"] = this.averageEvaluationTime;
        data["maxEvaluationTime"] = this.maxEvaluationTime;
        data["minEvaluationTime"] = this.minEvaluationTime;
        data["evaluationErrors"] = this.evaluationErrors;
        data["errorRate"] = this.errorRate;
        if (this.triggersByConditionType) {
            data["triggersByConditionType"] = {};
            for (let key in this.triggersByConditionType) {
                if (this.triggersByConditionType.hasOwnProperty(key))
                    (<any>data["triggersByConditionType"])[key] = (<any>this.triggersByConditionType)[key];
            }
        }
        if (this.averageEvaluationTimeByCondition) {
            data["averageEvaluationTimeByCondition"] = {};
            for (let key in this.averageEvaluationTimeByCondition) {
                if (this.averageEvaluationTimeByCondition.hasOwnProperty(key))
                    (<any>data["averageEvaluationTimeByCondition"])[key] = (<any>this.averageEvaluationTimeByCondition)[key];
            }
        }
        return data;
    }
}

export interface IAlertEvaluationMetricsDto {
    totalPricePointsProcessed?: number;
    totalAlertsEvaluated?: number;
    totalAlertsTriggered?: number;
    alertTriggerRate?: number;
    averageEvaluationTime?: string;
    maxEvaluationTime?: string;
    minEvaluationTime?: string;
    evaluationErrors?: number;
    errorRate?: number;
    triggersByConditionType?: { [key: string]: number; } | undefined;
    averageEvaluationTimeByCondition?: { [key: string]: string; } | undefined;
}

export class AlertPerformanceMetricsDto implements IAlertPerformanceMetricsDto {
    alertRuleId?: string;
    ruleDescription?: string | undefined;
    analysisPeriodStart?: Date | undefined;
    analysisPeriodEnd?: Date | undefined;
    totalPricePointsAnalyzed?: number;
    timesWouldHaveTriggered?: number;
    triggerRate?: number;
    lowestTriggeringPrice?: number | undefined;
    highestTriggeringPrice?: number | undefined;
    averageTriggeringPrice?: number | undefined;
    recentTriggers?: AlertTestMatchDto[] | undefined;
    triggersByMonth?: { [key: string]: number; } | undefined;
    triggersBySeller?: { [key: string]: number; } | undefined;

    constructor(data?: IAlertPerformanceMetricsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alertRuleId = _data["alertRuleId"];
            this.ruleDescription = _data["ruleDescription"];
            this.analysisPeriodStart = _data["analysisPeriodStart"] ? new Date(_data["analysisPeriodStart"].toString()) : <any>undefined;
            this.analysisPeriodEnd = _data["analysisPeriodEnd"] ? new Date(_data["analysisPeriodEnd"].toString()) : <any>undefined;
            this.totalPricePointsAnalyzed = _data["totalPricePointsAnalyzed"];
            this.timesWouldHaveTriggered = _data["timesWouldHaveTriggered"];
            this.triggerRate = _data["triggerRate"];
            this.lowestTriggeringPrice = _data["lowestTriggeringPrice"];
            this.highestTriggeringPrice = _data["highestTriggeringPrice"];
            this.averageTriggeringPrice = _data["averageTriggeringPrice"];
            if (Array.isArray(_data["recentTriggers"])) {
                this.recentTriggers = [] as any;
                for (let item of _data["recentTriggers"])
                    this.recentTriggers!.push(AlertTestMatchDto.fromJS(item));
            }
            if (_data["triggersByMonth"]) {
                this.triggersByMonth = {} as any;
                for (let key in _data["triggersByMonth"]) {
                    if (_data["triggersByMonth"].hasOwnProperty(key))
                        (<any>this.triggersByMonth)![key] = _data["triggersByMonth"][key];
                }
            }
            if (_data["triggersBySeller"]) {
                this.triggersBySeller = {} as any;
                for (let key in _data["triggersBySeller"]) {
                    if (_data["triggersBySeller"].hasOwnProperty(key))
                        (<any>this.triggersBySeller)![key] = _data["triggersBySeller"][key];
                }
            }
        }
    }

    static fromJS(data: any): AlertPerformanceMetricsDto {
        data = typeof data === 'object' ? data : {};
        let result = new AlertPerformanceMetricsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["alertRuleId"] = this.alertRuleId;
        data["ruleDescription"] = this.ruleDescription;
        data["analysisPeriodStart"] = this.analysisPeriodStart ? this.analysisPeriodStart.toISOString() : <any>undefined;
        data["analysisPeriodEnd"] = this.analysisPeriodEnd ? this.analysisPeriodEnd.toISOString() : <any>undefined;
        data["totalPricePointsAnalyzed"] = this.totalPricePointsAnalyzed;
        data["timesWouldHaveTriggered"] = this.timesWouldHaveTriggered;
        data["triggerRate"] = this.triggerRate;
        data["lowestTriggeringPrice"] = this.lowestTriggeringPrice;
        data["highestTriggeringPrice"] = this.highestTriggeringPrice;
        data["averageTriggeringPrice"] = this.averageTriggeringPrice;
        if (Array.isArray(this.recentTriggers)) {
            data["recentTriggers"] = [];
            for (let item of this.recentTriggers)
                data["recentTriggers"].push(item ? item.toJSON() : <any>undefined);
        }
        if (this.triggersByMonth) {
            data["triggersByMonth"] = {};
            for (let key in this.triggersByMonth) {
                if (this.triggersByMonth.hasOwnProperty(key))
                    (<any>data["triggersByMonth"])[key] = (<any>this.triggersByMonth)[key];
            }
        }
        if (this.triggersBySeller) {
            data["triggersBySeller"] = {};
            for (let key in this.triggersBySeller) {
                if (this.triggersBySeller.hasOwnProperty(key))
                    (<any>data["triggersBySeller"])[key] = (<any>this.triggersBySeller)[key];
            }
        }
        return data;
    }
}

export interface IAlertPerformanceMetricsDto {
    alertRuleId?: string;
    ruleDescription?: string | undefined;
    analysisPeriodStart?: Date | undefined;
    analysisPeriodEnd?: Date | undefined;
    totalPricePointsAnalyzed?: number;
    timesWouldHaveTriggered?: number;
    triggerRate?: number;
    lowestTriggeringPrice?: number | undefined;
    highestTriggeringPrice?: number | undefined;
    averageTriggeringPrice?: number | undefined;
    recentTriggers?: AlertTestMatchDto[] | undefined;
    triggersByMonth?: { [key: string]: number; } | undefined;
    triggersBySeller?: { [key: string]: number; } | undefined;
}

export class AlertPerformanceMetricsDtoApiResponse implements IAlertPerformanceMetricsDtoApiResponse {
    success?: boolean;
    data?: AlertPerformanceMetricsDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IAlertPerformanceMetricsDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"] ? AlertPerformanceMetricsDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): AlertPerformanceMetricsDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AlertPerformanceMetricsDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IAlertPerformanceMetricsDtoApiResponse {
    success?: boolean;
    data?: AlertPerformanceMetricsDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class AlertPerformanceReportDto implements IAlertPerformanceReportDto {
    generatedAt?: Date;
    periodStart?: Date;
    periodEnd?: Date;
    overallPerformance?: AlertSystemPerformanceDto;
    topPerformers?: AlertRulePerformanceAnalysisDto[] | undefined;
    poorPerformers?: AlertRulePerformanceAnalysisDto[] | undefined;
    keyInsights?: string[] | undefined;
    recommendations?: string[] | undefined;
    rawMetrics?: { [key: string]: any; } | undefined;

    constructor(data?: IAlertPerformanceReportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.generatedAt = _data["generatedAt"] ? new Date(_data["generatedAt"].toString()) : <any>undefined;
            this.periodStart = _data["periodStart"] ? new Date(_data["periodStart"].toString()) : <any>undefined;
            this.periodEnd = _data["periodEnd"] ? new Date(_data["periodEnd"].toString()) : <any>undefined;
            this.overallPerformance = _data["overallPerformance"] ? AlertSystemPerformanceDto.fromJS(_data["overallPerformance"]) : <any>undefined;
            if (Array.isArray(_data["topPerformers"])) {
                this.topPerformers = [] as any;
                for (let item of _data["topPerformers"])
                    this.topPerformers!.push(AlertRulePerformanceAnalysisDto.fromJS(item));
            }
            if (Array.isArray(_data["poorPerformers"])) {
                this.poorPerformers = [] as any;
                for (let item of _data["poorPerformers"])
                    this.poorPerformers!.push(AlertRulePerformanceAnalysisDto.fromJS(item));
            }
            if (Array.isArray(_data["keyInsights"])) {
                this.keyInsights = [] as any;
                for (let item of _data["keyInsights"])
                    this.keyInsights!.push(item);
            }
            if (Array.isArray(_data["recommendations"])) {
                this.recommendations = [] as any;
                for (let item of _data["recommendations"])
                    this.recommendations!.push(item);
            }
            if (_data["rawMetrics"]) {
                this.rawMetrics = {} as any;
                for (let key in _data["rawMetrics"]) {
                    if (_data["rawMetrics"].hasOwnProperty(key))
                        (<any>this.rawMetrics)![key] = _data["rawMetrics"][key];
                }
            }
        }
    }

    static fromJS(data: any): AlertPerformanceReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new AlertPerformanceReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["generatedAt"] = this.generatedAt ? this.generatedAt.toISOString() : <any>undefined;
        data["periodStart"] = this.periodStart ? this.periodStart.toISOString() : <any>undefined;
        data["periodEnd"] = this.periodEnd ? this.periodEnd.toISOString() : <any>undefined;
        data["overallPerformance"] = this.overallPerformance ? this.overallPerformance.toJSON() : <any>undefined;
        if (Array.isArray(this.topPerformers)) {
            data["topPerformers"] = [];
            for (let item of this.topPerformers)
                data["topPerformers"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.poorPerformers)) {
            data["poorPerformers"] = [];
            for (let item of this.poorPerformers)
                data["poorPerformers"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.keyInsights)) {
            data["keyInsights"] = [];
            for (let item of this.keyInsights)
                data["keyInsights"].push(item);
        }
        if (Array.isArray(this.recommendations)) {
            data["recommendations"] = [];
            for (let item of this.recommendations)
                data["recommendations"].push(item);
        }
        if (this.rawMetrics) {
            data["rawMetrics"] = {};
            for (let key in this.rawMetrics) {
                if (this.rawMetrics.hasOwnProperty(key))
                    (<any>data["rawMetrics"])[key] = (<any>this.rawMetrics)[key];
            }
        }
        return data;
    }
}

export interface IAlertPerformanceReportDto {
    generatedAt?: Date;
    periodStart?: Date;
    periodEnd?: Date;
    overallPerformance?: AlertSystemPerformanceDto;
    topPerformers?: AlertRulePerformanceAnalysisDto[] | undefined;
    poorPerformers?: AlertRulePerformanceAnalysisDto[] | undefined;
    keyInsights?: string[] | undefined;
    recommendations?: string[] | undefined;
    rawMetrics?: { [key: string]: any; } | undefined;
}

export class AlertPerformanceReportDtoApiResponse implements IAlertPerformanceReportDtoApiResponse {
    success?: boolean;
    data?: AlertPerformanceReportDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IAlertPerformanceReportDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"] ? AlertPerformanceReportDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): AlertPerformanceReportDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AlertPerformanceReportDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IAlertPerformanceReportDtoApiResponse {
    success?: boolean;
    data?: AlertPerformanceReportDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class AlertPerformanceTrendDto implements IAlertPerformanceTrendDto {
    timestamp?: Date;
    alertsTriggered?: number;
    notificationsSent?: number;
    successRate?: number;
    averageResponseTime?: string;
    errorCount?: number;

    constructor(data?: IAlertPerformanceTrendDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.alertsTriggered = _data["alertsTriggered"];
            this.notificationsSent = _data["notificationsSent"];
            this.successRate = _data["successRate"];
            this.averageResponseTime = _data["averageResponseTime"];
            this.errorCount = _data["errorCount"];
        }
    }

    static fromJS(data: any): AlertPerformanceTrendDto {
        data = typeof data === 'object' ? data : {};
        let result = new AlertPerformanceTrendDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["alertsTriggered"] = this.alertsTriggered;
        data["notificationsSent"] = this.notificationsSent;
        data["successRate"] = this.successRate;
        data["averageResponseTime"] = this.averageResponseTime;
        data["errorCount"] = this.errorCount;
        return data;
    }
}

export interface IAlertPerformanceTrendDto {
    timestamp?: Date;
    alertsTriggered?: number;
    notificationsSent?: number;
    successRate?: number;
    averageResponseTime?: string;
    errorCount?: number;
}

export class AlertPerformanceTrendDtoListApiResponse implements IAlertPerformanceTrendDtoListApiResponse {
    success?: boolean;
    data?: AlertPerformanceTrendDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IAlertPerformanceTrendDtoListApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(AlertPerformanceTrendDto.fromJS(item));
            }
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): AlertPerformanceTrendDtoListApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AlertPerformanceTrendDtoListApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : <any>undefined);
        }
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IAlertPerformanceTrendDtoListApiResponse {
    success?: boolean;
    data?: AlertPerformanceTrendDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class AlertRuleDto implements IAlertRuleDto {
    alertRuleId?: string;
    userId?: string;
    canonicalProductId?: string;
    conditionType?: string | undefined;
    alertType?: string | undefined;
    thresholdValue?: number | undefined;
    percentageValue?: number | undefined;
    specificSellerName?: string | undefined;
    notificationFrequencyMinutes?: number;
    isActive?: boolean;
    lastNotifiedAt?: Date | undefined;
    createdAt?: Date;
    updatedAt?: Date;
    ruleDescription?: string | undefined;
    user?: UserDto;
    product?: ProductDto;

    constructor(data?: IAlertRuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alertRuleId = _data["alertRuleId"];
            this.userId = _data["userId"];
            this.canonicalProductId = _data["canonicalProductId"];
            this.conditionType = _data["conditionType"];
            this.alertType = _data["alertType"];
            this.thresholdValue = _data["thresholdValue"];
            this.percentageValue = _data["percentageValue"];
            this.specificSellerName = _data["specificSellerName"];
            this.notificationFrequencyMinutes = _data["notificationFrequencyMinutes"];
            this.isActive = _data["isActive"];
            this.lastNotifiedAt = _data["lastNotifiedAt"] ? new Date(_data["lastNotifiedAt"].toString()) : <any>undefined;
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.ruleDescription = _data["ruleDescription"];
            this.user = _data["user"] ? UserDto.fromJS(_data["user"]) : <any>undefined;
            this.product = _data["product"] ? ProductDto.fromJS(_data["product"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AlertRuleDto {
        data = typeof data === 'object' ? data : {};
        let result = new AlertRuleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["alertRuleId"] = this.alertRuleId;
        data["userId"] = this.userId;
        data["canonicalProductId"] = this.canonicalProductId;
        data["conditionType"] = this.conditionType;
        data["alertType"] = this.alertType;
        data["thresholdValue"] = this.thresholdValue;
        data["percentageValue"] = this.percentageValue;
        data["specificSellerName"] = this.specificSellerName;
        data["notificationFrequencyMinutes"] = this.notificationFrequencyMinutes;
        data["isActive"] = this.isActive;
        data["lastNotifiedAt"] = this.lastNotifiedAt ? this.lastNotifiedAt.toISOString() : <any>undefined;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["ruleDescription"] = this.ruleDescription;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        return data;
    }
}

export interface IAlertRuleDto {
    alertRuleId?: string;
    userId?: string;
    canonicalProductId?: string;
    conditionType?: string | undefined;
    alertType?: string | undefined;
    thresholdValue?: number | undefined;
    percentageValue?: number | undefined;
    specificSellerName?: string | undefined;
    notificationFrequencyMinutes?: number;
    isActive?: boolean;
    lastNotifiedAt?: Date | undefined;
    createdAt?: Date;
    updatedAt?: Date;
    ruleDescription?: string | undefined;
    user?: UserDto;
    product?: ProductDto;
}

export class AlertRuleDtoApiResponse implements IAlertRuleDtoApiResponse {
    success?: boolean;
    data?: AlertRuleDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IAlertRuleDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"] ? AlertRuleDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): AlertRuleDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AlertRuleDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IAlertRuleDtoApiResponse {
    success?: boolean;
    data?: AlertRuleDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class AlertRuleDtoIEnumerableApiResponse implements IAlertRuleDtoIEnumerableApiResponse {
    success?: boolean;
    data?: AlertRuleDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IAlertRuleDtoIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(AlertRuleDto.fromJS(item));
            }
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): AlertRuleDtoIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AlertRuleDtoIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : <any>undefined);
        }
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IAlertRuleDtoIEnumerableApiResponse {
    success?: boolean;
    data?: AlertRuleDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class AlertRuleDtoPagedResponse implements IAlertRuleDtoPagedResponse {
    success?: boolean;
    data?: AlertRuleDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
    pagination?: PaginationMeta;

    constructor(data?: IAlertRuleDtoPagedResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(AlertRuleDto.fromJS(item));
            }
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
            this.pagination = _data["pagination"] ? PaginationMeta.fromJS(_data["pagination"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AlertRuleDtoPagedResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AlertRuleDtoPagedResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : <any>undefined);
        }
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        data["pagination"] = this.pagination ? this.pagination.toJSON() : <any>undefined;
        return data;
    }
}

export interface IAlertRuleDtoPagedResponse {
    success?: boolean;
    data?: AlertRuleDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
    pagination?: PaginationMeta;
}

export class AlertRulePerformanceAnalysisDto implements IAlertRulePerformanceAnalysisDto {
    alertRuleId?: string;
    ruleDescription?: string | undefined;
    conditionType?: string | undefined;
    isActive?: boolean;
    timesTriggered?: number;
    notificationsSent?: number;
    notificationSuccessRate?: number;
    averageEvaluationTime?: string;
    averageNotificationTime?: string;
    lastTriggered?: Date | undefined;
    lastSuccessfulNotification?: Date | undefined;
    recentErrors?: string[] | undefined;
    performanceRating?: PerformanceRating;
    optimizationSuggestions?: string[] | undefined;

    constructor(data?: IAlertRulePerformanceAnalysisDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alertRuleId = _data["alertRuleId"];
            this.ruleDescription = _data["ruleDescription"];
            this.conditionType = _data["conditionType"];
            this.isActive = _data["isActive"];
            this.timesTriggered = _data["timesTriggered"];
            this.notificationsSent = _data["notificationsSent"];
            this.notificationSuccessRate = _data["notificationSuccessRate"];
            this.averageEvaluationTime = _data["averageEvaluationTime"];
            this.averageNotificationTime = _data["averageNotificationTime"];
            this.lastTriggered = _data["lastTriggered"] ? new Date(_data["lastTriggered"].toString()) : <any>undefined;
            this.lastSuccessfulNotification = _data["lastSuccessfulNotification"] ? new Date(_data["lastSuccessfulNotification"].toString()) : <any>undefined;
            if (Array.isArray(_data["recentErrors"])) {
                this.recentErrors = [] as any;
                for (let item of _data["recentErrors"])
                    this.recentErrors!.push(item);
            }
            this.performanceRating = _data["performanceRating"];
            if (Array.isArray(_data["optimizationSuggestions"])) {
                this.optimizationSuggestions = [] as any;
                for (let item of _data["optimizationSuggestions"])
                    this.optimizationSuggestions!.push(item);
            }
        }
    }

    static fromJS(data: any): AlertRulePerformanceAnalysisDto {
        data = typeof data === 'object' ? data : {};
        let result = new AlertRulePerformanceAnalysisDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["alertRuleId"] = this.alertRuleId;
        data["ruleDescription"] = this.ruleDescription;
        data["conditionType"] = this.conditionType;
        data["isActive"] = this.isActive;
        data["timesTriggered"] = this.timesTriggered;
        data["notificationsSent"] = this.notificationsSent;
        data["notificationSuccessRate"] = this.notificationSuccessRate;
        data["averageEvaluationTime"] = this.averageEvaluationTime;
        data["averageNotificationTime"] = this.averageNotificationTime;
        data["lastTriggered"] = this.lastTriggered ? this.lastTriggered.toISOString() : <any>undefined;
        data["lastSuccessfulNotification"] = this.lastSuccessfulNotification ? this.lastSuccessfulNotification.toISOString() : <any>undefined;
        if (Array.isArray(this.recentErrors)) {
            data["recentErrors"] = [];
            for (let item of this.recentErrors)
                data["recentErrors"].push(item);
        }
        data["performanceRating"] = this.performanceRating;
        if (Array.isArray(this.optimizationSuggestions)) {
            data["optimizationSuggestions"] = [];
            for (let item of this.optimizationSuggestions)
                data["optimizationSuggestions"].push(item);
        }
        return data;
    }
}

export interface IAlertRulePerformanceAnalysisDto {
    alertRuleId?: string;
    ruleDescription?: string | undefined;
    conditionType?: string | undefined;
    isActive?: boolean;
    timesTriggered?: number;
    notificationsSent?: number;
    notificationSuccessRate?: number;
    averageEvaluationTime?: string;
    averageNotificationTime?: string;
    lastTriggered?: Date | undefined;
    lastSuccessfulNotification?: Date | undefined;
    recentErrors?: string[] | undefined;
    performanceRating?: PerformanceRating;
    optimizationSuggestions?: string[] | undefined;
}

export class AlertRulePerformanceAnalysisDtoApiResponse implements IAlertRulePerformanceAnalysisDtoApiResponse {
    success?: boolean;
    data?: AlertRulePerformanceAnalysisDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IAlertRulePerformanceAnalysisDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"] ? AlertRulePerformanceAnalysisDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): AlertRulePerformanceAnalysisDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AlertRulePerformanceAnalysisDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IAlertRulePerformanceAnalysisDtoApiResponse {
    success?: boolean;
    data?: AlertRulePerformanceAnalysisDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class AlertRulePerformanceAnalysisDtoListApiResponse implements IAlertRulePerformanceAnalysisDtoListApiResponse {
    success?: boolean;
    data?: AlertRulePerformanceAnalysisDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IAlertRulePerformanceAnalysisDtoListApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(AlertRulePerformanceAnalysisDto.fromJS(item));
            }
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): AlertRulePerformanceAnalysisDtoListApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AlertRulePerformanceAnalysisDtoListApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : <any>undefined);
        }
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IAlertRulePerformanceAnalysisDtoListApiResponse {
    success?: boolean;
    data?: AlertRulePerformanceAnalysisDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class AlertRuleSimulationRequestDto implements IAlertRuleSimulationRequestDto {
    alertRule!: TestAlertRuleDto;
    testPricePoint?: TestPricePointDto;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    maxRecords?: number | undefined;

    constructor(data?: IAlertRuleSimulationRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.alertRule = new TestAlertRuleDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alertRule = _data["alertRule"] ? TestAlertRuleDto.fromJS(_data["alertRule"]) : new TestAlertRuleDto();
            this.testPricePoint = _data["testPricePoint"] ? TestPricePointDto.fromJS(_data["testPricePoint"]) : <any>undefined;
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.maxRecords = _data["maxRecords"];
        }
    }

    static fromJS(data: any): AlertRuleSimulationRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new AlertRuleSimulationRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["alertRule"] = this.alertRule ? this.alertRule.toJSON() : <any>undefined;
        data["testPricePoint"] = this.testPricePoint ? this.testPricePoint.toJSON() : <any>undefined;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["maxRecords"] = this.maxRecords;
        return data;
    }
}

export interface IAlertRuleSimulationRequestDto {
    alertRule: TestAlertRuleDto;
    testPricePoint?: TestPricePointDto;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    maxRecords?: number | undefined;
}

export class AlertRuleValidationResultDto implements IAlertRuleValidationResultDto {
    isValid?: boolean;
    validationErrors?: string[] | undefined;
    warnings?: string[] | undefined;
    suggestions?: string[] | undefined;
    productExists?: boolean;
    productName?: string | undefined;
    currentLowestPrice?: number | undefined;
    currentHighestPrice?: number | undefined;
    mostCommonStockStatus?: string | undefined;

    constructor(data?: IAlertRuleValidationResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isValid = _data["isValid"];
            if (Array.isArray(_data["validationErrors"])) {
                this.validationErrors = [] as any;
                for (let item of _data["validationErrors"])
                    this.validationErrors!.push(item);
            }
            if (Array.isArray(_data["warnings"])) {
                this.warnings = [] as any;
                for (let item of _data["warnings"])
                    this.warnings!.push(item);
            }
            if (Array.isArray(_data["suggestions"])) {
                this.suggestions = [] as any;
                for (let item of _data["suggestions"])
                    this.suggestions!.push(item);
            }
            this.productExists = _data["productExists"];
            this.productName = _data["productName"];
            this.currentLowestPrice = _data["currentLowestPrice"];
            this.currentHighestPrice = _data["currentHighestPrice"];
            this.mostCommonStockStatus = _data["mostCommonStockStatus"];
        }
    }

    static fromJS(data: any): AlertRuleValidationResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new AlertRuleValidationResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isValid"] = this.isValid;
        if (Array.isArray(this.validationErrors)) {
            data["validationErrors"] = [];
            for (let item of this.validationErrors)
                data["validationErrors"].push(item);
        }
        if (Array.isArray(this.warnings)) {
            data["warnings"] = [];
            for (let item of this.warnings)
                data["warnings"].push(item);
        }
        if (Array.isArray(this.suggestions)) {
            data["suggestions"] = [];
            for (let item of this.suggestions)
                data["suggestions"].push(item);
        }
        data["productExists"] = this.productExists;
        data["productName"] = this.productName;
        data["currentLowestPrice"] = this.currentLowestPrice;
        data["currentHighestPrice"] = this.currentHighestPrice;
        data["mostCommonStockStatus"] = this.mostCommonStockStatus;
        return data;
    }
}

export interface IAlertRuleValidationResultDto {
    isValid?: boolean;
    validationErrors?: string[] | undefined;
    warnings?: string[] | undefined;
    suggestions?: string[] | undefined;
    productExists?: boolean;
    productName?: string | undefined;
    currentLowestPrice?: number | undefined;
    currentHighestPrice?: number | undefined;
    mostCommonStockStatus?: string | undefined;
}

export class AlertRuleValidationResultDtoApiResponse implements IAlertRuleValidationResultDtoApiResponse {
    success?: boolean;
    data?: AlertRuleValidationResultDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IAlertRuleValidationResultDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"] ? AlertRuleValidationResultDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): AlertRuleValidationResultDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AlertRuleValidationResultDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IAlertRuleValidationResultDtoApiResponse {
    success?: boolean;
    data?: AlertRuleValidationResultDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class AlertSystemEventDto implements IAlertSystemEventDto {
    timestamp?: Date;
    eventType?: string | undefined;
    message?: string | undefined;
    component?: string | undefined;
    metadata?: { [key: string]: any; } | undefined;

    constructor(data?: IAlertSystemEventDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.eventType = _data["eventType"];
            this.message = _data["message"];
            this.component = _data["component"];
            if (_data["metadata"]) {
                this.metadata = {} as any;
                for (let key in _data["metadata"]) {
                    if (_data["metadata"].hasOwnProperty(key))
                        (<any>this.metadata)![key] = _data["metadata"][key];
                }
            }
        }
    }

    static fromJS(data: any): AlertSystemEventDto {
        data = typeof data === 'object' ? data : {};
        let result = new AlertSystemEventDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["eventType"] = this.eventType;
        data["message"] = this.message;
        data["component"] = this.component;
        if (this.metadata) {
            data["metadata"] = {};
            for (let key in this.metadata) {
                if (this.metadata.hasOwnProperty(key))
                    (<any>data["metadata"])[key] = (<any>this.metadata)[key];
            }
        }
        return data;
    }
}

export interface IAlertSystemEventDto {
    timestamp?: Date;
    eventType?: string | undefined;
    message?: string | undefined;
    component?: string | undefined;
    metadata?: { [key: string]: any; } | undefined;
}

export class AlertSystemHealthDto implements IAlertSystemHealthDto {
    isHealthy?: boolean;
    healthIssues?: string[] | undefined;
    activeAlertRules?: number;
    inactiveAlertRules?: number;
    alertRulesWithErrors?: number;
    systemUptime?: string;
    memoryUsageMB?: number;
    cpuUsagePercent?: number;
    queueBacklog?: number;
    averageProcessingDelay?: string;

    constructor(data?: IAlertSystemHealthDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isHealthy = _data["isHealthy"];
            if (Array.isArray(_data["healthIssues"])) {
                this.healthIssues = [] as any;
                for (let item of _data["healthIssues"])
                    this.healthIssues!.push(item);
            }
            this.activeAlertRules = _data["activeAlertRules"];
            this.inactiveAlertRules = _data["inactiveAlertRules"];
            this.alertRulesWithErrors = _data["alertRulesWithErrors"];
            this.systemUptime = _data["systemUptime"];
            this.memoryUsageMB = _data["memoryUsageMB"];
            this.cpuUsagePercent = _data["cpuUsagePercent"];
            this.queueBacklog = _data["queueBacklog"];
            this.averageProcessingDelay = _data["averageProcessingDelay"];
        }
    }

    static fromJS(data: any): AlertSystemHealthDto {
        data = typeof data === 'object' ? data : {};
        let result = new AlertSystemHealthDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isHealthy"] = this.isHealthy;
        if (Array.isArray(this.healthIssues)) {
            data["healthIssues"] = [];
            for (let item of this.healthIssues)
                data["healthIssues"].push(item);
        }
        data["activeAlertRules"] = this.activeAlertRules;
        data["inactiveAlertRules"] = this.inactiveAlertRules;
        data["alertRulesWithErrors"] = this.alertRulesWithErrors;
        data["systemUptime"] = this.systemUptime;
        data["memoryUsageMB"] = this.memoryUsageMB;
        data["cpuUsagePercent"] = this.cpuUsagePercent;
        data["queueBacklog"] = this.queueBacklog;
        data["averageProcessingDelay"] = this.averageProcessingDelay;
        return data;
    }
}

export interface IAlertSystemHealthDto {
    isHealthy?: boolean;
    healthIssues?: string[] | undefined;
    activeAlertRules?: number;
    inactiveAlertRules?: number;
    alertRulesWithErrors?: number;
    systemUptime?: string;
    memoryUsageMB?: number;
    cpuUsagePercent?: number;
    queueBacklog?: number;
    averageProcessingDelay?: string;
}

export class AlertSystemHealthDtoApiResponse implements IAlertSystemHealthDtoApiResponse {
    success?: boolean;
    data?: AlertSystemHealthDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IAlertSystemHealthDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"] ? AlertSystemHealthDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): AlertSystemHealthDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AlertSystemHealthDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IAlertSystemHealthDtoApiResponse {
    success?: boolean;
    data?: AlertSystemHealthDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class AlertSystemPerformanceDto implements IAlertSystemPerformanceDto {
    metricsGeneratedAt?: Date;
    periodStart?: Date | undefined;
    periodEnd?: Date | undefined;
    evaluationMetrics?: AlertEvaluationMetricsDto;
    notificationMetrics?: NotificationDeliveryMetricsDto;
    systemHealth?: AlertSystemHealthDto;
    performanceTrends?: AlertPerformanceTrendDto[] | undefined;

    constructor(data?: IAlertSystemPerformanceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.metricsGeneratedAt = _data["metricsGeneratedAt"] ? new Date(_data["metricsGeneratedAt"].toString()) : <any>undefined;
            this.periodStart = _data["periodStart"] ? new Date(_data["periodStart"].toString()) : <any>undefined;
            this.periodEnd = _data["periodEnd"] ? new Date(_data["periodEnd"].toString()) : <any>undefined;
            this.evaluationMetrics = _data["evaluationMetrics"] ? AlertEvaluationMetricsDto.fromJS(_data["evaluationMetrics"]) : <any>undefined;
            this.notificationMetrics = _data["notificationMetrics"] ? NotificationDeliveryMetricsDto.fromJS(_data["notificationMetrics"]) : <any>undefined;
            this.systemHealth = _data["systemHealth"] ? AlertSystemHealthDto.fromJS(_data["systemHealth"]) : <any>undefined;
            if (Array.isArray(_data["performanceTrends"])) {
                this.performanceTrends = [] as any;
                for (let item of _data["performanceTrends"])
                    this.performanceTrends!.push(AlertPerformanceTrendDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AlertSystemPerformanceDto {
        data = typeof data === 'object' ? data : {};
        let result = new AlertSystemPerformanceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["metricsGeneratedAt"] = this.metricsGeneratedAt ? this.metricsGeneratedAt.toISOString() : <any>undefined;
        data["periodStart"] = this.periodStart ? this.periodStart.toISOString() : <any>undefined;
        data["periodEnd"] = this.periodEnd ? this.periodEnd.toISOString() : <any>undefined;
        data["evaluationMetrics"] = this.evaluationMetrics ? this.evaluationMetrics.toJSON() : <any>undefined;
        data["notificationMetrics"] = this.notificationMetrics ? this.notificationMetrics.toJSON() : <any>undefined;
        data["systemHealth"] = this.systemHealth ? this.systemHealth.toJSON() : <any>undefined;
        if (Array.isArray(this.performanceTrends)) {
            data["performanceTrends"] = [];
            for (let item of this.performanceTrends)
                data["performanceTrends"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface IAlertSystemPerformanceDto {
    metricsGeneratedAt?: Date;
    periodStart?: Date | undefined;
    periodEnd?: Date | undefined;
    evaluationMetrics?: AlertEvaluationMetricsDto;
    notificationMetrics?: NotificationDeliveryMetricsDto;
    systemHealth?: AlertSystemHealthDto;
    performanceTrends?: AlertPerformanceTrendDto[] | undefined;
}

export class AlertSystemPerformanceDtoApiResponse implements IAlertSystemPerformanceDtoApiResponse {
    success?: boolean;
    data?: AlertSystemPerformanceDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IAlertSystemPerformanceDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"] ? AlertSystemPerformanceDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): AlertSystemPerformanceDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AlertSystemPerformanceDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IAlertSystemPerformanceDtoApiResponse {
    success?: boolean;
    data?: AlertSystemPerformanceDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class AlertTestMatchDto implements IAlertTestMatchDto {
    price?: number;
    stockStatus?: string | undefined;
    sellerName?: string | undefined;
    timestamp?: Date;
    sourceUrl?: string | undefined;
    triggerReason?: string | undefined;
    wouldTrigger?: boolean;

    constructor(data?: IAlertTestMatchDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.price = _data["price"];
            this.stockStatus = _data["stockStatus"];
            this.sellerName = _data["sellerName"];
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.sourceUrl = _data["sourceUrl"];
            this.triggerReason = _data["triggerReason"];
            this.wouldTrigger = _data["wouldTrigger"];
        }
    }

    static fromJS(data: any): AlertTestMatchDto {
        data = typeof data === 'object' ? data : {};
        let result = new AlertTestMatchDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["price"] = this.price;
        data["stockStatus"] = this.stockStatus;
        data["sellerName"] = this.sellerName;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["sourceUrl"] = this.sourceUrl;
        data["triggerReason"] = this.triggerReason;
        data["wouldTrigger"] = this.wouldTrigger;
        return data;
    }
}

export interface IAlertTestMatchDto {
    price?: number;
    stockStatus?: string | undefined;
    sellerName?: string | undefined;
    timestamp?: Date;
    sourceUrl?: string | undefined;
    triggerReason?: string | undefined;
    wouldTrigger?: boolean;
}

export class AlertTestRequestDto implements IAlertTestRequestDto {
    alertRuleId!: string;
    testPricePoint?: TestPricePointDto;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    maxRecords?: number | undefined;

    constructor(data?: IAlertTestRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alertRuleId = _data["alertRuleId"];
            this.testPricePoint = _data["testPricePoint"] ? TestPricePointDto.fromJS(_data["testPricePoint"]) : <any>undefined;
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.maxRecords = _data["maxRecords"];
        }
    }

    static fromJS(data: any): AlertTestRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new AlertTestRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["alertRuleId"] = this.alertRuleId;
        data["testPricePoint"] = this.testPricePoint ? this.testPricePoint.toJSON() : <any>undefined;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["maxRecords"] = this.maxRecords;
        return data;
    }
}

export interface IAlertTestRequestDto {
    alertRuleId: string;
    testPricePoint?: TestPricePointDto;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    maxRecords?: number | undefined;
}

export class AlertTestResultDto implements IAlertTestResultDto {
    alertRuleId?: string;
    alertRuleDescription?: string | undefined;
    wouldTrigger?: boolean;
    testType?: string | undefined;
    totalPointsTested?: number;
    triggeredCount?: number;
    matches?: AlertTestMatchDto[] | undefined;
    errorMessage?: string | undefined;
    testedAt?: Date;

    constructor(data?: IAlertTestResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alertRuleId = _data["alertRuleId"];
            this.alertRuleDescription = _data["alertRuleDescription"];
            this.wouldTrigger = _data["wouldTrigger"];
            this.testType = _data["testType"];
            this.totalPointsTested = _data["totalPointsTested"];
            this.triggeredCount = _data["triggeredCount"];
            if (Array.isArray(_data["matches"])) {
                this.matches = [] as any;
                for (let item of _data["matches"])
                    this.matches!.push(AlertTestMatchDto.fromJS(item));
            }
            this.errorMessage = _data["errorMessage"];
            this.testedAt = _data["testedAt"] ? new Date(_data["testedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): AlertTestResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new AlertTestResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["alertRuleId"] = this.alertRuleId;
        data["alertRuleDescription"] = this.alertRuleDescription;
        data["wouldTrigger"] = this.wouldTrigger;
        data["testType"] = this.testType;
        data["totalPointsTested"] = this.totalPointsTested;
        data["triggeredCount"] = this.triggeredCount;
        if (Array.isArray(this.matches)) {
            data["matches"] = [];
            for (let item of this.matches)
                data["matches"].push(item ? item.toJSON() : <any>undefined);
        }
        data["errorMessage"] = this.errorMessage;
        data["testedAt"] = this.testedAt ? this.testedAt.toISOString() : <any>undefined;
        return data;
    }
}

export interface IAlertTestResultDto {
    alertRuleId?: string;
    alertRuleDescription?: string | undefined;
    wouldTrigger?: boolean;
    testType?: string | undefined;
    totalPointsTested?: number;
    triggeredCount?: number;
    matches?: AlertTestMatchDto[] | undefined;
    errorMessage?: string | undefined;
    testedAt?: Date;
}

export class AlertTestResultDtoApiResponse implements IAlertTestResultDtoApiResponse {
    success?: boolean;
    data?: AlertTestResultDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IAlertTestResultDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"] ? AlertTestResultDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): AlertTestResultDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AlertTestResultDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IAlertTestResultDtoApiResponse {
    success?: boolean;
    data?: AlertTestResultDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class AlertTestResultDtoListApiResponse implements IAlertTestResultDtoListApiResponse {
    success?: boolean;
    data?: AlertTestResultDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IAlertTestResultDtoListApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(AlertTestResultDto.fromJS(item));
            }
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): AlertTestResultDtoListApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AlertTestResultDtoListApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : <any>undefined);
        }
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IAlertTestResultDtoListApiResponse {
    success?: boolean;
    data?: AlertTestResultDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class AlertTestingStatsDto implements IAlertTestingStatsDto {
    totalTestsRun?: number;
    totalSimulationsRun?: number;
    totalValidationsRun?: number;
    testsByConditionType?: { [key: string]: number; } | undefined;
    testsByUser?: { [key: string]: number; } | undefined;
    testsByProduct?: { [key: string]: number; } | undefined;
    testsByResult?: { [key: string]: number; } | undefined;
    lastTestRun?: Date | undefined;
    firstTestRun?: Date | undefined;
    averageExecutionTimeMs?: number;
    uniqueAlertRulesTested?: number;
    uniqueProductsTested?: number;
    dailyTestCounts?: { [key: string]: number; } | undefined;
    periodStart?: Date | undefined;
    periodEnd?: Date | undefined;

    constructor(data?: IAlertTestingStatsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalTestsRun = _data["totalTestsRun"];
            this.totalSimulationsRun = _data["totalSimulationsRun"];
            this.totalValidationsRun = _data["totalValidationsRun"];
            if (_data["testsByConditionType"]) {
                this.testsByConditionType = {} as any;
                for (let key in _data["testsByConditionType"]) {
                    if (_data["testsByConditionType"].hasOwnProperty(key))
                        (<any>this.testsByConditionType)![key] = _data["testsByConditionType"][key];
                }
            }
            if (_data["testsByUser"]) {
                this.testsByUser = {} as any;
                for (let key in _data["testsByUser"]) {
                    if (_data["testsByUser"].hasOwnProperty(key))
                        (<any>this.testsByUser)![key] = _data["testsByUser"][key];
                }
            }
            if (_data["testsByProduct"]) {
                this.testsByProduct = {} as any;
                for (let key in _data["testsByProduct"]) {
                    if (_data["testsByProduct"].hasOwnProperty(key))
                        (<any>this.testsByProduct)![key] = _data["testsByProduct"][key];
                }
            }
            if (_data["testsByResult"]) {
                this.testsByResult = {} as any;
                for (let key in _data["testsByResult"]) {
                    if (_data["testsByResult"].hasOwnProperty(key))
                        (<any>this.testsByResult)![key] = _data["testsByResult"][key];
                }
            }
            this.lastTestRun = _data["lastTestRun"] ? new Date(_data["lastTestRun"].toString()) : <any>undefined;
            this.firstTestRun = _data["firstTestRun"] ? new Date(_data["firstTestRun"].toString()) : <any>undefined;
            this.averageExecutionTimeMs = _data["averageExecutionTimeMs"];
            this.uniqueAlertRulesTested = _data["uniqueAlertRulesTested"];
            this.uniqueProductsTested = _data["uniqueProductsTested"];
            if (_data["dailyTestCounts"]) {
                this.dailyTestCounts = {} as any;
                for (let key in _data["dailyTestCounts"]) {
                    if (_data["dailyTestCounts"].hasOwnProperty(key))
                        (<any>this.dailyTestCounts)![key] = _data["dailyTestCounts"][key];
                }
            }
            this.periodStart = _data["periodStart"] ? new Date(_data["periodStart"].toString()) : <any>undefined;
            this.periodEnd = _data["periodEnd"] ? new Date(_data["periodEnd"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): AlertTestingStatsDto {
        data = typeof data === 'object' ? data : {};
        let result = new AlertTestingStatsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalTestsRun"] = this.totalTestsRun;
        data["totalSimulationsRun"] = this.totalSimulationsRun;
        data["totalValidationsRun"] = this.totalValidationsRun;
        if (this.testsByConditionType) {
            data["testsByConditionType"] = {};
            for (let key in this.testsByConditionType) {
                if (this.testsByConditionType.hasOwnProperty(key))
                    (<any>data["testsByConditionType"])[key] = (<any>this.testsByConditionType)[key];
            }
        }
        if (this.testsByUser) {
            data["testsByUser"] = {};
            for (let key in this.testsByUser) {
                if (this.testsByUser.hasOwnProperty(key))
                    (<any>data["testsByUser"])[key] = (<any>this.testsByUser)[key];
            }
        }
        if (this.testsByProduct) {
            data["testsByProduct"] = {};
            for (let key in this.testsByProduct) {
                if (this.testsByProduct.hasOwnProperty(key))
                    (<any>data["testsByProduct"])[key] = (<any>this.testsByProduct)[key];
            }
        }
        if (this.testsByResult) {
            data["testsByResult"] = {};
            for (let key in this.testsByResult) {
                if (this.testsByResult.hasOwnProperty(key))
                    (<any>data["testsByResult"])[key] = (<any>this.testsByResult)[key];
            }
        }
        data["lastTestRun"] = this.lastTestRun ? this.lastTestRun.toISOString() : <any>undefined;
        data["firstTestRun"] = this.firstTestRun ? this.firstTestRun.toISOString() : <any>undefined;
        data["averageExecutionTimeMs"] = this.averageExecutionTimeMs;
        data["uniqueAlertRulesTested"] = this.uniqueAlertRulesTested;
        data["uniqueProductsTested"] = this.uniqueProductsTested;
        if (this.dailyTestCounts) {
            data["dailyTestCounts"] = {};
            for (let key in this.dailyTestCounts) {
                if (this.dailyTestCounts.hasOwnProperty(key))
                    (<any>data["dailyTestCounts"])[key] = (<any>this.dailyTestCounts)[key];
            }
        }
        data["periodStart"] = this.periodStart ? this.periodStart.toISOString() : <any>undefined;
        data["periodEnd"] = this.periodEnd ? this.periodEnd.toISOString() : <any>undefined;
        return data;
    }
}

export interface IAlertTestingStatsDto {
    totalTestsRun?: number;
    totalSimulationsRun?: number;
    totalValidationsRun?: number;
    testsByConditionType?: { [key: string]: number; } | undefined;
    testsByUser?: { [key: string]: number; } | undefined;
    testsByProduct?: { [key: string]: number; } | undefined;
    testsByResult?: { [key: string]: number; } | undefined;
    lastTestRun?: Date | undefined;
    firstTestRun?: Date | undefined;
    averageExecutionTimeMs?: number;
    uniqueAlertRulesTested?: number;
    uniqueProductsTested?: number;
    dailyTestCounts?: { [key: string]: number; } | undefined;
    periodStart?: Date | undefined;
    periodEnd?: Date | undefined;
}

export class AlertTestingStatsDtoApiResponse implements IAlertTestingStatsDtoApiResponse {
    success?: boolean;
    data?: AlertTestingStatsDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IAlertTestingStatsDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"] ? AlertTestingStatsDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): AlertTestingStatsDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AlertTestingStatsDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IAlertTestingStatsDtoApiResponse {
    success?: boolean;
    data?: AlertTestingStatsDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class ApiResponse implements IApiResponse {
    success?: boolean;
    data?: any | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"];
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): ApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IApiResponse {
    success?: boolean;
    data?: any | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class BooleanApiResponse implements IBooleanApiResponse {
    success?: boolean;
    data?: boolean;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IBooleanApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"];
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): BooleanApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new BooleanApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IBooleanApiResponse {
    success?: boolean;
    data?: boolean;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class BrowserActionGenerationRequestDto implements IBrowserActionGenerationRequestDto {
    instructions!: string;
    context?: string | undefined;
    aiConfigurationId?: string | undefined;

    constructor(data?: IBrowserActionGenerationRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.instructions = _data["instructions"];
            this.context = _data["context"];
            this.aiConfigurationId = _data["aiConfigurationId"];
        }
    }

    static fromJS(data: any): BrowserActionGenerationRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new BrowserActionGenerationRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["instructions"] = this.instructions;
        data["context"] = this.context;
        data["aiConfigurationId"] = this.aiConfigurationId;
        return data;
    }
}

export interface IBrowserActionGenerationRequestDto {
    instructions: string;
    context?: string | undefined;
    aiConfigurationId?: string | undefined;
}

export class BrowserActionGenerationResponseDto implements IBrowserActionGenerationResponseDto {
    actions?: GeneratedBrowserAction[] | undefined;
    explanation?: string | undefined;
    tokensUsed?: number;
    model?: string | undefined;
    success?: boolean;
    errorMessage?: string | undefined;

    constructor(data?: IBrowserActionGenerationResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["actions"])) {
                this.actions = [] as any;
                for (let item of _data["actions"])
                    this.actions!.push(GeneratedBrowserAction.fromJS(item));
            }
            this.explanation = _data["explanation"];
            this.tokensUsed = _data["tokensUsed"];
            this.model = _data["model"];
            this.success = _data["success"];
            this.errorMessage = _data["errorMessage"];
        }
    }

    static fromJS(data: any): BrowserActionGenerationResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new BrowserActionGenerationResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.actions)) {
            data["actions"] = [];
            for (let item of this.actions)
                data["actions"].push(item ? item.toJSON() : <any>undefined);
        }
        data["explanation"] = this.explanation;
        data["tokensUsed"] = this.tokensUsed;
        data["model"] = this.model;
        data["success"] = this.success;
        data["errorMessage"] = this.errorMessage;
        return data;
    }
}

export interface IBrowserActionGenerationResponseDto {
    actions?: GeneratedBrowserAction[] | undefined;
    explanation?: string | undefined;
    tokensUsed?: number;
    model?: string | undefined;
    success?: boolean;
    errorMessage?: string | undefined;
}

export class BrowserActionGenerationResponseDtoApiResponse implements IBrowserActionGenerationResponseDtoApiResponse {
    success?: boolean;
    data?: BrowserActionGenerationResponseDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IBrowserActionGenerationResponseDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"] ? BrowserActionGenerationResponseDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): BrowserActionGenerationResponseDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new BrowserActionGenerationResponseDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IBrowserActionGenerationResponseDtoApiResponse {
    success?: boolean;
    data?: BrowserActionGenerationResponseDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class BrowserAutomationActionDto implements IBrowserAutomationActionDto {
    actionType?: string | undefined;
    selector?: string | undefined;
    value?: string | undefined;
    delayMs?: number | undefined;
    repeat?: number | undefined;
    options?: { [key: string]: any; } | undefined;

    constructor(data?: IBrowserAutomationActionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.actionType = _data["actionType"];
            this.selector = _data["selector"];
            this.value = _data["value"];
            this.delayMs = _data["delayMs"];
            this.repeat = _data["repeat"];
            if (_data["options"]) {
                this.options = {} as any;
                for (let key in _data["options"]) {
                    if (_data["options"].hasOwnProperty(key))
                        (<any>this.options)![key] = _data["options"][key];
                }
            }
        }
    }

    static fromJS(data: any): BrowserAutomationActionDto {
        data = typeof data === 'object' ? data : {};
        let result = new BrowserAutomationActionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["actionType"] = this.actionType;
        data["selector"] = this.selector;
        data["value"] = this.value;
        data["delayMs"] = this.delayMs;
        data["repeat"] = this.repeat;
        if (this.options) {
            data["options"] = {};
            for (let key in this.options) {
                if (this.options.hasOwnProperty(key))
                    (<any>data["options"])[key] = (<any>this.options)[key];
            }
        }
        return data;
    }
}

export interface IBrowserAutomationActionDto {
    actionType?: string | undefined;
    selector?: string | undefined;
    value?: string | undefined;
    delayMs?: number | undefined;
    repeat?: number | undefined;
    options?: { [key: string]: any; } | undefined;
}

export class BrowserAutomationProfileDto implements IBrowserAutomationProfileDto {
    preferredBrowser?: string | undefined;
    waitTimeMs?: number | undefined;
    actions?: BrowserAutomationActionDto[] | undefined;
    timeoutSeconds?: number | undefined;
    userAgent?: string | undefined;
    headers?: { [key: string]: string; } | undefined;
    proxyServer?: string | undefined;
    proxyUsername?: string | undefined;
    proxyPassword?: string | undefined;

    constructor(data?: IBrowserAutomationProfileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.preferredBrowser = _data["preferredBrowser"];
            this.waitTimeMs = _data["waitTimeMs"];
            if (Array.isArray(_data["actions"])) {
                this.actions = [] as any;
                for (let item of _data["actions"])
                    this.actions!.push(BrowserAutomationActionDto.fromJS(item));
            }
            this.timeoutSeconds = _data["timeoutSeconds"];
            this.userAgent = _data["userAgent"];
            if (_data["headers"]) {
                this.headers = {} as any;
                for (let key in _data["headers"]) {
                    if (_data["headers"].hasOwnProperty(key))
                        (<any>this.headers)![key] = _data["headers"][key];
                }
            }
            this.proxyServer = _data["proxyServer"];
            this.proxyUsername = _data["proxyUsername"];
            this.proxyPassword = _data["proxyPassword"];
        }
    }

    static fromJS(data: any): BrowserAutomationProfileDto {
        data = typeof data === 'object' ? data : {};
        let result = new BrowserAutomationProfileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["preferredBrowser"] = this.preferredBrowser;
        data["waitTimeMs"] = this.waitTimeMs;
        if (Array.isArray(this.actions)) {
            data["actions"] = [];
            for (let item of this.actions)
                data["actions"].push(item ? item.toJSON() : <any>undefined);
        }
        data["timeoutSeconds"] = this.timeoutSeconds;
        data["userAgent"] = this.userAgent;
        if (this.headers) {
            data["headers"] = {};
            for (let key in this.headers) {
                if (this.headers.hasOwnProperty(key))
                    (<any>data["headers"])[key] = (<any>this.headers)[key];
            }
        }
        data["proxyServer"] = this.proxyServer;
        data["proxyUsername"] = this.proxyUsername;
        data["proxyPassword"] = this.proxyPassword;
        return data;
    }
}

export interface IBrowserAutomationProfileDto {
    preferredBrowser?: string | undefined;
    waitTimeMs?: number | undefined;
    actions?: BrowserAutomationActionDto[] | undefined;
    timeoutSeconds?: number | undefined;
    userAgent?: string | undefined;
    headers?: { [key: string]: string; } | undefined;
    proxyServer?: string | undefined;
    proxyUsername?: string | undefined;
    proxyPassword?: string | undefined;
}

export class BrowserAutomationTestRequestDto implements IBrowserAutomationTestRequestDto {
    testUrl?: string | undefined;
    profile?: BrowserAutomationProfileDto;
    options?: BrowserTestOptionsDto;
    saveResults?: boolean;
    sessionName?: string | undefined;

    constructor(data?: IBrowserAutomationTestRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.testUrl = _data["testUrl"];
            this.profile = _data["profile"] ? BrowserAutomationProfileDto.fromJS(_data["profile"]) : <any>undefined;
            this.options = _data["options"] ? BrowserTestOptionsDto.fromJS(_data["options"]) : <any>undefined;
            this.saveResults = _data["saveResults"];
            this.sessionName = _data["sessionName"];
        }
    }

    static fromJS(data: any): BrowserAutomationTestRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new BrowserAutomationTestRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["testUrl"] = this.testUrl;
        data["profile"] = this.profile ? this.profile.toJSON() : <any>undefined;
        data["options"] = this.options ? this.options.toJSON() : <any>undefined;
        data["saveResults"] = this.saveResults;
        data["sessionName"] = this.sessionName;
        return data;
    }
}

export interface IBrowserAutomationTestRequestDto {
    testUrl?: string | undefined;
    profile?: BrowserAutomationProfileDto;
    options?: BrowserTestOptionsDto;
    saveResults?: boolean;
    sessionName?: string | undefined;
}

export class BrowserAutomationTestResultDto implements IBrowserAutomationTestResultDto {
    sessionId?: string | undefined;
    testUrl?: string | undefined;
    success?: boolean;
    startedAt?: Date;
    completedAt?: Date | undefined;
    duration?: number;
    profile?: BrowserAutomationProfileDto;
    options?: BrowserTestOptionsDto;
    actionsExecuted?: number;
    actionResults?: ActionExecutionResultDto[] | undefined;
    finalScreenshot?: string | undefined;
    videoRecording?: string | undefined;
    screenshots?: ScreenshotCaptureDto[] | undefined;
    metrics?: ExecutionMetricsDto;
    networkRequests?: NetworkRequestDto[] | undefined;
    consoleMessages?: ConsoleMessageDto[] | undefined;
    errors?: TestErrorDto[] | undefined;
    warnings?: TestWarningDto[] | undefined;
    extractedData?: { [key: string]: any; } | undefined;

    constructor(data?: IBrowserAutomationTestResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sessionId = _data["sessionId"];
            this.testUrl = _data["testUrl"];
            this.success = _data["success"];
            this.startedAt = _data["startedAt"] ? new Date(_data["startedAt"].toString()) : <any>undefined;
            this.completedAt = _data["completedAt"] ? new Date(_data["completedAt"].toString()) : <any>undefined;
            this.duration = _data["duration"];
            this.profile = _data["profile"] ? BrowserAutomationProfileDto.fromJS(_data["profile"]) : <any>undefined;
            this.options = _data["options"] ? BrowserTestOptionsDto.fromJS(_data["options"]) : <any>undefined;
            this.actionsExecuted = _data["actionsExecuted"];
            if (Array.isArray(_data["actionResults"])) {
                this.actionResults = [] as any;
                for (let item of _data["actionResults"])
                    this.actionResults!.push(ActionExecutionResultDto.fromJS(item));
            }
            this.finalScreenshot = _data["finalScreenshot"];
            this.videoRecording = _data["videoRecording"];
            if (Array.isArray(_data["screenshots"])) {
                this.screenshots = [] as any;
                for (let item of _data["screenshots"])
                    this.screenshots!.push(ScreenshotCaptureDto.fromJS(item));
            }
            this.metrics = _data["metrics"] ? ExecutionMetricsDto.fromJS(_data["metrics"]) : <any>undefined;
            if (Array.isArray(_data["networkRequests"])) {
                this.networkRequests = [] as any;
                for (let item of _data["networkRequests"])
                    this.networkRequests!.push(NetworkRequestDto.fromJS(item));
            }
            if (Array.isArray(_data["consoleMessages"])) {
                this.consoleMessages = [] as any;
                for (let item of _data["consoleMessages"])
                    this.consoleMessages!.push(ConsoleMessageDto.fromJS(item));
            }
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(TestErrorDto.fromJS(item));
            }
            if (Array.isArray(_data["warnings"])) {
                this.warnings = [] as any;
                for (let item of _data["warnings"])
                    this.warnings!.push(TestWarningDto.fromJS(item));
            }
            if (_data["extractedData"]) {
                this.extractedData = {} as any;
                for (let key in _data["extractedData"]) {
                    if (_data["extractedData"].hasOwnProperty(key))
                        (<any>this.extractedData)![key] = _data["extractedData"][key];
                }
            }
        }
    }

    static fromJS(data: any): BrowserAutomationTestResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new BrowserAutomationTestResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sessionId"] = this.sessionId;
        data["testUrl"] = this.testUrl;
        data["success"] = this.success;
        data["startedAt"] = this.startedAt ? this.startedAt.toISOString() : <any>undefined;
        data["completedAt"] = this.completedAt ? this.completedAt.toISOString() : <any>undefined;
        data["duration"] = this.duration;
        data["profile"] = this.profile ? this.profile.toJSON() : <any>undefined;
        data["options"] = this.options ? this.options.toJSON() : <any>undefined;
        data["actionsExecuted"] = this.actionsExecuted;
        if (Array.isArray(this.actionResults)) {
            data["actionResults"] = [];
            for (let item of this.actionResults)
                data["actionResults"].push(item ? item.toJSON() : <any>undefined);
        }
        data["finalScreenshot"] = this.finalScreenshot;
        data["videoRecording"] = this.videoRecording;
        if (Array.isArray(this.screenshots)) {
            data["screenshots"] = [];
            for (let item of this.screenshots)
                data["screenshots"].push(item ? item.toJSON() : <any>undefined);
        }
        data["metrics"] = this.metrics ? this.metrics.toJSON() : <any>undefined;
        if (Array.isArray(this.networkRequests)) {
            data["networkRequests"] = [];
            for (let item of this.networkRequests)
                data["networkRequests"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.consoleMessages)) {
            data["consoleMessages"] = [];
            for (let item of this.consoleMessages)
                data["consoleMessages"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.warnings)) {
            data["warnings"] = [];
            for (let item of this.warnings)
                data["warnings"].push(item ? item.toJSON() : <any>undefined);
        }
        if (this.extractedData) {
            data["extractedData"] = {};
            for (let key in this.extractedData) {
                if (this.extractedData.hasOwnProperty(key))
                    (<any>data["extractedData"])[key] = (<any>this.extractedData)[key];
            }
        }
        return data;
    }
}

export interface IBrowserAutomationTestResultDto {
    sessionId?: string | undefined;
    testUrl?: string | undefined;
    success?: boolean;
    startedAt?: Date;
    completedAt?: Date | undefined;
    duration?: number;
    profile?: BrowserAutomationProfileDto;
    options?: BrowserTestOptionsDto;
    actionsExecuted?: number;
    actionResults?: ActionExecutionResultDto[] | undefined;
    finalScreenshot?: string | undefined;
    videoRecording?: string | undefined;
    screenshots?: ScreenshotCaptureDto[] | undefined;
    metrics?: ExecutionMetricsDto;
    networkRequests?: NetworkRequestDto[] | undefined;
    consoleMessages?: ConsoleMessageDto[] | undefined;
    errors?: TestErrorDto[] | undefined;
    warnings?: TestWarningDto[] | undefined;
    extractedData?: { [key: string]: any; } | undefined;
}

export class BrowserAutomationTestResultDtoApiResponse implements IBrowserAutomationTestResultDtoApiResponse {
    success?: boolean;
    data?: BrowserAutomationTestResultDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IBrowserAutomationTestResultDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"] ? BrowserAutomationTestResultDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): BrowserAutomationTestResultDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new BrowserAutomationTestResultDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IBrowserAutomationTestResultDtoApiResponse {
    success?: boolean;
    data?: BrowserAutomationTestResultDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class BrowserTestOptionsDto implements IBrowserTestOptionsDto {
    recordVideo?: boolean;
    captureScreenshots?: boolean;
    slowMotion?: number;
    headless?: boolean;
    enableNetworkLogging?: boolean;
    enableConsoleLogging?: boolean;
    enablePerformanceLogging?: boolean;
    viewportWidth?: number;
    viewportHeight?: number;
    deviceEmulation?: string | undefined;
    testTimeoutMs?: number;
    actionTimeoutMs?: number;
    navigationTimeoutMs?: number;

    constructor(data?: IBrowserTestOptionsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.recordVideo = _data["recordVideo"];
            this.captureScreenshots = _data["captureScreenshots"];
            this.slowMotion = _data["slowMotion"];
            this.headless = _data["headless"];
            this.enableNetworkLogging = _data["enableNetworkLogging"];
            this.enableConsoleLogging = _data["enableConsoleLogging"];
            this.enablePerformanceLogging = _data["enablePerformanceLogging"];
            this.viewportWidth = _data["viewportWidth"];
            this.viewportHeight = _data["viewportHeight"];
            this.deviceEmulation = _data["deviceEmulation"];
            this.testTimeoutMs = _data["testTimeoutMs"];
            this.actionTimeoutMs = _data["actionTimeoutMs"];
            this.navigationTimeoutMs = _data["navigationTimeoutMs"];
        }
    }

    static fromJS(data: any): BrowserTestOptionsDto {
        data = typeof data === 'object' ? data : {};
        let result = new BrowserTestOptionsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["recordVideo"] = this.recordVideo;
        data["captureScreenshots"] = this.captureScreenshots;
        data["slowMotion"] = this.slowMotion;
        data["headless"] = this.headless;
        data["enableNetworkLogging"] = this.enableNetworkLogging;
        data["enableConsoleLogging"] = this.enableConsoleLogging;
        data["enablePerformanceLogging"] = this.enablePerformanceLogging;
        data["viewportWidth"] = this.viewportWidth;
        data["viewportHeight"] = this.viewportHeight;
        data["deviceEmulation"] = this.deviceEmulation;
        data["testTimeoutMs"] = this.testTimeoutMs;
        data["actionTimeoutMs"] = this.actionTimeoutMs;
        data["navigationTimeoutMs"] = this.navigationTimeoutMs;
        return data;
    }
}

export interface IBrowserTestOptionsDto {
    recordVideo?: boolean;
    captureScreenshots?: boolean;
    slowMotion?: number;
    headless?: boolean;
    enableNetworkLogging?: boolean;
    enableConsoleLogging?: boolean;
    enablePerformanceLogging?: boolean;
    viewportWidth?: number;
    viewportHeight?: number;
    deviceEmulation?: string | undefined;
    testTimeoutMs?: number;
    actionTimeoutMs?: number;
    navigationTimeoutMs?: number;
}

export class BrowserTestSessionDto implements IBrowserTestSessionDto {
    id?: string | undefined;
    testUrl?: string | undefined;
    profile?: BrowserAutomationProfileDto;
    options?: BrowserTestOptionsDto;
    status?: string | undefined;
    startedAt?: Date;
    completedAt?: Date | undefined;
    sessionName?: string | undefined;
    webSocketUrl?: string | undefined;

    constructor(data?: IBrowserTestSessionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.testUrl = _data["testUrl"];
            this.profile = _data["profile"] ? BrowserAutomationProfileDto.fromJS(_data["profile"]) : <any>undefined;
            this.options = _data["options"] ? BrowserTestOptionsDto.fromJS(_data["options"]) : <any>undefined;
            this.status = _data["status"];
            this.startedAt = _data["startedAt"] ? new Date(_data["startedAt"].toString()) : <any>undefined;
            this.completedAt = _data["completedAt"] ? new Date(_data["completedAt"].toString()) : <any>undefined;
            this.sessionName = _data["sessionName"];
            this.webSocketUrl = _data["webSocketUrl"];
        }
    }

    static fromJS(data: any): BrowserTestSessionDto {
        data = typeof data === 'object' ? data : {};
        let result = new BrowserTestSessionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["testUrl"] = this.testUrl;
        data["profile"] = this.profile ? this.profile.toJSON() : <any>undefined;
        data["options"] = this.options ? this.options.toJSON() : <any>undefined;
        data["status"] = this.status;
        data["startedAt"] = this.startedAt ? this.startedAt.toISOString() : <any>undefined;
        data["completedAt"] = this.completedAt ? this.completedAt.toISOString() : <any>undefined;
        data["sessionName"] = this.sessionName;
        data["webSocketUrl"] = this.webSocketUrl;
        return data;
    }
}

export interface IBrowserTestSessionDto {
    id?: string | undefined;
    testUrl?: string | undefined;
    profile?: BrowserAutomationProfileDto;
    options?: BrowserTestOptionsDto;
    status?: string | undefined;
    startedAt?: Date;
    completedAt?: Date | undefined;
    sessionName?: string | undefined;
    webSocketUrl?: string | undefined;
}

export class BrowserTestSessionDtoApiResponse implements IBrowserTestSessionDtoApiResponse {
    success?: boolean;
    data?: BrowserTestSessionDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IBrowserTestSessionDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"] ? BrowserTestSessionDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): BrowserTestSessionDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new BrowserTestSessionDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IBrowserTestSessionDtoApiResponse {
    success?: boolean;
    data?: BrowserTestSessionDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class BrowserTestSessionDtoListApiResponse implements IBrowserTestSessionDtoListApiResponse {
    success?: boolean;
    data?: BrowserTestSessionDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IBrowserTestSessionDtoListApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(BrowserTestSessionDto.fromJS(item));
            }
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): BrowserTestSessionDtoListApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new BrowserTestSessionDtoListApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : <any>undefined);
        }
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IBrowserTestSessionDtoListApiResponse {
    success?: boolean;
    data?: BrowserTestSessionDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class BulkDeleteResultDto implements IBulkDeleteResultDto {
    totalRequested?: number;
    successfullyDeleted?: number;
    failedToDelete?: number;
    errors?: string[] | undefined;

    constructor(data?: IBulkDeleteResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalRequested = _data["totalRequested"];
            this.successfullyDeleted = _data["successfullyDeleted"];
            this.failedToDelete = _data["failedToDelete"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): BulkDeleteResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new BulkDeleteResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalRequested"] = this.totalRequested;
        data["successfullyDeleted"] = this.successfullyDeleted;
        data["failedToDelete"] = this.failedToDelete;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IBulkDeleteResultDto {
    totalRequested?: number;
    successfullyDeleted?: number;
    failedToDelete?: number;
    errors?: string[] | undefined;
}

export class BulkDeleteResultDtoApiResponse implements IBulkDeleteResultDtoApiResponse {
    success?: boolean;
    data?: BulkDeleteResultDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IBulkDeleteResultDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"] ? BulkDeleteResultDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): BulkDeleteResultDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new BulkDeleteResultDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IBulkDeleteResultDtoApiResponse {
    success?: boolean;
    data?: BulkDeleteResultDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class BulkDeleteTestResultsRequestDto implements IBulkDeleteTestResultsRequestDto {
    resultIds?: string[] | undefined;

    constructor(data?: IBulkDeleteTestResultsRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["resultIds"])) {
                this.resultIds = [] as any;
                for (let item of _data["resultIds"])
                    this.resultIds!.push(item);
            }
        }
    }

    static fromJS(data: any): BulkDeleteTestResultsRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new BulkDeleteTestResultsRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.resultIds)) {
            data["resultIds"] = [];
            for (let item of this.resultIds)
                data["resultIds"].push(item);
        }
        return data;
    }
}

export interface IBulkDeleteTestResultsRequestDto {
    resultIds?: string[] | undefined;
}

export class BulkProxyActiveStatusDto implements IBulkProxyActiveStatusDto {
    proxyIds?: string[] | undefined;
    isActive?: boolean;

    constructor(data?: IBulkProxyActiveStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["proxyIds"])) {
                this.proxyIds = [] as any;
                for (let item of _data["proxyIds"])
                    this.proxyIds!.push(item);
            }
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): BulkProxyActiveStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new BulkProxyActiveStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.proxyIds)) {
            data["proxyIds"] = [];
            for (let item of this.proxyIds)
                data["proxyIds"].push(item);
        }
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IBulkProxyActiveStatusDto {
    proxyIds?: string[] | undefined;
    isActive?: boolean;
}

export class BulkProxyImportDto implements IBulkProxyImportDto {
    proxies!: ProxyImportItemDto[];
    testBeforeImport?: boolean;
    overwriteExisting?: boolean;

    constructor(data?: IBulkProxyImportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.proxies = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["proxies"])) {
                this.proxies = [] as any;
                for (let item of _data["proxies"])
                    this.proxies!.push(ProxyImportItemDto.fromJS(item));
            }
            this.testBeforeImport = _data["testBeforeImport"];
            this.overwriteExisting = _data["overwriteExisting"];
        }
    }

    static fromJS(data: any): BulkProxyImportDto {
        data = typeof data === 'object' ? data : {};
        let result = new BulkProxyImportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.proxies)) {
            data["proxies"] = [];
            for (let item of this.proxies)
                data["proxies"].push(item ? item.toJSON() : <any>undefined);
        }
        data["testBeforeImport"] = this.testBeforeImport;
        data["overwriteExisting"] = this.overwriteExisting;
        return data;
    }
}

export interface IBulkProxyImportDto {
    proxies: ProxyImportItemDto[];
    testBeforeImport?: boolean;
    overwriteExisting?: boolean;
}

export class BulkProxyImportResultDto implements IBulkProxyImportResultDto {
    totalProcessed?: number;
    successfulImports?: number;
    failedImports?: number;
    skippedDuplicates?: number;
    errors?: string[] | undefined;
    importedProxies?: ProxyConfigurationDto[] | undefined;

    constructor(data?: IBulkProxyImportResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalProcessed = _data["totalProcessed"];
            this.successfulImports = _data["successfulImports"];
            this.failedImports = _data["failedImports"];
            this.skippedDuplicates = _data["skippedDuplicates"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            if (Array.isArray(_data["importedProxies"])) {
                this.importedProxies = [] as any;
                for (let item of _data["importedProxies"])
                    this.importedProxies!.push(ProxyConfigurationDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BulkProxyImportResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new BulkProxyImportResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalProcessed"] = this.totalProcessed;
        data["successfulImports"] = this.successfulImports;
        data["failedImports"] = this.failedImports;
        data["skippedDuplicates"] = this.skippedDuplicates;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        if (Array.isArray(this.importedProxies)) {
            data["importedProxies"] = [];
            for (let item of this.importedProxies)
                data["importedProxies"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface IBulkProxyImportResultDto {
    totalProcessed?: number;
    successfulImports?: number;
    failedImports?: number;
    skippedDuplicates?: number;
    errors?: string[] | undefined;
    importedProxies?: ProxyConfigurationDto[] | undefined;
}

export class BulkProxyImportResultDtoApiResponse implements IBulkProxyImportResultDtoApiResponse {
    success?: boolean;
    data?: BulkProxyImportResultDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IBulkProxyImportResultDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"] ? BulkProxyImportResultDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): BulkProxyImportResultDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new BulkProxyImportResultDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IBulkProxyImportResultDtoApiResponse {
    success?: boolean;
    data?: BulkProxyImportResultDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class BulkProxyImportValidationDto implements IBulkProxyImportValidationDto {
    totalProxies?: number;
    validProxies?: number;
    invalidProxies?: number;
    duplicateProxies?: number;
    proxiesToImport?: ProxyImportItemDto[] | undefined;
    validationErrors?: string[] | undefined;

    constructor(data?: IBulkProxyImportValidationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalProxies = _data["totalProxies"];
            this.validProxies = _data["validProxies"];
            this.invalidProxies = _data["invalidProxies"];
            this.duplicateProxies = _data["duplicateProxies"];
            if (Array.isArray(_data["proxiesToImport"])) {
                this.proxiesToImport = [] as any;
                for (let item of _data["proxiesToImport"])
                    this.proxiesToImport!.push(ProxyImportItemDto.fromJS(item));
            }
            if (Array.isArray(_data["validationErrors"])) {
                this.validationErrors = [] as any;
                for (let item of _data["validationErrors"])
                    this.validationErrors!.push(item);
            }
        }
    }

    static fromJS(data: any): BulkProxyImportValidationDto {
        data = typeof data === 'object' ? data : {};
        let result = new BulkProxyImportValidationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalProxies"] = this.totalProxies;
        data["validProxies"] = this.validProxies;
        data["invalidProxies"] = this.invalidProxies;
        data["duplicateProxies"] = this.duplicateProxies;
        if (Array.isArray(this.proxiesToImport)) {
            data["proxiesToImport"] = [];
            for (let item of this.proxiesToImport)
                data["proxiesToImport"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.validationErrors)) {
            data["validationErrors"] = [];
            for (let item of this.validationErrors)
                data["validationErrors"].push(item);
        }
        return data;
    }
}

export interface IBulkProxyImportValidationDto {
    totalProxies?: number;
    validProxies?: number;
    invalidProxies?: number;
    duplicateProxies?: number;
    proxiesToImport?: ProxyImportItemDto[] | undefined;
    validationErrors?: string[] | undefined;
}

export class BulkProxyImportValidationDtoApiResponse implements IBulkProxyImportValidationDtoApiResponse {
    success?: boolean;
    data?: BulkProxyImportValidationDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IBulkProxyImportValidationDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"] ? BulkProxyImportValidationDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): BulkProxyImportValidationDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new BulkProxyImportValidationDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IBulkProxyImportValidationDtoApiResponse {
    success?: boolean;
    data?: BulkProxyImportValidationDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class BulkProxyTestDto implements IBulkProxyTestDto {
    proxyIds!: string[];
    testUrl?: string | undefined;
    timeoutSeconds?: number;

    constructor(data?: IBulkProxyTestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.proxyIds = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["proxyIds"])) {
                this.proxyIds = [] as any;
                for (let item of _data["proxyIds"])
                    this.proxyIds!.push(item);
            }
            this.testUrl = _data["testUrl"];
            this.timeoutSeconds = _data["timeoutSeconds"];
        }
    }

    static fromJS(data: any): BulkProxyTestDto {
        data = typeof data === 'object' ? data : {};
        let result = new BulkProxyTestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.proxyIds)) {
            data["proxyIds"] = [];
            for (let item of this.proxyIds)
                data["proxyIds"].push(item);
        }
        data["testUrl"] = this.testUrl;
        data["timeoutSeconds"] = this.timeoutSeconds;
        return data;
    }
}

export interface IBulkProxyTestDto {
    proxyIds: string[];
    testUrl?: string | undefined;
    timeoutSeconds?: number;
}

export class CategoryDto implements ICategoryDto {
    categoryId?: string;
    name?: string | undefined;
    slug?: string | undefined;
    description?: string | undefined;
    createdAt?: Date;
    updatedAt?: Date;

    constructor(data?: ICategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.categoryId = _data["categoryId"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.description = _data["description"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["categoryId"] = this.categoryId;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["description"] = this.description;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        return data;
    }
}

export interface ICategoryDto {
    categoryId?: string;
    name?: string | undefined;
    slug?: string | undefined;
    description?: string | undefined;
    createdAt?: Date;
    updatedAt?: Date;
}

export class CategoryDtoApiResponse implements ICategoryDtoApiResponse {
    success?: boolean;
    data?: CategoryDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: ICategoryDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"] ? CategoryDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): CategoryDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface ICategoryDtoApiResponse {
    success?: boolean;
    data?: CategoryDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class CategoryDtoIEnumerableApiResponse implements ICategoryDtoIEnumerableApiResponse {
    success?: boolean;
    data?: CategoryDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: ICategoryDtoIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(CategoryDto.fromJS(item));
            }
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): CategoryDtoIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryDtoIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : <any>undefined);
        }
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface ICategoryDtoIEnumerableApiResponse {
    success?: boolean;
    data?: CategoryDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class CategoryScoreDto implements ICategoryScoreDto {
    categoryName?: string | undefined;
    product1Score?: number;
    product2Score?: number;
    weight?: number;
    analysis?: string | undefined;

    constructor(data?: ICategoryScoreDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.categoryName = _data["categoryName"];
            this.product1Score = _data["product1Score"];
            this.product2Score = _data["product2Score"];
            this.weight = _data["weight"];
            this.analysis = _data["analysis"];
        }
    }

    static fromJS(data: any): CategoryScoreDto {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryScoreDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["categoryName"] = this.categoryName;
        data["product1Score"] = this.product1Score;
        data["product2Score"] = this.product2Score;
        data["weight"] = this.weight;
        data["analysis"] = this.analysis;
        return data;
    }
}

export interface ICategoryScoreDto {
    categoryName?: string | undefined;
    product1Score?: number;
    product2Score?: number;
    weight?: number;
    analysis?: string | undefined;
}

export class CompareProductsRequestDto implements ICompareProductsRequestDto {
    productId1!: string;
    productId2!: string;
    specificationWeights?: { [key: string]: number; } | undefined;
    includePriceAnalysis?: boolean;
    generateRecommendations?: boolean;

    constructor(data?: ICompareProductsRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId1 = _data["productId1"];
            this.productId2 = _data["productId2"];
            if (_data["specificationWeights"]) {
                this.specificationWeights = {} as any;
                for (let key in _data["specificationWeights"]) {
                    if (_data["specificationWeights"].hasOwnProperty(key))
                        (<any>this.specificationWeights)![key] = _data["specificationWeights"][key];
                }
            }
            this.includePriceAnalysis = _data["includePriceAnalysis"];
            this.generateRecommendations = _data["generateRecommendations"];
        }
    }

    static fromJS(data: any): CompareProductsRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new CompareProductsRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId1"] = this.productId1;
        data["productId2"] = this.productId2;
        if (this.specificationWeights) {
            data["specificationWeights"] = {};
            for (let key in this.specificationWeights) {
                if (this.specificationWeights.hasOwnProperty(key))
                    (<any>data["specificationWeights"])[key] = (<any>this.specificationWeights)[key];
            }
        }
        data["includePriceAnalysis"] = this.includePriceAnalysis;
        data["generateRecommendations"] = this.generateRecommendations;
        return data;
    }
}

export interface ICompareProductsRequestDto {
    productId1: string;
    productId2: string;
    specificationWeights?: { [key: string]: number; } | undefined;
    includePriceAnalysis?: boolean;
    generateRecommendations?: boolean;
}

export class CompareTestResultsRequestDto implements ICompareTestResultsRequestDto {
    firstResultId?: string | undefined;
    secondResultId?: string | undefined;
    includeScreenshots?: boolean;
    includeNetworkData?: boolean;
    includeDetailedDifferences?: boolean;

    constructor(data?: ICompareTestResultsRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firstResultId = _data["firstResultId"];
            this.secondResultId = _data["secondResultId"];
            this.includeScreenshots = _data["includeScreenshots"];
            this.includeNetworkData = _data["includeNetworkData"];
            this.includeDetailedDifferences = _data["includeDetailedDifferences"];
        }
    }

    static fromJS(data: any): CompareTestResultsRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new CompareTestResultsRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstResultId"] = this.firstResultId;
        data["secondResultId"] = this.secondResultId;
        data["includeScreenshots"] = this.includeScreenshots;
        data["includeNetworkData"] = this.includeNetworkData;
        data["includeDetailedDifferences"] = this.includeDetailedDifferences;
        return data;
    }
}

export interface ICompareTestResultsRequestDto {
    firstResultId?: string | undefined;
    secondResultId?: string | undefined;
    includeScreenshots?: boolean;
    includeNetworkData?: boolean;
    includeDetailedDifferences?: boolean;
}

export enum ComparisonResultType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
}

export enum ComparisonTrend {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export class ConsoleMessageDto implements IConsoleMessageDto {
    level?: string | undefined;
    message?: string | undefined;
    source?: string | undefined;
    lineNumber?: number | undefined;
    timestamp?: Date;

    constructor(data?: IConsoleMessageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.level = _data["level"];
            this.message = _data["message"];
            this.source = _data["source"];
            this.lineNumber = _data["lineNumber"];
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ConsoleMessageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConsoleMessageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["level"] = this.level;
        data["message"] = this.message;
        data["source"] = this.source;
        data["lineNumber"] = this.lineNumber;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        return data;
    }
}

export interface IConsoleMessageDto {
    level?: string | undefined;
    message?: string | undefined;
    source?: string | undefined;
    lineNumber?: number | undefined;
    timestamp?: Date;
}

export class CreateAiConfigurationDto implements ICreateAiConfigurationDto {
    provider!: string;
    name!: string;
    description?: string | undefined;
    openApiCompatibleUrl?: string | undefined;
    apiKey!: string;
    model!: string;
    inputTokenLimit?: number | undefined;
    outputTokenLimit?: number | undefined;
    capabilities?: string[] | undefined;
    supportedInputTypes?: string[] | undefined;
    supportedOutputTypes?: string[] | undefined;
    rateLimitRpm?: number | undefined;
    rateLimitTpm?: number | undefined;
    rateLimitRpd?: number | undefined;
    isActive?: boolean;
    isDefault?: boolean;

    constructor(data?: ICreateAiConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.provider = _data["provider"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.openApiCompatibleUrl = _data["openApiCompatibleUrl"];
            this.apiKey = _data["apiKey"];
            this.model = _data["model"];
            this.inputTokenLimit = _data["inputTokenLimit"];
            this.outputTokenLimit = _data["outputTokenLimit"];
            if (Array.isArray(_data["capabilities"])) {
                this.capabilities = [] as any;
                for (let item of _data["capabilities"])
                    this.capabilities!.push(item);
            }
            if (Array.isArray(_data["supportedInputTypes"])) {
                this.supportedInputTypes = [] as any;
                for (let item of _data["supportedInputTypes"])
                    this.supportedInputTypes!.push(item);
            }
            if (Array.isArray(_data["supportedOutputTypes"])) {
                this.supportedOutputTypes = [] as any;
                for (let item of _data["supportedOutputTypes"])
                    this.supportedOutputTypes!.push(item);
            }
            this.rateLimitRpm = _data["rateLimitRpm"];
            this.rateLimitTpm = _data["rateLimitTpm"];
            this.rateLimitRpd = _data["rateLimitRpd"];
            this.isActive = _data["isActive"];
            this.isDefault = _data["isDefault"];
        }
    }

    static fromJS(data: any): CreateAiConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAiConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["provider"] = this.provider;
        data["name"] = this.name;
        data["description"] = this.description;
        data["openApiCompatibleUrl"] = this.openApiCompatibleUrl;
        data["apiKey"] = this.apiKey;
        data["model"] = this.model;
        data["inputTokenLimit"] = this.inputTokenLimit;
        data["outputTokenLimit"] = this.outputTokenLimit;
        if (Array.isArray(this.capabilities)) {
            data["capabilities"] = [];
            for (let item of this.capabilities)
                data["capabilities"].push(item);
        }
        if (Array.isArray(this.supportedInputTypes)) {
            data["supportedInputTypes"] = [];
            for (let item of this.supportedInputTypes)
                data["supportedInputTypes"].push(item);
        }
        if (Array.isArray(this.supportedOutputTypes)) {
            data["supportedOutputTypes"] = [];
            for (let item of this.supportedOutputTypes)
                data["supportedOutputTypes"].push(item);
        }
        data["rateLimitRpm"] = this.rateLimitRpm;
        data["rateLimitTpm"] = this.rateLimitTpm;
        data["rateLimitRpd"] = this.rateLimitRpd;
        data["isActive"] = this.isActive;
        data["isDefault"] = this.isDefault;
        return data;
    }
}

export interface ICreateAiConfigurationDto {
    provider: string;
    name: string;
    description?: string | undefined;
    openApiCompatibleUrl?: string | undefined;
    apiKey: string;
    model: string;
    inputTokenLimit?: number | undefined;
    outputTokenLimit?: number | undefined;
    capabilities?: string[] | undefined;
    supportedInputTypes?: string[] | undefined;
    supportedOutputTypes?: string[] | undefined;
    rateLimitRpm?: number | undefined;
    rateLimitTpm?: number | undefined;
    rateLimitRpd?: number | undefined;
    isActive?: boolean;
    isDefault?: boolean;
}

export class CreateAlertRuleDto implements ICreateAlertRuleDto {
    canonicalProductId!: string;
    conditionType!: string;
    alertType!: string;
    thresholdValue?: number | undefined;
    percentageValue?: number | undefined;
    specificSellerName?: string | undefined;
    notificationFrequencyMinutes?: number;

    constructor(data?: ICreateAlertRuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.canonicalProductId = _data["canonicalProductId"];
            this.conditionType = _data["conditionType"];
            this.alertType = _data["alertType"];
            this.thresholdValue = _data["thresholdValue"];
            this.percentageValue = _data["percentageValue"];
            this.specificSellerName = _data["specificSellerName"];
            this.notificationFrequencyMinutes = _data["notificationFrequencyMinutes"];
        }
    }

    static fromJS(data: any): CreateAlertRuleDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAlertRuleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canonicalProductId"] = this.canonicalProductId;
        data["conditionType"] = this.conditionType;
        data["alertType"] = this.alertType;
        data["thresholdValue"] = this.thresholdValue;
        data["percentageValue"] = this.percentageValue;
        data["specificSellerName"] = this.specificSellerName;
        data["notificationFrequencyMinutes"] = this.notificationFrequencyMinutes;
        return data;
    }
}

export interface ICreateAlertRuleDto {
    canonicalProductId: string;
    conditionType: string;
    alertType: string;
    thresholdValue?: number | undefined;
    percentageValue?: number | undefined;
    specificSellerName?: string | undefined;
    notificationFrequencyMinutes?: number;
}

export class CreateCategoryDto implements ICreateCategoryDto {
    name!: string;
    slug?: string | undefined;
    description?: string | undefined;

    constructor(data?: ICreateCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): CreateCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["description"] = this.description;
        return data;
    }
}

export interface ICreateCategoryDto {
    name: string;
    slug?: string | undefined;
    description?: string | undefined;
}

export class CreatePermissionDto implements ICreatePermissionDto {
    name!: string;
    description?: string | undefined;
    category!: string;

    constructor(data?: ICreatePermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.category = _data["category"];
        }
    }

    static fromJS(data: any): CreatePermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["category"] = this.category;
        return data;
    }
}

export interface ICreatePermissionDto {
    name: string;
    description?: string | undefined;
    category: string;
}

export class CreateProductDto implements ICreateProductDto {
    name!: string;
    manufacturer?: string | undefined;
    modelNumber?: string | undefined;
    sku?: string | undefined;
    categoryId!: string;
    description?: string | undefined;
    primaryImageUrl?: string | undefined;
    additionalImageUrls?: string[] | undefined;

    constructor(data?: ICreateProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.manufacturer = _data["manufacturer"];
            this.modelNumber = _data["modelNumber"];
            this.sku = _data["sku"];
            this.categoryId = _data["categoryId"];
            this.description = _data["description"];
            this.primaryImageUrl = _data["primaryImageUrl"];
            if (Array.isArray(_data["additionalImageUrls"])) {
                this.additionalImageUrls = [] as any;
                for (let item of _data["additionalImageUrls"])
                    this.additionalImageUrls!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["manufacturer"] = this.manufacturer;
        data["modelNumber"] = this.modelNumber;
        data["sku"] = this.sku;
        data["categoryId"] = this.categoryId;
        data["description"] = this.description;
        data["primaryImageUrl"] = this.primaryImageUrl;
        if (Array.isArray(this.additionalImageUrls)) {
            data["additionalImageUrls"] = [];
            for (let item of this.additionalImageUrls)
                data["additionalImageUrls"].push(item);
        }
        return data;
    }
}

export interface ICreateProductDto {
    name: string;
    manufacturer?: string | undefined;
    modelNumber?: string | undefined;
    sku?: string | undefined;
    categoryId: string;
    description?: string | undefined;
    primaryImageUrl?: string | undefined;
    additionalImageUrls?: string[] | undefined;
}

export class CreateProductSellerMappingDto implements ICreateProductSellerMappingDto {
    canonicalProductId!: string;
    sellerName!: string;
    exactProductUrl!: string;
    isActiveForScraping?: boolean;
    scrapingFrequencyOverride?: string | undefined;
    siteConfigId?: string | undefined;

    constructor(data?: ICreateProductSellerMappingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.canonicalProductId = _data["canonicalProductId"];
            this.sellerName = _data["sellerName"];
            this.exactProductUrl = _data["exactProductUrl"];
            this.isActiveForScraping = _data["isActiveForScraping"];
            this.scrapingFrequencyOverride = _data["scrapingFrequencyOverride"];
            this.siteConfigId = _data["siteConfigId"];
        }
    }

    static fromJS(data: any): CreateProductSellerMappingDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductSellerMappingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canonicalProductId"] = this.canonicalProductId;
        data["sellerName"] = this.sellerName;
        data["exactProductUrl"] = this.exactProductUrl;
        data["isActiveForScraping"] = this.isActiveForScraping;
        data["scrapingFrequencyOverride"] = this.scrapingFrequencyOverride;
        data["siteConfigId"] = this.siteConfigId;
        return data;
    }
}

export interface ICreateProductSellerMappingDto {
    canonicalProductId: string;
    sellerName: string;
    exactProductUrl: string;
    isActiveForScraping?: boolean;
    scrapingFrequencyOverride?: string | undefined;
    siteConfigId?: string | undefined;
}

export class CreateProxyConfigurationDto implements ICreateProxyConfigurationDto {
    host!: string;
    port!: number;
    proxyType!: string;
    username?: string | undefined;
    password?: string | undefined;
    description?: string | undefined;
    timeoutSeconds?: number;
    maxRetries?: number;
    isActive?: boolean;

    constructor(data?: ICreateProxyConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.host = _data["host"];
            this.port = _data["port"];
            this.proxyType = _data["proxyType"];
            this.username = _data["username"];
            this.password = _data["password"];
            this.description = _data["description"];
            this.timeoutSeconds = _data["timeoutSeconds"];
            this.maxRetries = _data["maxRetries"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateProxyConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProxyConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["host"] = this.host;
        data["port"] = this.port;
        data["proxyType"] = this.proxyType;
        data["username"] = this.username;
        data["password"] = this.password;
        data["description"] = this.description;
        data["timeoutSeconds"] = this.timeoutSeconds;
        data["maxRetries"] = this.maxRetries;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface ICreateProxyConfigurationDto {
    host: string;
    port: number;
    proxyType: string;
    username?: string | undefined;
    password?: string | undefined;
    description?: string | undefined;
    timeoutSeconds?: number;
    maxRetries?: number;
    isActive?: boolean;
}

export class CreateRoleDto implements ICreateRoleDto {
    name?: string | undefined;

    constructor(data?: ICreateRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CreateRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }
}

export interface ICreateRoleDto {
    name?: string | undefined;
}

export class CreateScraperSiteConfigurationDto implements ICreateScraperSiteConfigurationDto {
    siteDomain!: string;
    productNameSelector!: string;
    priceSelector!: string;
    stockSelector!: string;
    sellerNameOnPageSelector?: string | undefined;
    imageSelector?: string | undefined;
    defaultUserAgent?: string | undefined;
    additionalHeaders?: { [key: string]: string; } | undefined;
    isEnabled?: boolean;
    requiresBrowserAutomation?: boolean;
    browserAutomationProfile?: string | undefined;
    specificationTableSelector?: string | undefined;
    specificationContainerSelector?: string | undefined;
    enableSpecificationScraping?: boolean;
    specificationOptions?: SpecificationParsingOptions;

    constructor(data?: ICreateScraperSiteConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.siteDomain = _data["siteDomain"];
            this.productNameSelector = _data["productNameSelector"];
            this.priceSelector = _data["priceSelector"];
            this.stockSelector = _data["stockSelector"];
            this.sellerNameOnPageSelector = _data["sellerNameOnPageSelector"];
            this.imageSelector = _data["imageSelector"];
            this.defaultUserAgent = _data["defaultUserAgent"];
            if (_data["additionalHeaders"]) {
                this.additionalHeaders = {} as any;
                for (let key in _data["additionalHeaders"]) {
                    if (_data["additionalHeaders"].hasOwnProperty(key))
                        (<any>this.additionalHeaders)![key] = _data["additionalHeaders"][key];
                }
            }
            this.isEnabled = _data["isEnabled"];
            this.requiresBrowserAutomation = _data["requiresBrowserAutomation"];
            this.browserAutomationProfile = _data["browserAutomationProfile"];
            this.specificationTableSelector = _data["specificationTableSelector"];
            this.specificationContainerSelector = _data["specificationContainerSelector"];
            this.enableSpecificationScraping = _data["enableSpecificationScraping"];
            this.specificationOptions = _data["specificationOptions"] ? SpecificationParsingOptions.fromJS(_data["specificationOptions"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateScraperSiteConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateScraperSiteConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["siteDomain"] = this.siteDomain;
        data["productNameSelector"] = this.productNameSelector;
        data["priceSelector"] = this.priceSelector;
        data["stockSelector"] = this.stockSelector;
        data["sellerNameOnPageSelector"] = this.sellerNameOnPageSelector;
        data["imageSelector"] = this.imageSelector;
        data["defaultUserAgent"] = this.defaultUserAgent;
        if (this.additionalHeaders) {
            data["additionalHeaders"] = {};
            for (let key in this.additionalHeaders) {
                if (this.additionalHeaders.hasOwnProperty(key))
                    (<any>data["additionalHeaders"])[key] = (<any>this.additionalHeaders)[key];
            }
        }
        data["isEnabled"] = this.isEnabled;
        data["requiresBrowserAutomation"] = this.requiresBrowserAutomation;
        data["browserAutomationProfile"] = this.browserAutomationProfile;
        data["specificationTableSelector"] = this.specificationTableSelector;
        data["specificationContainerSelector"] = this.specificationContainerSelector;
        data["enableSpecificationScraping"] = this.enableSpecificationScraping;
        data["specificationOptions"] = this.specificationOptions ? this.specificationOptions.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICreateScraperSiteConfigurationDto {
    siteDomain: string;
    productNameSelector: string;
    priceSelector: string;
    stockSelector: string;
    sellerNameOnPageSelector?: string | undefined;
    imageSelector?: string | undefined;
    defaultUserAgent?: string | undefined;
    additionalHeaders?: { [key: string]: string; } | undefined;
    isEnabled?: boolean;
    requiresBrowserAutomation?: boolean;
    browserAutomationProfile?: string | undefined;
    specificationTableSelector?: string | undefined;
    specificationContainerSelector?: string | undefined;
    enableSpecificationScraping?: boolean;
    specificationOptions?: SpecificationParsingOptions;
}

export class CreateUserDto implements ICreateUserDto {
    email!: string;
    password!: string;
    firstName?: string | undefined;
    lastName?: string | undefined;
    roles?: string[] | undefined;

    constructor(data?: ICreateUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data;
    }
}

export interface ICreateUserDto {
    email: string;
    password: string;
    firstName?: string | undefined;
    lastName?: string | undefined;
    roles?: string[] | undefined;
}

export class CurrentPriceDto implements ICurrentPriceDto {
    sellerName?: string | undefined;
    price?: number;
    stockStatus?: string | undefined;
    sourceUrl?: string | undefined;
    lastUpdated?: Date;
    scrapedProductNameOnPage?: string | undefined;

    constructor(data?: ICurrentPriceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sellerName = _data["sellerName"];
            this.price = _data["price"];
            this.stockStatus = _data["stockStatus"];
            this.sourceUrl = _data["sourceUrl"];
            this.lastUpdated = _data["lastUpdated"] ? new Date(_data["lastUpdated"].toString()) : <any>undefined;
            this.scrapedProductNameOnPage = _data["scrapedProductNameOnPage"];
        }
    }

    static fromJS(data: any): CurrentPriceDto {
        data = typeof data === 'object' ? data : {};
        let result = new CurrentPriceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sellerName"] = this.sellerName;
        data["price"] = this.price;
        data["stockStatus"] = this.stockStatus;
        data["sourceUrl"] = this.sourceUrl;
        data["lastUpdated"] = this.lastUpdated ? this.lastUpdated.toISOString() : <any>undefined;
        data["scrapedProductNameOnPage"] = this.scrapedProductNameOnPage;
        return data;
    }
}

export interface ICurrentPriceDto {
    sellerName?: string | undefined;
    price?: number;
    stockStatus?: string | undefined;
    sourceUrl?: string | undefined;
    lastUpdated?: Date;
    scrapedProductNameOnPage?: string | undefined;
}

export class CurrentPriceDtoIEnumerableApiResponse implements ICurrentPriceDtoIEnumerableApiResponse {
    success?: boolean;
    data?: CurrentPriceDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: ICurrentPriceDtoIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(CurrentPriceDto.fromJS(item));
            }
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): CurrentPriceDtoIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CurrentPriceDtoIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : <any>undefined);
        }
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface ICurrentPriceDtoIEnumerableApiResponse {
    success?: boolean;
    data?: CurrentPriceDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class DashboardStatsDto implements IDashboardStatsDto {
    totalProducts?: number;
    totalCategories?: number;
    activeMappings?: number;
    activeAlerts?: number;
    totalUsers?: number | undefined;
    totalProxies?: number;
    healthyProxies?: number;
    proxyHealthPercentage?: number;
    recentScraperRuns?: number;
    scraperSuccessRate?: number;
    recentNotifications?: number;
    notificationSuccessRate?: number;
    systemHealthy?: boolean;
    recentAlerts?: number;

    constructor(data?: IDashboardStatsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalProducts = _data["totalProducts"];
            this.totalCategories = _data["totalCategories"];
            this.activeMappings = _data["activeMappings"];
            this.activeAlerts = _data["activeAlerts"];
            this.totalUsers = _data["totalUsers"];
            this.totalProxies = _data["totalProxies"];
            this.healthyProxies = _data["healthyProxies"];
            this.proxyHealthPercentage = _data["proxyHealthPercentage"];
            this.recentScraperRuns = _data["recentScraperRuns"];
            this.scraperSuccessRate = _data["scraperSuccessRate"];
            this.recentNotifications = _data["recentNotifications"];
            this.notificationSuccessRate = _data["notificationSuccessRate"];
            this.systemHealthy = _data["systemHealthy"];
            this.recentAlerts = _data["recentAlerts"];
        }
    }

    static fromJS(data: any): DashboardStatsDto {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardStatsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalProducts"] = this.totalProducts;
        data["totalCategories"] = this.totalCategories;
        data["activeMappings"] = this.activeMappings;
        data["activeAlerts"] = this.activeAlerts;
        data["totalUsers"] = this.totalUsers;
        data["totalProxies"] = this.totalProxies;
        data["healthyProxies"] = this.healthyProxies;
        data["proxyHealthPercentage"] = this.proxyHealthPercentage;
        data["recentScraperRuns"] = this.recentScraperRuns;
        data["scraperSuccessRate"] = this.scraperSuccessRate;
        data["recentNotifications"] = this.recentNotifications;
        data["notificationSuccessRate"] = this.notificationSuccessRate;
        data["systemHealthy"] = this.systemHealthy;
        data["recentAlerts"] = this.recentAlerts;
        return data;
    }
}

export interface IDashboardStatsDto {
    totalProducts?: number;
    totalCategories?: number;
    activeMappings?: number;
    activeAlerts?: number;
    totalUsers?: number | undefined;
    totalProxies?: number;
    healthyProxies?: number;
    proxyHealthPercentage?: number;
    recentScraperRuns?: number;
    scraperSuccessRate?: number;
    recentNotifications?: number;
    notificationSuccessRate?: number;
    systemHealthy?: boolean;
    recentAlerts?: number;
}

export class DashboardStatsDtoApiResponse implements IDashboardStatsDtoApiResponse {
    success?: boolean;
    data?: DashboardStatsDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IDashboardStatsDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"] ? DashboardStatsDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): DashboardStatsDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardStatsDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IDashboardStatsDtoApiResponse {
    success?: boolean;
    data?: DashboardStatsDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export enum DifferenceSeverity {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export enum DifferenceType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class ExecutionMetricsDto implements IExecutionMetricsDto {
    totalDuration?: number;
    navigationTime?: number;
    actionsTime?: number;
    memoryUsage?: number;
    cpuUsage?: number;
    networkRequestCount?: number;
    networkBytesReceived?: number;
    networkBytesSent?: number;

    constructor(data?: IExecutionMetricsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalDuration = _data["totalDuration"];
            this.navigationTime = _data["navigationTime"];
            this.actionsTime = _data["actionsTime"];
            this.memoryUsage = _data["memoryUsage"];
            this.cpuUsage = _data["cpuUsage"];
            this.networkRequestCount = _data["networkRequestCount"];
            this.networkBytesReceived = _data["networkBytesReceived"];
            this.networkBytesSent = _data["networkBytesSent"];
        }
    }

    static fromJS(data: any): ExecutionMetricsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExecutionMetricsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalDuration"] = this.totalDuration;
        data["navigationTime"] = this.navigationTime;
        data["actionsTime"] = this.actionsTime;
        data["memoryUsage"] = this.memoryUsage;
        data["cpuUsage"] = this.cpuUsage;
        data["networkRequestCount"] = this.networkRequestCount;
        data["networkBytesReceived"] = this.networkBytesReceived;
        data["networkBytesSent"] = this.networkBytesSent;
        return data;
    }
}

export interface IExecutionMetricsDto {
    totalDuration?: number;
    navigationTime?: number;
    actionsTime?: number;
    memoryUsage?: number;
    cpuUsage?: number;
    networkRequestCount?: number;
    networkBytesReceived?: number;
    networkBytesSent?: number;
}

export class GeneratedBrowserAction implements IGeneratedBrowserAction {
    actionType?: string | undefined;
    selector?: string | undefined;
    repeat?: number | undefined;
    delayMs?: number | undefined;
    value?: string | undefined;
    description?: string | undefined;

    constructor(data?: IGeneratedBrowserAction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.actionType = _data["actionType"];
            this.selector = _data["selector"];
            this.repeat = _data["repeat"];
            this.delayMs = _data["delayMs"];
            this.value = _data["value"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): GeneratedBrowserAction {
        data = typeof data === 'object' ? data : {};
        let result = new GeneratedBrowserAction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["actionType"] = this.actionType;
        data["selector"] = this.selector;
        data["repeat"] = this.repeat;
        data["delayMs"] = this.delayMs;
        data["value"] = this.value;
        data["description"] = this.description;
        return data;
    }
}

export interface IGeneratedBrowserAction {
    actionType?: string | undefined;
    selector?: string | undefined;
    repeat?: number | undefined;
    delayMs?: number | undefined;
    value?: string | undefined;
    description?: string | undefined;
}

export class GenericAiRequestDto implements IGenericAiRequestDto {
    inputText!: string;
    systemPrompt?: string | undefined;
    context?: string | undefined;
    jsonSchema?: string | undefined;
    aiConfigurationId?: string | undefined;
    temperature?: number | undefined;
    maxTokens?: number | undefined;

    constructor(data?: IGenericAiRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.inputText = _data["inputText"];
            this.systemPrompt = _data["systemPrompt"];
            this.context = _data["context"];
            this.jsonSchema = _data["jsonSchema"];
            this.aiConfigurationId = _data["aiConfigurationId"];
            this.temperature = _data["temperature"];
            this.maxTokens = _data["maxTokens"];
        }
    }

    static fromJS(data: any): GenericAiRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new GenericAiRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["inputText"] = this.inputText;
        data["systemPrompt"] = this.systemPrompt;
        data["context"] = this.context;
        data["jsonSchema"] = this.jsonSchema;
        data["aiConfigurationId"] = this.aiConfigurationId;
        data["temperature"] = this.temperature;
        data["maxTokens"] = this.maxTokens;
        return data;
    }
}

export interface IGenericAiRequestDto {
    inputText: string;
    systemPrompt?: string | undefined;
    context?: string | undefined;
    jsonSchema?: string | undefined;
    aiConfigurationId?: string | undefined;
    temperature?: number | undefined;
    maxTokens?: number | undefined;
}

export class GenericAiResponseDto implements IGenericAiResponseDto {
    response?: string | undefined;
    tokensUsed?: number;
    model?: string | undefined;
    success?: boolean;
    errorMessage?: string | undefined;
    isStructuredOutput?: boolean;
    generatedAt?: Date;

    constructor(data?: IGenericAiResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.response = _data["response"];
            this.tokensUsed = _data["tokensUsed"];
            this.model = _data["model"];
            this.success = _data["success"];
            this.errorMessage = _data["errorMessage"];
            this.isStructuredOutput = _data["isStructuredOutput"];
            this.generatedAt = _data["generatedAt"] ? new Date(_data["generatedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GenericAiResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GenericAiResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["response"] = this.response;
        data["tokensUsed"] = this.tokensUsed;
        data["model"] = this.model;
        data["success"] = this.success;
        data["errorMessage"] = this.errorMessage;
        data["isStructuredOutput"] = this.isStructuredOutput;
        data["generatedAt"] = this.generatedAt ? this.generatedAt.toISOString() : <any>undefined;
        return data;
    }
}

export interface IGenericAiResponseDto {
    response?: string | undefined;
    tokensUsed?: number;
    model?: string | undefined;
    success?: boolean;
    errorMessage?: string | undefined;
    isStructuredOutput?: boolean;
    generatedAt?: Date;
}

export class GenericAiResponseDtoApiResponse implements IGenericAiResponseDtoApiResponse {
    success?: boolean;
    data?: GenericAiResponseDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IGenericAiResponseDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"] ? GenericAiResponseDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): GenericAiResponseDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GenericAiResponseDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IGenericAiResponseDtoApiResponse {
    success?: boolean;
    data?: GenericAiResponseDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class Int32ApiResponse implements IInt32ApiResponse {
    success?: boolean;
    data?: number;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IInt32ApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"];
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): Int32ApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new Int32ApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IInt32ApiResponse {
    success?: boolean;
    data?: number;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class LoginResponseDto implements ILoginResponseDto {
    token?: string | undefined;
    userId?: string;
    email?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    roles?: string[] | undefined;

    constructor(data?: ILoginResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
            this.userId = _data["userId"];
            this.email = _data["email"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
        }
    }

    static fromJS(data: any): LoginResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new LoginResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        data["userId"] = this.userId;
        data["email"] = this.email;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data;
    }
}

export interface ILoginResponseDto {
    token?: string | undefined;
    userId?: string;
    email?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    roles?: string[] | undefined;
}

export class LoginResponseDtoApiResponse implements ILoginResponseDtoApiResponse {
    success?: boolean;
    data?: LoginResponseDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: ILoginResponseDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"] ? LoginResponseDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): LoginResponseDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new LoginResponseDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface ILoginResponseDtoApiResponse {
    success?: boolean;
    data?: LoginResponseDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class LoginUserDto implements ILoginUserDto {
    email!: string;
    password!: string;

    constructor(data?: ILoginUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): LoginUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new LoginUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        return data;
    }
}

export interface ILoginUserDto {
    email: string;
    password: string;
}

export class MetricComparison implements IMetricComparison {
    firstValue?: number;
    secondValue?: number;
    difference?: number;
    percentageChange?: number;
    trend?: ComparisonTrend;

    constructor(data?: IMetricComparison) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firstValue = _data["firstValue"];
            this.secondValue = _data["secondValue"];
            this.difference = _data["difference"];
            this.percentageChange = _data["percentageChange"];
            this.trend = _data["trend"];
        }
    }

    static fromJS(data: any): MetricComparison {
        data = typeof data === 'object' ? data : {};
        let result = new MetricComparison();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstValue"] = this.firstValue;
        data["secondValue"] = this.secondValue;
        data["difference"] = this.difference;
        data["percentageChange"] = this.percentageChange;
        data["trend"] = this.trend;
        return data;
    }
}

export interface IMetricComparison {
    firstValue?: number;
    secondValue?: number;
    difference?: number;
    percentageChange?: number;
    trend?: ComparisonTrend;
}

export class NetworkRequestDto implements INetworkRequestDto {
    url?: string | undefined;
    method?: string | undefined;
    statusCode?: number;
    statusText?: string | undefined;
    headers?: { [key: string]: string; } | undefined;
    duration?: number;
    size?: number;
    timestamp?: Date;

    constructor(data?: INetworkRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.url = _data["url"];
            this.method = _data["method"];
            this.statusCode = _data["statusCode"];
            this.statusText = _data["statusText"];
            if (_data["headers"]) {
                this.headers = {} as any;
                for (let key in _data["headers"]) {
                    if (_data["headers"].hasOwnProperty(key))
                        (<any>this.headers)![key] = _data["headers"][key];
                }
            }
            this.duration = _data["duration"];
            this.size = _data["size"];
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): NetworkRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new NetworkRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        data["method"] = this.method;
        data["statusCode"] = this.statusCode;
        data["statusText"] = this.statusText;
        if (this.headers) {
            data["headers"] = {};
            for (let key in this.headers) {
                if (this.headers.hasOwnProperty(key))
                    (<any>data["headers"])[key] = (<any>this.headers)[key];
            }
        }
        data["duration"] = this.duration;
        data["size"] = this.size;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        return data;
    }
}

export interface INetworkRequestDto {
    url?: string | undefined;
    method?: string | undefined;
    statusCode?: number;
    statusText?: string | undefined;
    headers?: { [key: string]: string; } | undefined;
    duration?: number;
    size?: number;
    timestamp?: Date;
}

export class NormalizedSpecificationValue implements INormalizedSpecificationValue {
    value?: any | undefined;
    unit?: string | undefined;
    dataType?: SpecificationType;
    rawValue?: string | undefined;
    canonicalName?: string | undefined;
    confidence?: number;

    constructor(data?: INormalizedSpecificationValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.unit = _data["unit"];
            this.dataType = _data["dataType"];
            this.rawValue = _data["rawValue"];
            this.canonicalName = _data["canonicalName"];
            this.confidence = _data["confidence"];
        }
    }

    static fromJS(data: any): NormalizedSpecificationValue {
        data = typeof data === 'object' ? data : {};
        let result = new NormalizedSpecificationValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["unit"] = this.unit;
        data["dataType"] = this.dataType;
        data["rawValue"] = this.rawValue;
        data["canonicalName"] = this.canonicalName;
        data["confidence"] = this.confidence;
        return data;
    }
}

export interface INormalizedSpecificationValue {
    value?: any | undefined;
    unit?: string | undefined;
    dataType?: SpecificationType;
    rawValue?: string | undefined;
    canonicalName?: string | undefined;
    confidence?: number;
}

export class NotificationChannelStatsDto implements INotificationChannelStatsDto {
    channelName?: string | undefined;
    totalNotifications?: number;
    successfulDeliveries?: number;
    failedDeliveries?: number;
    successRate?: number;
    averageDeliveryTime?: string;
    maxDeliveryTime?: string;
    minDeliveryTime?: string;
    topFailureReasons?: NotificationFailureReasonDto[] | undefined;
    deliveriesByHour?: { [key: string]: number; } | undefined;
    isHealthy?: boolean;
    healthIssues?: string[] | undefined;

    constructor(data?: INotificationChannelStatsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.channelName = _data["channelName"];
            this.totalNotifications = _data["totalNotifications"];
            this.successfulDeliveries = _data["successfulDeliveries"];
            this.failedDeliveries = _data["failedDeliveries"];
            this.successRate = _data["successRate"];
            this.averageDeliveryTime = _data["averageDeliveryTime"];
            this.maxDeliveryTime = _data["maxDeliveryTime"];
            this.minDeliveryTime = _data["minDeliveryTime"];
            if (Array.isArray(_data["topFailureReasons"])) {
                this.topFailureReasons = [] as any;
                for (let item of _data["topFailureReasons"])
                    this.topFailureReasons!.push(NotificationFailureReasonDto.fromJS(item));
            }
            if (_data["deliveriesByHour"]) {
                this.deliveriesByHour = {} as any;
                for (let key in _data["deliveriesByHour"]) {
                    if (_data["deliveriesByHour"].hasOwnProperty(key))
                        (<any>this.deliveriesByHour)![key] = _data["deliveriesByHour"][key];
                }
            }
            this.isHealthy = _data["isHealthy"];
            if (Array.isArray(_data["healthIssues"])) {
                this.healthIssues = [] as any;
                for (let item of _data["healthIssues"])
                    this.healthIssues!.push(item);
            }
        }
    }

    static fromJS(data: any): NotificationChannelStatsDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationChannelStatsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["channelName"] = this.channelName;
        data["totalNotifications"] = this.totalNotifications;
        data["successfulDeliveries"] = this.successfulDeliveries;
        data["failedDeliveries"] = this.failedDeliveries;
        data["successRate"] = this.successRate;
        data["averageDeliveryTime"] = this.averageDeliveryTime;
        data["maxDeliveryTime"] = this.maxDeliveryTime;
        data["minDeliveryTime"] = this.minDeliveryTime;
        if (Array.isArray(this.topFailureReasons)) {
            data["topFailureReasons"] = [];
            for (let item of this.topFailureReasons)
                data["topFailureReasons"].push(item ? item.toJSON() : <any>undefined);
        }
        if (this.deliveriesByHour) {
            data["deliveriesByHour"] = {};
            for (let key in this.deliveriesByHour) {
                if (this.deliveriesByHour.hasOwnProperty(key))
                    (<any>data["deliveriesByHour"])[key] = (<any>this.deliveriesByHour)[key];
            }
        }
        data["isHealthy"] = this.isHealthy;
        if (Array.isArray(this.healthIssues)) {
            data["healthIssues"] = [];
            for (let item of this.healthIssues)
                data["healthIssues"].push(item);
        }
        return data;
    }
}

export interface INotificationChannelStatsDto {
    channelName?: string | undefined;
    totalNotifications?: number;
    successfulDeliveries?: number;
    failedDeliveries?: number;
    successRate?: number;
    averageDeliveryTime?: string;
    maxDeliveryTime?: string;
    minDeliveryTime?: string;
    topFailureReasons?: NotificationFailureReasonDto[] | undefined;
    deliveriesByHour?: { [key: string]: number; } | undefined;
    isHealthy?: boolean;
    healthIssues?: string[] | undefined;
}

export class NotificationDeliveryMetricsDto implements INotificationDeliveryMetricsDto {
    totalNotificationsSent?: number;
    successfulDeliveries?: number;
    failedDeliveries?: number;
    pendingDeliveries?: number;
    deliverySuccessRate?: number;
    averageDeliveryTime?: string;
    maxDeliveryTime?: string;
    minDeliveryTime?: string;
    deliveriesByChannel?: { [key: string]: number; } | undefined;
    successRateByChannel?: { [key: string]: number; } | undefined;
    topFailureReasons?: NotificationFailureReasonDto[] | undefined;

    constructor(data?: INotificationDeliveryMetricsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalNotificationsSent = _data["totalNotificationsSent"];
            this.successfulDeliveries = _data["successfulDeliveries"];
            this.failedDeliveries = _data["failedDeliveries"];
            this.pendingDeliveries = _data["pendingDeliveries"];
            this.deliverySuccessRate = _data["deliverySuccessRate"];
            this.averageDeliveryTime = _data["averageDeliveryTime"];
            this.maxDeliveryTime = _data["maxDeliveryTime"];
            this.minDeliveryTime = _data["minDeliveryTime"];
            if (_data["deliveriesByChannel"]) {
                this.deliveriesByChannel = {} as any;
                for (let key in _data["deliveriesByChannel"]) {
                    if (_data["deliveriesByChannel"].hasOwnProperty(key))
                        (<any>this.deliveriesByChannel)![key] = _data["deliveriesByChannel"][key];
                }
            }
            if (_data["successRateByChannel"]) {
                this.successRateByChannel = {} as any;
                for (let key in _data["successRateByChannel"]) {
                    if (_data["successRateByChannel"].hasOwnProperty(key))
                        (<any>this.successRateByChannel)![key] = _data["successRateByChannel"][key];
                }
            }
            if (Array.isArray(_data["topFailureReasons"])) {
                this.topFailureReasons = [] as any;
                for (let item of _data["topFailureReasons"])
                    this.topFailureReasons!.push(NotificationFailureReasonDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): NotificationDeliveryMetricsDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationDeliveryMetricsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalNotificationsSent"] = this.totalNotificationsSent;
        data["successfulDeliveries"] = this.successfulDeliveries;
        data["failedDeliveries"] = this.failedDeliveries;
        data["pendingDeliveries"] = this.pendingDeliveries;
        data["deliverySuccessRate"] = this.deliverySuccessRate;
        data["averageDeliveryTime"] = this.averageDeliveryTime;
        data["maxDeliveryTime"] = this.maxDeliveryTime;
        data["minDeliveryTime"] = this.minDeliveryTime;
        if (this.deliveriesByChannel) {
            data["deliveriesByChannel"] = {};
            for (let key in this.deliveriesByChannel) {
                if (this.deliveriesByChannel.hasOwnProperty(key))
                    (<any>data["deliveriesByChannel"])[key] = (<any>this.deliveriesByChannel)[key];
            }
        }
        if (this.successRateByChannel) {
            data["successRateByChannel"] = {};
            for (let key in this.successRateByChannel) {
                if (this.successRateByChannel.hasOwnProperty(key))
                    (<any>data["successRateByChannel"])[key] = (<any>this.successRateByChannel)[key];
            }
        }
        if (Array.isArray(this.topFailureReasons)) {
            data["topFailureReasons"] = [];
            for (let item of this.topFailureReasons)
                data["topFailureReasons"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface INotificationDeliveryMetricsDto {
    totalNotificationsSent?: number;
    successfulDeliveries?: number;
    failedDeliveries?: number;
    pendingDeliveries?: number;
    deliverySuccessRate?: number;
    averageDeliveryTime?: string;
    maxDeliveryTime?: string;
    minDeliveryTime?: string;
    deliveriesByChannel?: { [key: string]: number; } | undefined;
    successRateByChannel?: { [key: string]: number; } | undefined;
    topFailureReasons?: NotificationFailureReasonDto[] | undefined;
}

export class NotificationFailureReasonDto implements INotificationFailureReasonDto {
    reason?: string | undefined;
    count?: number;
    percentage?: number;
    suggestedAction?: string | undefined;

    constructor(data?: INotificationFailureReasonDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.reason = _data["reason"];
            this.count = _data["count"];
            this.percentage = _data["percentage"];
            this.suggestedAction = _data["suggestedAction"];
        }
    }

    static fromJS(data: any): NotificationFailureReasonDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationFailureReasonDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reason"] = this.reason;
        data["count"] = this.count;
        data["percentage"] = this.percentage;
        data["suggestedAction"] = this.suggestedAction;
        return data;
    }
}

export interface INotificationFailureReasonDto {
    reason?: string | undefined;
    count?: number;
    percentage?: number;
    suggestedAction?: string | undefined;
}

export class NotificationPreferencesSummaryDto implements INotificationPreferencesSummaryDto {
    isDiscordEnabled?: boolean;
    hasWebhookConfigured?: boolean;
    selectedProductsCount?: number;
    maxProductsAllowed?: number;
    selectedProductNames?: string[] | undefined;

    constructor(data?: INotificationPreferencesSummaryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isDiscordEnabled = _data["isDiscordEnabled"];
            this.hasWebhookConfigured = _data["hasWebhookConfigured"];
            this.selectedProductsCount = _data["selectedProductsCount"];
            this.maxProductsAllowed = _data["maxProductsAllowed"];
            if (Array.isArray(_data["selectedProductNames"])) {
                this.selectedProductNames = [] as any;
                for (let item of _data["selectedProductNames"])
                    this.selectedProductNames!.push(item);
            }
        }
    }

    static fromJS(data: any): NotificationPreferencesSummaryDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationPreferencesSummaryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isDiscordEnabled"] = this.isDiscordEnabled;
        data["hasWebhookConfigured"] = this.hasWebhookConfigured;
        data["selectedProductsCount"] = this.selectedProductsCount;
        data["maxProductsAllowed"] = this.maxProductsAllowed;
        if (Array.isArray(this.selectedProductNames)) {
            data["selectedProductNames"] = [];
            for (let item of this.selectedProductNames)
                data["selectedProductNames"].push(item);
        }
        return data;
    }
}

export interface INotificationPreferencesSummaryDto {
    isDiscordEnabled?: boolean;
    hasWebhookConfigured?: boolean;
    selectedProductsCount?: number;
    maxProductsAllowed?: number;
    selectedProductNames?: string[] | undefined;
}

export class NotificationPreferencesSummaryDtoApiResponse implements INotificationPreferencesSummaryDtoApiResponse {
    success?: boolean;
    data?: NotificationPreferencesSummaryDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: INotificationPreferencesSummaryDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"] ? NotificationPreferencesSummaryDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): NotificationPreferencesSummaryDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationPreferencesSummaryDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface INotificationPreferencesSummaryDtoApiResponse {
    success?: boolean;
    data?: NotificationPreferencesSummaryDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class NotificationProductSelectionDto implements INotificationProductSelectionDto {
    productId?: string;
    productName?: string | undefined;
    categoryName?: string | undefined;
    manufacturer?: string | undefined;
    isSelected?: boolean;
    hasActiveAlerts?: boolean;

    constructor(data?: INotificationProductSelectionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.productName = _data["productName"];
            this.categoryName = _data["categoryName"];
            this.manufacturer = _data["manufacturer"];
            this.isSelected = _data["isSelected"];
            this.hasActiveAlerts = _data["hasActiveAlerts"];
        }
    }

    static fromJS(data: any): NotificationProductSelectionDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationProductSelectionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["productName"] = this.productName;
        data["categoryName"] = this.categoryName;
        data["manufacturer"] = this.manufacturer;
        data["isSelected"] = this.isSelected;
        data["hasActiveAlerts"] = this.hasActiveAlerts;
        return data;
    }
}

export interface INotificationProductSelectionDto {
    productId?: string;
    productName?: string | undefined;
    categoryName?: string | undefined;
    manufacturer?: string | undefined;
    isSelected?: boolean;
    hasActiveAlerts?: boolean;
}

export class NotificationProductSelectionDtoIEnumerableApiResponse implements INotificationProductSelectionDtoIEnumerableApiResponse {
    success?: boolean;
    data?: NotificationProductSelectionDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: INotificationProductSelectionDtoIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(NotificationProductSelectionDto.fromJS(item));
            }
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): NotificationProductSelectionDtoIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationProductSelectionDtoIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : <any>undefined);
        }
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface INotificationProductSelectionDtoIEnumerableApiResponse {
    success?: boolean;
    data?: NotificationProductSelectionDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class ObjectApiResponse implements IObjectApiResponse {
    success?: boolean;
    data?: any | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IObjectApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"];
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): ObjectApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ObjectApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IObjectApiResponse {
    success?: boolean;
    data?: any | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class ObjectPagedResponse implements IObjectPagedResponse {
    success?: boolean;
    data?: any[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
    pagination?: PaginationMeta;

    constructor(data?: IObjectPagedResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(item);
            }
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
            this.pagination = _data["pagination"] ? PaginationMeta.fromJS(_data["pagination"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ObjectPagedResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ObjectPagedResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item);
        }
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        data["pagination"] = this.pagination ? this.pagination.toJSON() : <any>undefined;
        return data;
    }
}

export interface IObjectPagedResponse {
    success?: boolean;
    data?: any[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
    pagination?: PaginationMeta;
}

export class PaginationMeta implements IPaginationMeta {
    pageNumber?: number;
    pageSize?: number;
    totalCount?: number;
    readonly totalPages?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;
    readonly firstItemOnPage?: number;
    readonly lastItemOnPage?: number;

    constructor(data?: IPaginationMeta) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
            this.totalCount = _data["totalCount"];
            (<any>this).totalPages = _data["totalPages"];
            (<any>this).hasPreviousPage = _data["hasPreviousPage"];
            (<any>this).hasNextPage = _data["hasNextPage"];
            (<any>this).firstItemOnPage = _data["firstItemOnPage"];
            (<any>this).lastItemOnPage = _data["lastItemOnPage"];
        }
    }

    static fromJS(data: any): PaginationMeta {
        data = typeof data === 'object' ? data : {};
        let result = new PaginationMeta();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        data["totalCount"] = this.totalCount;
        data["totalPages"] = this.totalPages;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        data["firstItemOnPage"] = this.firstItemOnPage;
        data["lastItemOnPage"] = this.lastItemOnPage;
        return data;
    }
}

export interface IPaginationMeta {
    pageNumber?: number;
    pageSize?: number;
    totalCount?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    firstItemOnPage?: number;
    lastItemOnPage?: number;
}

export class PerformanceDataPoint implements IPerformanceDataPoint {
    date?: Date;
    value?: number;
    sampleCount?: number;

    constructor(data?: IPerformanceDataPoint) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.value = _data["value"];
            this.sampleCount = _data["sampleCount"];
        }
    }

    static fromJS(data: any): PerformanceDataPoint {
        data = typeof data === 'object' ? data : {};
        let result = new PerformanceDataPoint();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["value"] = this.value;
        data["sampleCount"] = this.sampleCount;
        return data;
    }
}

export interface IPerformanceDataPoint {
    date?: Date;
    value?: number;
    sampleCount?: number;
}

export enum PerformanceRating {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export class PerformanceTrendDto implements IPerformanceTrendDto {
    metricName?: string | undefined;
    dataPoints?: PerformanceDataPoint[] | undefined;
    currentAverage?: number;
    previousAverage?: number;
    trend?: ComparisonTrend;
    percentageChange?: number;

    constructor(data?: IPerformanceTrendDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.metricName = _data["metricName"];
            if (Array.isArray(_data["dataPoints"])) {
                this.dataPoints = [] as any;
                for (let item of _data["dataPoints"])
                    this.dataPoints!.push(PerformanceDataPoint.fromJS(item));
            }
            this.currentAverage = _data["currentAverage"];
            this.previousAverage = _data["previousAverage"];
            this.trend = _data["trend"];
            this.percentageChange = _data["percentageChange"];
        }
    }

    static fromJS(data: any): PerformanceTrendDto {
        data = typeof data === 'object' ? data : {};
        let result = new PerformanceTrendDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["metricName"] = this.metricName;
        if (Array.isArray(this.dataPoints)) {
            data["dataPoints"] = [];
            for (let item of this.dataPoints)
                data["dataPoints"].push(item ? item.toJSON() : <any>undefined);
        }
        data["currentAverage"] = this.currentAverage;
        data["previousAverage"] = this.previousAverage;
        data["trend"] = this.trend;
        data["percentageChange"] = this.percentageChange;
        return data;
    }
}

export interface IPerformanceTrendDto {
    metricName?: string | undefined;
    dataPoints?: PerformanceDataPoint[] | undefined;
    currentAverage?: number;
    previousAverage?: number;
    trend?: ComparisonTrend;
    percentageChange?: number;
}

export class PermissionDto implements IPermissionDto {
    permissionId?: string;
    name?: string | undefined;
    description?: string | undefined;
    category?: string | undefined;
    createdAt?: Date;
    updatedAt?: Date;

    constructor(data?: IPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.permissionId = _data["permissionId"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.category = _data["category"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): PermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["permissionId"] = this.permissionId;
        data["name"] = this.name;
        data["description"] = this.description;
        data["category"] = this.category;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        return data;
    }
}

export interface IPermissionDto {
    permissionId?: string;
    name?: string | undefined;
    description?: string | undefined;
    category?: string | undefined;
    createdAt?: Date;
    updatedAt?: Date;
}

export class PermissionDtoApiResponse implements IPermissionDtoApiResponse {
    success?: boolean;
    data?: PermissionDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IPermissionDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"] ? PermissionDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): PermissionDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IPermissionDtoApiResponse {
    success?: boolean;
    data?: PermissionDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class PermissionDtoIEnumerableApiResponse implements IPermissionDtoIEnumerableApiResponse {
    success?: boolean;
    data?: PermissionDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IPermissionDtoIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(PermissionDto.fromJS(item));
            }
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): PermissionDtoIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDtoIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : <any>undefined);
        }
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IPermissionDtoIEnumerableApiResponse {
    success?: boolean;
    data?: PermissionDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class PopularTestUrlDto implements IPopularTestUrlDto {
    url?: string | undefined;
    testCount?: number;
    successRate?: number;
    averageExecutionTime?: number;
    lastTested?: Date | undefined;

    constructor(data?: IPopularTestUrlDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.url = _data["url"];
            this.testCount = _data["testCount"];
            this.successRate = _data["successRate"];
            this.averageExecutionTime = _data["averageExecutionTime"];
            this.lastTested = _data["lastTested"] ? new Date(_data["lastTested"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): PopularTestUrlDto {
        data = typeof data === 'object' ? data : {};
        let result = new PopularTestUrlDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        data["testCount"] = this.testCount;
        data["successRate"] = this.successRate;
        data["averageExecutionTime"] = this.averageExecutionTime;
        data["lastTested"] = this.lastTested ? this.lastTested.toISOString() : <any>undefined;
        return data;
    }
}

export interface IPopularTestUrlDto {
    url?: string | undefined;
    testCount?: number;
    successRate?: number;
    averageExecutionTime?: number;
    lastTested?: Date | undefined;
}

export class PriceAnalysisDto implements IPriceAnalysisDto {
    summary?: PriceComparisonSummaryDto;
    sellerComparisons?: SellerPriceComparisonDto[] | undefined;
    valueAnalysis?: ValueAnalysisDto;

    constructor(data?: IPriceAnalysisDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.summary = _data["summary"] ? PriceComparisonSummaryDto.fromJS(_data["summary"]) : <any>undefined;
            if (Array.isArray(_data["sellerComparisons"])) {
                this.sellerComparisons = [] as any;
                for (let item of _data["sellerComparisons"])
                    this.sellerComparisons!.push(SellerPriceComparisonDto.fromJS(item));
            }
            this.valueAnalysis = _data["valueAnalysis"] ? ValueAnalysisDto.fromJS(_data["valueAnalysis"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PriceAnalysisDto {
        data = typeof data === 'object' ? data : {};
        let result = new PriceAnalysisDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["summary"] = this.summary ? this.summary.toJSON() : <any>undefined;
        if (Array.isArray(this.sellerComparisons)) {
            data["sellerComparisons"] = [];
            for (let item of this.sellerComparisons)
                data["sellerComparisons"].push(item ? item.toJSON() : <any>undefined);
        }
        data["valueAnalysis"] = this.valueAnalysis ? this.valueAnalysis.toJSON() : <any>undefined;
        return data;
    }
}

export interface IPriceAnalysisDto {
    summary?: PriceComparisonSummaryDto;
    sellerComparisons?: SellerPriceComparisonDto[] | undefined;
    valueAnalysis?: ValueAnalysisDto;
}

export class PriceComparisonSummaryDto implements IPriceComparisonSummaryDto {
    product1LowestPrice?: number;
    product2LowestPrice?: number;
    priceDifference?: number;
    priceDifferencePercentage?: number;
    lowerPricedProduct?: string | undefined;
    product1SellerCount?: number;
    product2SellerCount?: number;

    constructor(data?: IPriceComparisonSummaryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.product1LowestPrice = _data["product1LowestPrice"];
            this.product2LowestPrice = _data["product2LowestPrice"];
            this.priceDifference = _data["priceDifference"];
            this.priceDifferencePercentage = _data["priceDifferencePercentage"];
            this.lowerPricedProduct = _data["lowerPricedProduct"];
            this.product1SellerCount = _data["product1SellerCount"];
            this.product2SellerCount = _data["product2SellerCount"];
        }
    }

    static fromJS(data: any): PriceComparisonSummaryDto {
        data = typeof data === 'object' ? data : {};
        let result = new PriceComparisonSummaryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["product1LowestPrice"] = this.product1LowestPrice;
        data["product2LowestPrice"] = this.product2LowestPrice;
        data["priceDifference"] = this.priceDifference;
        data["priceDifferencePercentage"] = this.priceDifferencePercentage;
        data["lowerPricedProduct"] = this.lowerPricedProduct;
        data["product1SellerCount"] = this.product1SellerCount;
        data["product2SellerCount"] = this.product2SellerCount;
        return data;
    }
}

export interface IPriceComparisonSummaryDto {
    product1LowestPrice?: number;
    product2LowestPrice?: number;
    priceDifference?: number;
    priceDifferencePercentage?: number;
    lowerPricedProduct?: string | undefined;
    product1SellerCount?: number;
    product2SellerCount?: number;
}

export class PriceHistoryDto implements IPriceHistoryDto {
    timestamp?: Date;
    price?: number;
    stockStatus?: string | undefined;
    sourceUrl?: string | undefined;
    scrapedProductNameOnPage?: string | undefined;

    constructor(data?: IPriceHistoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.price = _data["price"];
            this.stockStatus = _data["stockStatus"];
            this.sourceUrl = _data["sourceUrl"];
            this.scrapedProductNameOnPage = _data["scrapedProductNameOnPage"];
        }
    }

    static fromJS(data: any): PriceHistoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new PriceHistoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["price"] = this.price;
        data["stockStatus"] = this.stockStatus;
        data["sourceUrl"] = this.sourceUrl;
        data["scrapedProductNameOnPage"] = this.scrapedProductNameOnPage;
        return data;
    }
}

export interface IPriceHistoryDto {
    timestamp?: Date;
    price?: number;
    stockStatus?: string | undefined;
    sourceUrl?: string | undefined;
    scrapedProductNameOnPage?: string | undefined;
}

export class PriceHistoryDtoIEnumerableApiResponse implements IPriceHistoryDtoIEnumerableApiResponse {
    success?: boolean;
    data?: PriceHistoryDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IPriceHistoryDtoIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(PriceHistoryDto.fromJS(item));
            }
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): PriceHistoryDtoIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PriceHistoryDtoIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : <any>undefined);
        }
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IPriceHistoryDtoIEnumerableApiResponse {
    success?: boolean;
    data?: PriceHistoryDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class ProductComparisonResultDto implements IProductComparisonResultDto {
    summary?: ProductComparisonSummaryDto;
    product1?: ProductWithCurrentPricesDto;
    product2?: ProductWithCurrentPricesDto;
    specificationComparison?: SpecificationComparisonDto;
    priceAnalysis?: PriceAnalysisDto;
    recommendationAnalysis?: RecommendationAnalysisDto;
    generatedAt?: Date;

    constructor(data?: IProductComparisonResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.summary = _data["summary"] ? ProductComparisonSummaryDto.fromJS(_data["summary"]) : <any>undefined;
            this.product1 = _data["product1"] ? ProductWithCurrentPricesDto.fromJS(_data["product1"]) : <any>undefined;
            this.product2 = _data["product2"] ? ProductWithCurrentPricesDto.fromJS(_data["product2"]) : <any>undefined;
            this.specificationComparison = _data["specificationComparison"] ? SpecificationComparisonDto.fromJS(_data["specificationComparison"]) : <any>undefined;
            this.priceAnalysis = _data["priceAnalysis"] ? PriceAnalysisDto.fromJS(_data["priceAnalysis"]) : <any>undefined;
            this.recommendationAnalysis = _data["recommendationAnalysis"] ? RecommendationAnalysisDto.fromJS(_data["recommendationAnalysis"]) : <any>undefined;
            this.generatedAt = _data["generatedAt"] ? new Date(_data["generatedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ProductComparisonResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductComparisonResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["summary"] = this.summary ? this.summary.toJSON() : <any>undefined;
        data["product1"] = this.product1 ? this.product1.toJSON() : <any>undefined;
        data["product2"] = this.product2 ? this.product2.toJSON() : <any>undefined;
        data["specificationComparison"] = this.specificationComparison ? this.specificationComparison.toJSON() : <any>undefined;
        data["priceAnalysis"] = this.priceAnalysis ? this.priceAnalysis.toJSON() : <any>undefined;
        data["recommendationAnalysis"] = this.recommendationAnalysis ? this.recommendationAnalysis.toJSON() : <any>undefined;
        data["generatedAt"] = this.generatedAt ? this.generatedAt.toISOString() : <any>undefined;
        return data;
    }
}

export interface IProductComparisonResultDto {
    summary?: ProductComparisonSummaryDto;
    product1?: ProductWithCurrentPricesDto;
    product2?: ProductWithCurrentPricesDto;
    specificationComparison?: SpecificationComparisonDto;
    priceAnalysis?: PriceAnalysisDto;
    recommendationAnalysis?: RecommendationAnalysisDto;
    generatedAt?: Date;
}

export class ProductComparisonResultDtoApiResponse implements IProductComparisonResultDtoApiResponse {
    success?: boolean;
    data?: ProductComparisonResultDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IProductComparisonResultDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"] ? ProductComparisonResultDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): ProductComparisonResultDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ProductComparisonResultDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IProductComparisonResultDtoApiResponse {
    success?: boolean;
    data?: ProductComparisonResultDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class ProductComparisonSummaryDto implements IProductComparisonSummaryDto {
    categoryName?: string | undefined;
    totalSpecifications?: number;
    matchingSpecifications?: number;
    differentSpecifications?: number;
    product1OverallScore?: number;
    product2OverallScore?: number;
    recommendedProductId?: string | undefined;
    recommendationReason?: string | undefined;

    constructor(data?: IProductComparisonSummaryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.categoryName = _data["categoryName"];
            this.totalSpecifications = _data["totalSpecifications"];
            this.matchingSpecifications = _data["matchingSpecifications"];
            this.differentSpecifications = _data["differentSpecifications"];
            this.product1OverallScore = _data["product1OverallScore"];
            this.product2OverallScore = _data["product2OverallScore"];
            this.recommendedProductId = _data["recommendedProductId"];
            this.recommendationReason = _data["recommendationReason"];
        }
    }

    static fromJS(data: any): ProductComparisonSummaryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductComparisonSummaryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["categoryName"] = this.categoryName;
        data["totalSpecifications"] = this.totalSpecifications;
        data["matchingSpecifications"] = this.matchingSpecifications;
        data["differentSpecifications"] = this.differentSpecifications;
        data["product1OverallScore"] = this.product1OverallScore;
        data["product2OverallScore"] = this.product2OverallScore;
        data["recommendedProductId"] = this.recommendedProductId;
        data["recommendationReason"] = this.recommendationReason;
        return data;
    }
}

export interface IProductComparisonSummaryDto {
    categoryName?: string | undefined;
    totalSpecifications?: number;
    matchingSpecifications?: number;
    differentSpecifications?: number;
    product1OverallScore?: number;
    product2OverallScore?: number;
    recommendedProductId?: string | undefined;
    recommendationReason?: string | undefined;
}

export class ProductDto implements IProductDto {
    productId?: string;
    name?: string | undefined;
    manufacturer?: string | undefined;
    modelNumber?: string | undefined;
    sku?: string | undefined;
    categoryId?: string;
    description?: string | undefined;
    normalizedSpecifications?: { [key: string]: NormalizedSpecificationValue; } | undefined;
    uncategorizedSpecifications?: { [key: string]: string; } | undefined;
    isActive?: boolean;
    createdAt?: Date;
    updatedAt?: Date;
    primaryImageUrl?: string | undefined;
    additionalImageUrls?: string[] | undefined;
    originalImageUrls?: string[] | undefined;
    imageLastUpdated?: Date | undefined;
    category?: CategoryDto;

    constructor(data?: IProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.name = _data["name"];
            this.manufacturer = _data["manufacturer"];
            this.modelNumber = _data["modelNumber"];
            this.sku = _data["sku"];
            this.categoryId = _data["categoryId"];
            this.description = _data["description"];
            if (_data["normalizedSpecifications"]) {
                this.normalizedSpecifications = {} as any;
                for (let key in _data["normalizedSpecifications"]) {
                    if (_data["normalizedSpecifications"].hasOwnProperty(key))
                        (<any>this.normalizedSpecifications)![key] = _data["normalizedSpecifications"][key] ? NormalizedSpecificationValue.fromJS(_data["normalizedSpecifications"][key]) : new NormalizedSpecificationValue();
                }
            }
            if (_data["uncategorizedSpecifications"]) {
                this.uncategorizedSpecifications = {} as any;
                for (let key in _data["uncategorizedSpecifications"]) {
                    if (_data["uncategorizedSpecifications"].hasOwnProperty(key))
                        (<any>this.uncategorizedSpecifications)![key] = _data["uncategorizedSpecifications"][key];
                }
            }
            this.isActive = _data["isActive"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.primaryImageUrl = _data["primaryImageUrl"];
            if (Array.isArray(_data["additionalImageUrls"])) {
                this.additionalImageUrls = [] as any;
                for (let item of _data["additionalImageUrls"])
                    this.additionalImageUrls!.push(item);
            }
            if (Array.isArray(_data["originalImageUrls"])) {
                this.originalImageUrls = [] as any;
                for (let item of _data["originalImageUrls"])
                    this.originalImageUrls!.push(item);
            }
            this.imageLastUpdated = _data["imageLastUpdated"] ? new Date(_data["imageLastUpdated"].toString()) : <any>undefined;
            this.category = _data["category"] ? CategoryDto.fromJS(_data["category"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["name"] = this.name;
        data["manufacturer"] = this.manufacturer;
        data["modelNumber"] = this.modelNumber;
        data["sku"] = this.sku;
        data["categoryId"] = this.categoryId;
        data["description"] = this.description;
        if (this.normalizedSpecifications) {
            data["normalizedSpecifications"] = {};
            for (let key in this.normalizedSpecifications) {
                if (this.normalizedSpecifications.hasOwnProperty(key))
                    (<any>data["normalizedSpecifications"])[key] = this.normalizedSpecifications[key] ? this.normalizedSpecifications[key].toJSON() : <any>undefined;
            }
        }
        if (this.uncategorizedSpecifications) {
            data["uncategorizedSpecifications"] = {};
            for (let key in this.uncategorizedSpecifications) {
                if (this.uncategorizedSpecifications.hasOwnProperty(key))
                    (<any>data["uncategorizedSpecifications"])[key] = (<any>this.uncategorizedSpecifications)[key];
            }
        }
        data["isActive"] = this.isActive;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["primaryImageUrl"] = this.primaryImageUrl;
        if (Array.isArray(this.additionalImageUrls)) {
            data["additionalImageUrls"] = [];
            for (let item of this.additionalImageUrls)
                data["additionalImageUrls"].push(item);
        }
        if (Array.isArray(this.originalImageUrls)) {
            data["originalImageUrls"] = [];
            for (let item of this.originalImageUrls)
                data["originalImageUrls"].push(item);
        }
        data["imageLastUpdated"] = this.imageLastUpdated ? this.imageLastUpdated.toISOString() : <any>undefined;
        data["category"] = this.category ? this.category.toJSON() : <any>undefined;
        return data;
    }
}

export interface IProductDto {
    productId?: string;
    name?: string | undefined;
    manufacturer?: string | undefined;
    modelNumber?: string | undefined;
    sku?: string | undefined;
    categoryId?: string;
    description?: string | undefined;
    normalizedSpecifications?: { [key: string]: NormalizedSpecificationValue; } | undefined;
    uncategorizedSpecifications?: { [key: string]: string; } | undefined;
    isActive?: boolean;
    createdAt?: Date;
    updatedAt?: Date;
    primaryImageUrl?: string | undefined;
    additionalImageUrls?: string[] | undefined;
    originalImageUrls?: string[] | undefined;
    imageLastUpdated?: Date | undefined;
    category?: CategoryDto;
}

export class ProductDtoApiResponse implements IProductDtoApiResponse {
    success?: boolean;
    data?: ProductDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IProductDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"] ? ProductDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): ProductDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ProductDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IProductDtoApiResponse {
    success?: boolean;
    data?: ProductDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class ProductDtoPagedResponse implements IProductDtoPagedResponse {
    success?: boolean;
    data?: ProductDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
    pagination?: PaginationMeta;

    constructor(data?: IProductDtoPagedResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(ProductDto.fromJS(item));
            }
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
            this.pagination = _data["pagination"] ? PaginationMeta.fromJS(_data["pagination"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProductDtoPagedResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ProductDtoPagedResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : <any>undefined);
        }
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        data["pagination"] = this.pagination ? this.pagination.toJSON() : <any>undefined;
        return data;
    }
}

export interface IProductDtoPagedResponse {
    success?: boolean;
    data?: ProductDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
    pagination?: PaginationMeta;
}

export class ProductDtoPagedResponseApiResponse implements IProductDtoPagedResponseApiResponse {
    success?: boolean;
    data?: ProductDtoPagedResponse;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IProductDtoPagedResponseApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"] ? ProductDtoPagedResponse.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): ProductDtoPagedResponseApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ProductDtoPagedResponseApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IProductDtoPagedResponseApiResponse {
    success?: boolean;
    data?: ProductDtoPagedResponse;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class ProductSellerMappingDto implements IProductSellerMappingDto {
    mappingId?: string;
    canonicalProductId?: string;
    sellerName?: string | undefined;
    exactProductUrl?: string | undefined;
    isActiveForScraping?: boolean;
    scrapingFrequencyOverride?: string | undefined;
    siteConfigId?: string | undefined;
    lastScrapedAt?: Date | undefined;
    nextScrapeAt?: Date | undefined;
    lastScrapeStatus?: string | undefined;
    lastScrapeErrorCode?: string | undefined;
    consecutiveFailureCount?: number;
    createdAt?: Date;
    updatedAt?: Date;
    product?: ProductDto;
    siteConfiguration?: ScraperSiteConfigurationDto;

    constructor(data?: IProductSellerMappingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.mappingId = _data["mappingId"];
            this.canonicalProductId = _data["canonicalProductId"];
            this.sellerName = _data["sellerName"];
            this.exactProductUrl = _data["exactProductUrl"];
            this.isActiveForScraping = _data["isActiveForScraping"];
            this.scrapingFrequencyOverride = _data["scrapingFrequencyOverride"];
            this.siteConfigId = _data["siteConfigId"];
            this.lastScrapedAt = _data["lastScrapedAt"] ? new Date(_data["lastScrapedAt"].toString()) : <any>undefined;
            this.nextScrapeAt = _data["nextScrapeAt"] ? new Date(_data["nextScrapeAt"].toString()) : <any>undefined;
            this.lastScrapeStatus = _data["lastScrapeStatus"];
            this.lastScrapeErrorCode = _data["lastScrapeErrorCode"];
            this.consecutiveFailureCount = _data["consecutiveFailureCount"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.product = _data["product"] ? ProductDto.fromJS(_data["product"]) : <any>undefined;
            this.siteConfiguration = _data["siteConfiguration"] ? ScraperSiteConfigurationDto.fromJS(_data["siteConfiguration"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProductSellerMappingDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductSellerMappingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mappingId"] = this.mappingId;
        data["canonicalProductId"] = this.canonicalProductId;
        data["sellerName"] = this.sellerName;
        data["exactProductUrl"] = this.exactProductUrl;
        data["isActiveForScraping"] = this.isActiveForScraping;
        data["scrapingFrequencyOverride"] = this.scrapingFrequencyOverride;
        data["siteConfigId"] = this.siteConfigId;
        data["lastScrapedAt"] = this.lastScrapedAt ? this.lastScrapedAt.toISOString() : <any>undefined;
        data["nextScrapeAt"] = this.nextScrapeAt ? this.nextScrapeAt.toISOString() : <any>undefined;
        data["lastScrapeStatus"] = this.lastScrapeStatus;
        data["lastScrapeErrorCode"] = this.lastScrapeErrorCode;
        data["consecutiveFailureCount"] = this.consecutiveFailureCount;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        data["siteConfiguration"] = this.siteConfiguration ? this.siteConfiguration.toJSON() : <any>undefined;
        return data;
    }
}

export interface IProductSellerMappingDto {
    mappingId?: string;
    canonicalProductId?: string;
    sellerName?: string | undefined;
    exactProductUrl?: string | undefined;
    isActiveForScraping?: boolean;
    scrapingFrequencyOverride?: string | undefined;
    siteConfigId?: string | undefined;
    lastScrapedAt?: Date | undefined;
    nextScrapeAt?: Date | undefined;
    lastScrapeStatus?: string | undefined;
    lastScrapeErrorCode?: string | undefined;
    consecutiveFailureCount?: number;
    createdAt?: Date;
    updatedAt?: Date;
    product?: ProductDto;
    siteConfiguration?: ScraperSiteConfigurationDto;
}

export class ProductSellerMappingDtoApiResponse implements IProductSellerMappingDtoApiResponse {
    success?: boolean;
    data?: ProductSellerMappingDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IProductSellerMappingDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"] ? ProductSellerMappingDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): ProductSellerMappingDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ProductSellerMappingDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IProductSellerMappingDtoApiResponse {
    success?: boolean;
    data?: ProductSellerMappingDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class ProductSellerMappingDtoIEnumerableApiResponse implements IProductSellerMappingDtoIEnumerableApiResponse {
    success?: boolean;
    data?: ProductSellerMappingDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IProductSellerMappingDtoIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(ProductSellerMappingDto.fromJS(item));
            }
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): ProductSellerMappingDtoIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ProductSellerMappingDtoIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : <any>undefined);
        }
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IProductSellerMappingDtoIEnumerableApiResponse {
    success?: boolean;
    data?: ProductSellerMappingDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class ProductWithCurrentPricesDto implements IProductWithCurrentPricesDto {
    productId?: string;
    name?: string | undefined;
    manufacturer?: string | undefined;
    modelNumber?: string | undefined;
    sku?: string | undefined;
    categoryId?: string;
    description?: string | undefined;
    normalizedSpecifications?: { [key: string]: NormalizedSpecificationValue; } | undefined;
    uncategorizedSpecifications?: { [key: string]: string; } | undefined;
    isActive?: boolean;
    createdAt?: Date;
    updatedAt?: Date;
    primaryImageUrl?: string | undefined;
    additionalImageUrls?: string[] | undefined;
    originalImageUrls?: string[] | undefined;
    imageLastUpdated?: Date | undefined;
    category?: CategoryDto;
    currentPrices?: CurrentPriceDto[] | undefined;
    lowestCurrentPrice?: number | undefined;
    highestCurrentPrice?: number | undefined;
    availableSellersCount?: number;

    constructor(data?: IProductWithCurrentPricesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.name = _data["name"];
            this.manufacturer = _data["manufacturer"];
            this.modelNumber = _data["modelNumber"];
            this.sku = _data["sku"];
            this.categoryId = _data["categoryId"];
            this.description = _data["description"];
            if (_data["normalizedSpecifications"]) {
                this.normalizedSpecifications = {} as any;
                for (let key in _data["normalizedSpecifications"]) {
                    if (_data["normalizedSpecifications"].hasOwnProperty(key))
                        (<any>this.normalizedSpecifications)![key] = _data["normalizedSpecifications"][key] ? NormalizedSpecificationValue.fromJS(_data["normalizedSpecifications"][key]) : new NormalizedSpecificationValue();
                }
            }
            if (_data["uncategorizedSpecifications"]) {
                this.uncategorizedSpecifications = {} as any;
                for (let key in _data["uncategorizedSpecifications"]) {
                    if (_data["uncategorizedSpecifications"].hasOwnProperty(key))
                        (<any>this.uncategorizedSpecifications)![key] = _data["uncategorizedSpecifications"][key];
                }
            }
            this.isActive = _data["isActive"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.primaryImageUrl = _data["primaryImageUrl"];
            if (Array.isArray(_data["additionalImageUrls"])) {
                this.additionalImageUrls = [] as any;
                for (let item of _data["additionalImageUrls"])
                    this.additionalImageUrls!.push(item);
            }
            if (Array.isArray(_data["originalImageUrls"])) {
                this.originalImageUrls = [] as any;
                for (let item of _data["originalImageUrls"])
                    this.originalImageUrls!.push(item);
            }
            this.imageLastUpdated = _data["imageLastUpdated"] ? new Date(_data["imageLastUpdated"].toString()) : <any>undefined;
            this.category = _data["category"] ? CategoryDto.fromJS(_data["category"]) : <any>undefined;
            if (Array.isArray(_data["currentPrices"])) {
                this.currentPrices = [] as any;
                for (let item of _data["currentPrices"])
                    this.currentPrices!.push(CurrentPriceDto.fromJS(item));
            }
            this.lowestCurrentPrice = _data["lowestCurrentPrice"];
            this.highestCurrentPrice = _data["highestCurrentPrice"];
            this.availableSellersCount = _data["availableSellersCount"];
        }
    }

    static fromJS(data: any): ProductWithCurrentPricesDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductWithCurrentPricesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["name"] = this.name;
        data["manufacturer"] = this.manufacturer;
        data["modelNumber"] = this.modelNumber;
        data["sku"] = this.sku;
        data["categoryId"] = this.categoryId;
        data["description"] = this.description;
        if (this.normalizedSpecifications) {
            data["normalizedSpecifications"] = {};
            for (let key in this.normalizedSpecifications) {
                if (this.normalizedSpecifications.hasOwnProperty(key))
                    (<any>data["normalizedSpecifications"])[key] = this.normalizedSpecifications[key] ? this.normalizedSpecifications[key].toJSON() : <any>undefined;
            }
        }
        if (this.uncategorizedSpecifications) {
            data["uncategorizedSpecifications"] = {};
            for (let key in this.uncategorizedSpecifications) {
                if (this.uncategorizedSpecifications.hasOwnProperty(key))
                    (<any>data["uncategorizedSpecifications"])[key] = (<any>this.uncategorizedSpecifications)[key];
            }
        }
        data["isActive"] = this.isActive;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["primaryImageUrl"] = this.primaryImageUrl;
        if (Array.isArray(this.additionalImageUrls)) {
            data["additionalImageUrls"] = [];
            for (let item of this.additionalImageUrls)
                data["additionalImageUrls"].push(item);
        }
        if (Array.isArray(this.originalImageUrls)) {
            data["originalImageUrls"] = [];
            for (let item of this.originalImageUrls)
                data["originalImageUrls"].push(item);
        }
        data["imageLastUpdated"] = this.imageLastUpdated ? this.imageLastUpdated.toISOString() : <any>undefined;
        data["category"] = this.category ? this.category.toJSON() : <any>undefined;
        if (Array.isArray(this.currentPrices)) {
            data["currentPrices"] = [];
            for (let item of this.currentPrices)
                data["currentPrices"].push(item ? item.toJSON() : <any>undefined);
        }
        data["lowestCurrentPrice"] = this.lowestCurrentPrice;
        data["highestCurrentPrice"] = this.highestCurrentPrice;
        data["availableSellersCount"] = this.availableSellersCount;
        return data;
    }
}

export interface IProductWithCurrentPricesDto {
    productId?: string;
    name?: string | undefined;
    manufacturer?: string | undefined;
    modelNumber?: string | undefined;
    sku?: string | undefined;
    categoryId?: string;
    description?: string | undefined;
    normalizedSpecifications?: { [key: string]: NormalizedSpecificationValue; } | undefined;
    uncategorizedSpecifications?: { [key: string]: string; } | undefined;
    isActive?: boolean;
    createdAt?: Date;
    updatedAt?: Date;
    primaryImageUrl?: string | undefined;
    additionalImageUrls?: string[] | undefined;
    originalImageUrls?: string[] | undefined;
    imageLastUpdated?: Date | undefined;
    category?: CategoryDto;
    currentPrices?: CurrentPriceDto[] | undefined;
    lowestCurrentPrice?: number | undefined;
    highestCurrentPrice?: number | undefined;
    availableSellersCount?: number;
}

export class ProductWithCurrentPricesDtoApiResponse implements IProductWithCurrentPricesDtoApiResponse {
    success?: boolean;
    data?: ProductWithCurrentPricesDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IProductWithCurrentPricesDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"] ? ProductWithCurrentPricesDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): ProductWithCurrentPricesDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ProductWithCurrentPricesDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IProductWithCurrentPricesDtoApiResponse {
    success?: boolean;
    data?: ProductWithCurrentPricesDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class ProductWithCurrentPricesDtoPagedResponse implements IProductWithCurrentPricesDtoPagedResponse {
    success?: boolean;
    data?: ProductWithCurrentPricesDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
    pagination?: PaginationMeta;

    constructor(data?: IProductWithCurrentPricesDtoPagedResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(ProductWithCurrentPricesDto.fromJS(item));
            }
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
            this.pagination = _data["pagination"] ? PaginationMeta.fromJS(_data["pagination"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProductWithCurrentPricesDtoPagedResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ProductWithCurrentPricesDtoPagedResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : <any>undefined);
        }
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        data["pagination"] = this.pagination ? this.pagination.toJSON() : <any>undefined;
        return data;
    }
}

export interface IProductWithCurrentPricesDtoPagedResponse {
    success?: boolean;
    data?: ProductWithCurrentPricesDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
    pagination?: PaginationMeta;
}

export class ProfileValidationRequestDto implements IProfileValidationRequestDto {
    profile?: BrowserAutomationProfileDto;

    constructor(data?: IProfileValidationRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.profile = _data["profile"] ? BrowserAutomationProfileDto.fromJS(_data["profile"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProfileValidationRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProfileValidationRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["profile"] = this.profile ? this.profile.toJSON() : <any>undefined;
        return data;
    }
}

export interface IProfileValidationRequestDto {
    profile?: BrowserAutomationProfileDto;
}

export class ProfileValidationResultDto implements IProfileValidationResultDto {
    isValid?: boolean;
    warnings?: string[] | undefined;
    errors?: string[] | undefined;

    constructor(data?: IProfileValidationResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isValid = _data["isValid"];
            if (Array.isArray(_data["warnings"])) {
                this.warnings = [] as any;
                for (let item of _data["warnings"])
                    this.warnings!.push(item);
            }
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ProfileValidationResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProfileValidationResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isValid"] = this.isValid;
        if (Array.isArray(this.warnings)) {
            data["warnings"] = [];
            for (let item of this.warnings)
                data["warnings"].push(item);
        }
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IProfileValidationResultDto {
    isValid?: boolean;
    warnings?: string[] | undefined;
    errors?: string[] | undefined;
}

export class ProfileValidationResultDtoApiResponse implements IProfileValidationResultDtoApiResponse {
    success?: boolean;
    data?: ProfileValidationResultDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IProfileValidationResultDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"] ? ProfileValidationResultDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): ProfileValidationResultDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ProfileValidationResultDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IProfileValidationResultDtoApiResponse {
    success?: boolean;
    data?: ProfileValidationResultDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class ProviderModelsRequestDto implements IProviderModelsRequestDto {
    baseUrl?: string | undefined;
    apiKey?: string | undefined;

    constructor(data?: IProviderModelsRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.baseUrl = _data["baseUrl"];
            this.apiKey = _data["apiKey"];
        }
    }

    static fromJS(data: any): ProviderModelsRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProviderModelsRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["baseUrl"] = this.baseUrl;
        data["apiKey"] = this.apiKey;
        return data;
    }
}

export interface IProviderModelsRequestDto {
    baseUrl?: string | undefined;
    apiKey?: string | undefined;
}

export class ProxyConfigurationDto implements IProxyConfigurationDto {
    proxyConfigurationId?: string;
    host?: string | undefined;
    port?: number;
    proxyType?: string | undefined;
    username?: string | undefined;
    hasPassword?: boolean;
    description?: string | undefined;
    isActive?: boolean;
    isHealthy?: boolean;
    lastTestedAt?: Date | undefined;
    lastUsedAt?: Date | undefined;
    successRate?: number;
    totalRequests?: number;
    successfulRequests?: number;
    failedRequests?: number;
    consecutiveFailures?: number;
    timeoutSeconds?: number;
    maxRetries?: number;
    lastErrorMessage?: string | undefined;
    lastErrorCode?: string | undefined;
    createdAt?: Date;
    updatedAt?: Date;
    displayName?: string | undefined;
    requiresAuthentication?: boolean;
    isReliable?: boolean;
    statusDescription?: string | undefined;

    constructor(data?: IProxyConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.proxyConfigurationId = _data["proxyConfigurationId"];
            this.host = _data["host"];
            this.port = _data["port"];
            this.proxyType = _data["proxyType"];
            this.username = _data["username"];
            this.hasPassword = _data["hasPassword"];
            this.description = _data["description"];
            this.isActive = _data["isActive"];
            this.isHealthy = _data["isHealthy"];
            this.lastTestedAt = _data["lastTestedAt"] ? new Date(_data["lastTestedAt"].toString()) : <any>undefined;
            this.lastUsedAt = _data["lastUsedAt"] ? new Date(_data["lastUsedAt"].toString()) : <any>undefined;
            this.successRate = _data["successRate"];
            this.totalRequests = _data["totalRequests"];
            this.successfulRequests = _data["successfulRequests"];
            this.failedRequests = _data["failedRequests"];
            this.consecutiveFailures = _data["consecutiveFailures"];
            this.timeoutSeconds = _data["timeoutSeconds"];
            this.maxRetries = _data["maxRetries"];
            this.lastErrorMessage = _data["lastErrorMessage"];
            this.lastErrorCode = _data["lastErrorCode"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.displayName = _data["displayName"];
            this.requiresAuthentication = _data["requiresAuthentication"];
            this.isReliable = _data["isReliable"];
            this.statusDescription = _data["statusDescription"];
        }
    }

    static fromJS(data: any): ProxyConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProxyConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["proxyConfigurationId"] = this.proxyConfigurationId;
        data["host"] = this.host;
        data["port"] = this.port;
        data["proxyType"] = this.proxyType;
        data["username"] = this.username;
        data["hasPassword"] = this.hasPassword;
        data["description"] = this.description;
        data["isActive"] = this.isActive;
        data["isHealthy"] = this.isHealthy;
        data["lastTestedAt"] = this.lastTestedAt ? this.lastTestedAt.toISOString() : <any>undefined;
        data["lastUsedAt"] = this.lastUsedAt ? this.lastUsedAt.toISOString() : <any>undefined;
        data["successRate"] = this.successRate;
        data["totalRequests"] = this.totalRequests;
        data["successfulRequests"] = this.successfulRequests;
        data["failedRequests"] = this.failedRequests;
        data["consecutiveFailures"] = this.consecutiveFailures;
        data["timeoutSeconds"] = this.timeoutSeconds;
        data["maxRetries"] = this.maxRetries;
        data["lastErrorMessage"] = this.lastErrorMessage;
        data["lastErrorCode"] = this.lastErrorCode;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["displayName"] = this.displayName;
        data["requiresAuthentication"] = this.requiresAuthentication;
        data["isReliable"] = this.isReliable;
        data["statusDescription"] = this.statusDescription;
        return data;
    }
}

export interface IProxyConfigurationDto {
    proxyConfigurationId?: string;
    host?: string | undefined;
    port?: number;
    proxyType?: string | undefined;
    username?: string | undefined;
    hasPassword?: boolean;
    description?: string | undefined;
    isActive?: boolean;
    isHealthy?: boolean;
    lastTestedAt?: Date | undefined;
    lastUsedAt?: Date | undefined;
    successRate?: number;
    totalRequests?: number;
    successfulRequests?: number;
    failedRequests?: number;
    consecutiveFailures?: number;
    timeoutSeconds?: number;
    maxRetries?: number;
    lastErrorMessage?: string | undefined;
    lastErrorCode?: string | undefined;
    createdAt?: Date;
    updatedAt?: Date;
    displayName?: string | undefined;
    requiresAuthentication?: boolean;
    isReliable?: boolean;
    statusDescription?: string | undefined;
}

export class ProxyConfigurationDtoApiResponse implements IProxyConfigurationDtoApiResponse {
    success?: boolean;
    data?: ProxyConfigurationDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IProxyConfigurationDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"] ? ProxyConfigurationDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): ProxyConfigurationDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ProxyConfigurationDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IProxyConfigurationDtoApiResponse {
    success?: boolean;
    data?: ProxyConfigurationDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class ProxyConfigurationDtoIEnumerableApiResponse implements IProxyConfigurationDtoIEnumerableApiResponse {
    success?: boolean;
    data?: ProxyConfigurationDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IProxyConfigurationDtoIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(ProxyConfigurationDto.fromJS(item));
            }
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): ProxyConfigurationDtoIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ProxyConfigurationDtoIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : <any>undefined);
        }
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IProxyConfigurationDtoIEnumerableApiResponse {
    success?: boolean;
    data?: ProxyConfigurationDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class ProxyImportItemDto implements IProxyImportItemDto {
    host!: string;
    port!: number;
    proxyType!: string;
    username?: string | undefined;
    password?: string | undefined;
    description?: string | undefined;
    timeoutSeconds?: number;
    maxRetries?: number;
    isValid?: boolean;
    validationErrors?: string[] | undefined;
    alreadyExists?: boolean;

    constructor(data?: IProxyImportItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.host = _data["host"];
            this.port = _data["port"];
            this.proxyType = _data["proxyType"];
            this.username = _data["username"];
            this.password = _data["password"];
            this.description = _data["description"];
            this.timeoutSeconds = _data["timeoutSeconds"];
            this.maxRetries = _data["maxRetries"];
            this.isValid = _data["isValid"];
            if (Array.isArray(_data["validationErrors"])) {
                this.validationErrors = [] as any;
                for (let item of _data["validationErrors"])
                    this.validationErrors!.push(item);
            }
            this.alreadyExists = _data["alreadyExists"];
        }
    }

    static fromJS(data: any): ProxyImportItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProxyImportItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["host"] = this.host;
        data["port"] = this.port;
        data["proxyType"] = this.proxyType;
        data["username"] = this.username;
        data["password"] = this.password;
        data["description"] = this.description;
        data["timeoutSeconds"] = this.timeoutSeconds;
        data["maxRetries"] = this.maxRetries;
        data["isValid"] = this.isValid;
        if (Array.isArray(this.validationErrors)) {
            data["validationErrors"] = [];
            for (let item of this.validationErrors)
                data["validationErrors"].push(item);
        }
        data["alreadyExists"] = this.alreadyExists;
        return data;
    }
}

export interface IProxyImportItemDto {
    host: string;
    port: number;
    proxyType: string;
    username?: string | undefined;
    password?: string | undefined;
    description?: string | undefined;
    timeoutSeconds?: number;
    maxRetries?: number;
    isValid?: boolean;
    validationErrors?: string[] | undefined;
    alreadyExists?: boolean;
}

export class ProxyImportItemDtoIEnumerableApiResponse implements IProxyImportItemDtoIEnumerableApiResponse {
    success?: boolean;
    data?: ProxyImportItemDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IProxyImportItemDtoIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(ProxyImportItemDto.fromJS(item));
            }
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): ProxyImportItemDtoIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ProxyImportItemDtoIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : <any>undefined);
        }
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IProxyImportItemDtoIEnumerableApiResponse {
    success?: boolean;
    data?: ProxyImportItemDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class ProxyStatsDto implements IProxyStatsDto {
    totalProxies?: number;
    activeProxies?: number;
    healthyProxies?: number;
    averageSuccessRate?: number;
    proxiesWithErrors?: number;
    proxiesByType?: { [key: string]: number; } | undefined;
    proxiesByStatus?: { [key: string]: number; } | undefined;

    constructor(data?: IProxyStatsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalProxies = _data["totalProxies"];
            this.activeProxies = _data["activeProxies"];
            this.healthyProxies = _data["healthyProxies"];
            this.averageSuccessRate = _data["averageSuccessRate"];
            this.proxiesWithErrors = _data["proxiesWithErrors"];
            if (_data["proxiesByType"]) {
                this.proxiesByType = {} as any;
                for (let key in _data["proxiesByType"]) {
                    if (_data["proxiesByType"].hasOwnProperty(key))
                        (<any>this.proxiesByType)![key] = _data["proxiesByType"][key];
                }
            }
            if (_data["proxiesByStatus"]) {
                this.proxiesByStatus = {} as any;
                for (let key in _data["proxiesByStatus"]) {
                    if (_data["proxiesByStatus"].hasOwnProperty(key))
                        (<any>this.proxiesByStatus)![key] = _data["proxiesByStatus"][key];
                }
            }
        }
    }

    static fromJS(data: any): ProxyStatsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProxyStatsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalProxies"] = this.totalProxies;
        data["activeProxies"] = this.activeProxies;
        data["healthyProxies"] = this.healthyProxies;
        data["averageSuccessRate"] = this.averageSuccessRate;
        data["proxiesWithErrors"] = this.proxiesWithErrors;
        if (this.proxiesByType) {
            data["proxiesByType"] = {};
            for (let key in this.proxiesByType) {
                if (this.proxiesByType.hasOwnProperty(key))
                    (<any>data["proxiesByType"])[key] = (<any>this.proxiesByType)[key];
            }
        }
        if (this.proxiesByStatus) {
            data["proxiesByStatus"] = {};
            for (let key in this.proxiesByStatus) {
                if (this.proxiesByStatus.hasOwnProperty(key))
                    (<any>data["proxiesByStatus"])[key] = (<any>this.proxiesByStatus)[key];
            }
        }
        return data;
    }
}

export interface IProxyStatsDto {
    totalProxies?: number;
    activeProxies?: number;
    healthyProxies?: number;
    averageSuccessRate?: number;
    proxiesWithErrors?: number;
    proxiesByType?: { [key: string]: number; } | undefined;
    proxiesByStatus?: { [key: string]: number; } | undefined;
}

export class ProxyStatsDtoApiResponse implements IProxyStatsDtoApiResponse {
    success?: boolean;
    data?: ProxyStatsDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IProxyStatsDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"] ? ProxyStatsDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): ProxyStatsDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ProxyStatsDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IProxyStatsDtoApiResponse {
    success?: boolean;
    data?: ProxyStatsDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class ProxyTestResultDto implements IProxyTestResultDto {
    proxyConfigurationId?: string;
    host?: string | undefined;
    port?: number;
    proxyType?: string | undefined;
    isHealthy?: boolean;
    responseTimeMs?: number;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    testedAt?: Date;

    constructor(data?: IProxyTestResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.proxyConfigurationId = _data["proxyConfigurationId"];
            this.host = _data["host"];
            this.port = _data["port"];
            this.proxyType = _data["proxyType"];
            this.isHealthy = _data["isHealthy"];
            this.responseTimeMs = _data["responseTimeMs"];
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            this.testedAt = _data["testedAt"] ? new Date(_data["testedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ProxyTestResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProxyTestResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["proxyConfigurationId"] = this.proxyConfigurationId;
        data["host"] = this.host;
        data["port"] = this.port;
        data["proxyType"] = this.proxyType;
        data["isHealthy"] = this.isHealthy;
        data["responseTimeMs"] = this.responseTimeMs;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        data["testedAt"] = this.testedAt ? this.testedAt.toISOString() : <any>undefined;
        return data;
    }
}

export interface IProxyTestResultDto {
    proxyConfigurationId?: string;
    host?: string | undefined;
    port?: number;
    proxyType?: string | undefined;
    isHealthy?: boolean;
    responseTimeMs?: number;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    testedAt?: Date;
}

export class ProxyTestResultDtoApiResponse implements IProxyTestResultDtoApiResponse {
    success?: boolean;
    data?: ProxyTestResultDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IProxyTestResultDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"] ? ProxyTestResultDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): ProxyTestResultDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ProxyTestResultDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IProxyTestResultDtoApiResponse {
    success?: boolean;
    data?: ProxyTestResultDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class ProxyTestResultDtoIEnumerableApiResponse implements IProxyTestResultDtoIEnumerableApiResponse {
    success?: boolean;
    data?: ProxyTestResultDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IProxyTestResultDtoIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(ProxyTestResultDto.fromJS(item));
            }
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): ProxyTestResultDtoIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ProxyTestResultDtoIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : <any>undefined);
        }
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IProxyTestResultDtoIEnumerableApiResponse {
    success?: boolean;
    data?: ProxyTestResultDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class ProxyTextParseDto implements IProxyTextParseDto {
    proxyText!: string;
    defaultProxyType?: string | undefined;

    constructor(data?: IProxyTextParseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.proxyText = _data["proxyText"];
            this.defaultProxyType = _data["defaultProxyType"];
        }
    }

    static fromJS(data: any): ProxyTextParseDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProxyTextParseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["proxyText"] = this.proxyText;
        data["defaultProxyType"] = this.defaultProxyType;
        return data;
    }
}

export interface IProxyTextParseDto {
    proxyText: string;
    defaultProxyType?: string | undefined;
}

export class ProxyUsageUpdateDto implements IProxyUsageUpdateDto {
    proxyConfigurationId?: string;
    success?: boolean;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    responseTimeMs?: number;

    constructor(data?: IProxyUsageUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.proxyConfigurationId = _data["proxyConfigurationId"];
            this.success = _data["success"];
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            this.responseTimeMs = _data["responseTimeMs"];
        }
    }

    static fromJS(data: any): ProxyUsageUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProxyUsageUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["proxyConfigurationId"] = this.proxyConfigurationId;
        data["success"] = this.success;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        data["responseTimeMs"] = this.responseTimeMs;
        return data;
    }
}

export interface IProxyUsageUpdateDto {
    proxyConfigurationId?: string;
    success?: boolean;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    responseTimeMs?: number;
}

export class RealTimeAlertMonitoringDto implements IRealTimeAlertMonitoringDto {
    lastUpdated?: Date;
    alertsInLastMinute?: number;
    alertsInLastHour?: number;
    notificationsInLastMinute?: number;
    notificationsInLastHour?: number;
    currentQueueSize?: number;
    averageProcessingTime?: string;
    recentActivity?: RecentAlertActivityDto[] | undefined;
    recentEvents?: AlertSystemEventDto[] | undefined;

    constructor(data?: IRealTimeAlertMonitoringDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.lastUpdated = _data["lastUpdated"] ? new Date(_data["lastUpdated"].toString()) : <any>undefined;
            this.alertsInLastMinute = _data["alertsInLastMinute"];
            this.alertsInLastHour = _data["alertsInLastHour"];
            this.notificationsInLastMinute = _data["notificationsInLastMinute"];
            this.notificationsInLastHour = _data["notificationsInLastHour"];
            this.currentQueueSize = _data["currentQueueSize"];
            this.averageProcessingTime = _data["averageProcessingTime"];
            if (Array.isArray(_data["recentActivity"])) {
                this.recentActivity = [] as any;
                for (let item of _data["recentActivity"])
                    this.recentActivity!.push(RecentAlertActivityDto.fromJS(item));
            }
            if (Array.isArray(_data["recentEvents"])) {
                this.recentEvents = [] as any;
                for (let item of _data["recentEvents"])
                    this.recentEvents!.push(AlertSystemEventDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RealTimeAlertMonitoringDto {
        data = typeof data === 'object' ? data : {};
        let result = new RealTimeAlertMonitoringDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lastUpdated"] = this.lastUpdated ? this.lastUpdated.toISOString() : <any>undefined;
        data["alertsInLastMinute"] = this.alertsInLastMinute;
        data["alertsInLastHour"] = this.alertsInLastHour;
        data["notificationsInLastMinute"] = this.notificationsInLastMinute;
        data["notificationsInLastHour"] = this.notificationsInLastHour;
        data["currentQueueSize"] = this.currentQueueSize;
        data["averageProcessingTime"] = this.averageProcessingTime;
        if (Array.isArray(this.recentActivity)) {
            data["recentActivity"] = [];
            for (let item of this.recentActivity)
                data["recentActivity"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.recentEvents)) {
            data["recentEvents"] = [];
            for (let item of this.recentEvents)
                data["recentEvents"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface IRealTimeAlertMonitoringDto {
    lastUpdated?: Date;
    alertsInLastMinute?: number;
    alertsInLastHour?: number;
    notificationsInLastMinute?: number;
    notificationsInLastHour?: number;
    currentQueueSize?: number;
    averageProcessingTime?: string;
    recentActivity?: RecentAlertActivityDto[] | undefined;
    recentEvents?: AlertSystemEventDto[] | undefined;
}

export class RealTimeAlertMonitoringDtoApiResponse implements IRealTimeAlertMonitoringDtoApiResponse {
    success?: boolean;
    data?: RealTimeAlertMonitoringDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IRealTimeAlertMonitoringDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"] ? RealTimeAlertMonitoringDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): RealTimeAlertMonitoringDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RealTimeAlertMonitoringDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IRealTimeAlertMonitoringDtoApiResponse {
    success?: boolean;
    data?: RealTimeAlertMonitoringDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class RecentAlertActivityDto implements IRecentAlertActivityDto {
    timestamp?: Date;
    alertRuleId?: string;
    productName?: string | undefined;
    conditionType?: string | undefined;
    triggeringPrice?: number;
    status?: string | undefined;
    processingTime?: string;

    constructor(data?: IRecentAlertActivityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.alertRuleId = _data["alertRuleId"];
            this.productName = _data["productName"];
            this.conditionType = _data["conditionType"];
            this.triggeringPrice = _data["triggeringPrice"];
            this.status = _data["status"];
            this.processingTime = _data["processingTime"];
        }
    }

    static fromJS(data: any): RecentAlertActivityDto {
        data = typeof data === 'object' ? data : {};
        let result = new RecentAlertActivityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["alertRuleId"] = this.alertRuleId;
        data["productName"] = this.productName;
        data["conditionType"] = this.conditionType;
        data["triggeringPrice"] = this.triggeringPrice;
        data["status"] = this.status;
        data["processingTime"] = this.processingTime;
        return data;
    }
}

export interface IRecentAlertActivityDto {
    timestamp?: Date;
    alertRuleId?: string;
    productName?: string | undefined;
    conditionType?: string | undefined;
    triggeringPrice?: number;
    status?: string | undefined;
    processingTime?: string;
}

export class RecommendationAnalysisDto implements IRecommendationAnalysisDto {
    recommendedProductId?: string | undefined;
    confidenceScore?: number;
    primaryReason?: string | undefined;
    factors?: RecommendationFactorDto[] | undefined;
    pros?: string[] | undefined;
    cons?: string[] | undefined;
    useCase?: string | undefined;
    alternativeRecommendation?: string | undefined;

    constructor(data?: IRecommendationAnalysisDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.recommendedProductId = _data["recommendedProductId"];
            this.confidenceScore = _data["confidenceScore"];
            this.primaryReason = _data["primaryReason"];
            if (Array.isArray(_data["factors"])) {
                this.factors = [] as any;
                for (let item of _data["factors"])
                    this.factors!.push(RecommendationFactorDto.fromJS(item));
            }
            if (Array.isArray(_data["pros"])) {
                this.pros = [] as any;
                for (let item of _data["pros"])
                    this.pros!.push(item);
            }
            if (Array.isArray(_data["cons"])) {
                this.cons = [] as any;
                for (let item of _data["cons"])
                    this.cons!.push(item);
            }
            this.useCase = _data["useCase"];
            this.alternativeRecommendation = _data["alternativeRecommendation"];
        }
    }

    static fromJS(data: any): RecommendationAnalysisDto {
        data = typeof data === 'object' ? data : {};
        let result = new RecommendationAnalysisDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["recommendedProductId"] = this.recommendedProductId;
        data["confidenceScore"] = this.confidenceScore;
        data["primaryReason"] = this.primaryReason;
        if (Array.isArray(this.factors)) {
            data["factors"] = [];
            for (let item of this.factors)
                data["factors"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.pros)) {
            data["pros"] = [];
            for (let item of this.pros)
                data["pros"].push(item);
        }
        if (Array.isArray(this.cons)) {
            data["cons"] = [];
            for (let item of this.cons)
                data["cons"].push(item);
        }
        data["useCase"] = this.useCase;
        data["alternativeRecommendation"] = this.alternativeRecommendation;
        return data;
    }
}

export interface IRecommendationAnalysisDto {
    recommendedProductId?: string | undefined;
    confidenceScore?: number;
    primaryReason?: string | undefined;
    factors?: RecommendationFactorDto[] | undefined;
    pros?: string[] | undefined;
    cons?: string[] | undefined;
    useCase?: string | undefined;
    alternativeRecommendation?: string | undefined;
}

export class RecommendationFactorDto implements IRecommendationFactorDto {
    factor?: string | undefined;
    weight?: number;
    product1Score?: number;
    product2Score?: number;
    impact?: string | undefined;

    constructor(data?: IRecommendationFactorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.factor = _data["factor"];
            this.weight = _data["weight"];
            this.product1Score = _data["product1Score"];
            this.product2Score = _data["product2Score"];
            this.impact = _data["impact"];
        }
    }

    static fromJS(data: any): RecommendationFactorDto {
        data = typeof data === 'object' ? data : {};
        let result = new RecommendationFactorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["factor"] = this.factor;
        data["weight"] = this.weight;
        data["product1Score"] = this.product1Score;
        data["product2Score"] = this.product2Score;
        data["impact"] = this.impact;
        return data;
    }
}

export interface IRecommendationFactorDto {
    factor?: string | undefined;
    weight?: number;
    product1Score?: number;
    product2Score?: number;
    impact?: string | undefined;
}

export class RegisterUserDto implements IRegisterUserDto {
    email!: string;
    password!: string;
    firstName?: string | undefined;
    lastName?: string | undefined;

    constructor(data?: IRegisterUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
        }
    }

    static fromJS(data: any): RegisterUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        return data;
    }
}

export interface IRegisterUserDto {
    email: string;
    password: string;
    firstName?: string | undefined;
    lastName?: string | undefined;
}

export class RoleInfoDto implements IRoleInfoDto {
    id?: string;
    name?: string | undefined;
    displayName?: string | undefined;
    description?: string | undefined;
    userCount?: number;
    isSystemRole?: boolean;

    constructor(data?: IRoleInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.userCount = _data["userCount"];
            this.isSystemRole = _data["isSystemRole"];
        }
    }

    static fromJS(data: any): RoleInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["userCount"] = this.userCount;
        data["isSystemRole"] = this.isSystemRole;
        return data;
    }
}

export interface IRoleInfoDto {
    id?: string;
    name?: string | undefined;
    displayName?: string | undefined;
    description?: string | undefined;
    userCount?: number;
    isSystemRole?: boolean;
}

export class RoleInfoDtoApiResponse implements IRoleInfoDtoApiResponse {
    success?: boolean;
    data?: RoleInfoDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IRoleInfoDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"] ? RoleInfoDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): RoleInfoDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RoleInfoDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IRoleInfoDtoApiResponse {
    success?: boolean;
    data?: RoleInfoDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class RoleInfoDtoIEnumerableApiResponse implements IRoleInfoDtoIEnumerableApiResponse {
    success?: boolean;
    data?: RoleInfoDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IRoleInfoDtoIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(RoleInfoDto.fromJS(item));
            }
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): RoleInfoDtoIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RoleInfoDtoIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : <any>undefined);
        }
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IRoleInfoDtoIEnumerableApiResponse {
    success?: boolean;
    data?: RoleInfoDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class SaveTestResultRequestDto implements ISaveTestResultRequestDto {
    name?: string | undefined;
    description?: string | undefined;
    tags?: string[] | undefined;

    constructor(data?: ISaveTestResultRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
        }
    }

    static fromJS(data: any): SaveTestResultRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new SaveTestResultRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        return data;
    }
}

export interface ISaveTestResultRequestDto {
    name?: string | undefined;
    description?: string | undefined;
    tags?: string[] | undefined;
}

export class SavedTestResultDetailDto implements ISavedTestResultDetailDto {
    id?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    tags?: string[] | undefined;
    testUrl?: string | undefined;
    success?: boolean;
    savedAt?: Date;
    executedAt?: Date;
    duration?: number;
    actionsExecuted?: number;
    errorCount?: number;
    profileHash?: string | undefined;
    createdBy?: string | undefined;
    testResult?: BrowserAutomationTestResultDto;
    profile?: BrowserAutomationProfileDto;
    options?: BrowserTestOptionsDto;
    screenshots?: string[] | undefined;
    videoRecording?: string | undefined;
    metadata?: { [key: string]: any; } | undefined;

    constructor(data?: ISavedTestResultDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
            this.testUrl = _data["testUrl"];
            this.success = _data["success"];
            this.savedAt = _data["savedAt"] ? new Date(_data["savedAt"].toString()) : <any>undefined;
            this.executedAt = _data["executedAt"] ? new Date(_data["executedAt"].toString()) : <any>undefined;
            this.duration = _data["duration"];
            this.actionsExecuted = _data["actionsExecuted"];
            this.errorCount = _data["errorCount"];
            this.profileHash = _data["profileHash"];
            this.createdBy = _data["createdBy"];
            this.testResult = _data["testResult"] ? BrowserAutomationTestResultDto.fromJS(_data["testResult"]) : <any>undefined;
            this.profile = _data["profile"] ? BrowserAutomationProfileDto.fromJS(_data["profile"]) : <any>undefined;
            this.options = _data["options"] ? BrowserTestOptionsDto.fromJS(_data["options"]) : <any>undefined;
            if (Array.isArray(_data["screenshots"])) {
                this.screenshots = [] as any;
                for (let item of _data["screenshots"])
                    this.screenshots!.push(item);
            }
            this.videoRecording = _data["videoRecording"];
            if (_data["metadata"]) {
                this.metadata = {} as any;
                for (let key in _data["metadata"]) {
                    if (_data["metadata"].hasOwnProperty(key))
                        (<any>this.metadata)![key] = _data["metadata"][key];
                }
            }
        }
    }

    static fromJS(data: any): SavedTestResultDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new SavedTestResultDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        data["testUrl"] = this.testUrl;
        data["success"] = this.success;
        data["savedAt"] = this.savedAt ? this.savedAt.toISOString() : <any>undefined;
        data["executedAt"] = this.executedAt ? this.executedAt.toISOString() : <any>undefined;
        data["duration"] = this.duration;
        data["actionsExecuted"] = this.actionsExecuted;
        data["errorCount"] = this.errorCount;
        data["profileHash"] = this.profileHash;
        data["createdBy"] = this.createdBy;
        data["testResult"] = this.testResult ? this.testResult.toJSON() : <any>undefined;
        data["profile"] = this.profile ? this.profile.toJSON() : <any>undefined;
        data["options"] = this.options ? this.options.toJSON() : <any>undefined;
        if (Array.isArray(this.screenshots)) {
            data["screenshots"] = [];
            for (let item of this.screenshots)
                data["screenshots"].push(item);
        }
        data["videoRecording"] = this.videoRecording;
        if (this.metadata) {
            data["metadata"] = {};
            for (let key in this.metadata) {
                if (this.metadata.hasOwnProperty(key))
                    (<any>data["metadata"])[key] = (<any>this.metadata)[key];
            }
        }
        return data;
    }
}

export interface ISavedTestResultDetailDto {
    id?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    tags?: string[] | undefined;
    testUrl?: string | undefined;
    success?: boolean;
    savedAt?: Date;
    executedAt?: Date;
    duration?: number;
    actionsExecuted?: number;
    errorCount?: number;
    profileHash?: string | undefined;
    createdBy?: string | undefined;
    testResult?: BrowserAutomationTestResultDto;
    profile?: BrowserAutomationProfileDto;
    options?: BrowserTestOptionsDto;
    screenshots?: string[] | undefined;
    videoRecording?: string | undefined;
    metadata?: { [key: string]: any; } | undefined;
}

export class SavedTestResultDetailDtoApiResponse implements ISavedTestResultDetailDtoApiResponse {
    success?: boolean;
    data?: SavedTestResultDetailDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: ISavedTestResultDetailDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"] ? SavedTestResultDetailDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): SavedTestResultDetailDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SavedTestResultDetailDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface ISavedTestResultDetailDtoApiResponse {
    success?: boolean;
    data?: SavedTestResultDetailDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class SavedTestResultDto implements ISavedTestResultDto {
    id?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    tags?: string[] | undefined;
    testUrl?: string | undefined;
    success?: boolean;
    savedAt?: Date;
    executedAt?: Date;
    duration?: number;
    actionsExecuted?: number;
    errorCount?: number;
    profileHash?: string | undefined;
    createdBy?: string | undefined;

    constructor(data?: ISavedTestResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
            this.testUrl = _data["testUrl"];
            this.success = _data["success"];
            this.savedAt = _data["savedAt"] ? new Date(_data["savedAt"].toString()) : <any>undefined;
            this.executedAt = _data["executedAt"] ? new Date(_data["executedAt"].toString()) : <any>undefined;
            this.duration = _data["duration"];
            this.actionsExecuted = _data["actionsExecuted"];
            this.errorCount = _data["errorCount"];
            this.profileHash = _data["profileHash"];
            this.createdBy = _data["createdBy"];
        }
    }

    static fromJS(data: any): SavedTestResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new SavedTestResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        data["testUrl"] = this.testUrl;
        data["success"] = this.success;
        data["savedAt"] = this.savedAt ? this.savedAt.toISOString() : <any>undefined;
        data["executedAt"] = this.executedAt ? this.executedAt.toISOString() : <any>undefined;
        data["duration"] = this.duration;
        data["actionsExecuted"] = this.actionsExecuted;
        data["errorCount"] = this.errorCount;
        data["profileHash"] = this.profileHash;
        data["createdBy"] = this.createdBy;
        return data;
    }
}

export interface ISavedTestResultDto {
    id?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    tags?: string[] | undefined;
    testUrl?: string | undefined;
    success?: boolean;
    savedAt?: Date;
    executedAt?: Date;
    duration?: number;
    actionsExecuted?: number;
    errorCount?: number;
    profileHash?: string | undefined;
    createdBy?: string | undefined;
}

export class SavedTestResultDtoPagedResponse implements ISavedTestResultDtoPagedResponse {
    success?: boolean;
    data?: SavedTestResultDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
    pagination?: PaginationMeta;

    constructor(data?: ISavedTestResultDtoPagedResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(SavedTestResultDto.fromJS(item));
            }
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
            this.pagination = _data["pagination"] ? PaginationMeta.fromJS(_data["pagination"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SavedTestResultDtoPagedResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SavedTestResultDtoPagedResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : <any>undefined);
        }
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        data["pagination"] = this.pagination ? this.pagination.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISavedTestResultDtoPagedResponse {
    success?: boolean;
    data?: SavedTestResultDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
    pagination?: PaginationMeta;
}

export class ScraperRunLogDto implements IScraperRunLogDto {
    runId?: string;
    mappingId?: string;
    startedAt?: Date;
    completedAt?: Date | undefined;
    duration?: string | undefined;
    status?: string | undefined;
    statusDisplayName?: string | undefined;
    targetUrl?: string | undefined;
    userAgent?: string | undefined;
    additionalHeaders?: { [key: string]: string; } | undefined;
    selectors?: ScrapingSelectorsDto;
    httpStatusCode?: number | undefined;
    responseTime?: string | undefined;
    responseSizeBytes?: number | undefined;
    proxyUsed?: string | undefined;
    proxyId?: string | undefined;
    extractedProductName?: string | undefined;
    extractedPrice?: number | undefined;
    extractedStockStatus?: string | undefined;
    extractedSellerName?: string | undefined;
    extractedPrimaryImageUrl?: string | undefined;
    extractedAdditionalImageUrls?: string[] | undefined;
    extractedOriginalImageUrls?: string[] | undefined;
    imageProcessingCount?: number | undefined;
    imageUploadCount?: number | undefined;
    imageScrapingError?: string | undefined;
    specificationData?: string | undefined;
    specificationMetadata?: string | undefined;
    specificationCount?: number | undefined;
    specificationParsingStrategy?: string | undefined;
    specificationQualityScore?: number | undefined;
    specificationParsingTime?: number | undefined;
    specificationError?: string | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errorStackTrace?: string | undefined;
    errorCategory?: string | undefined;
    errorCategoryDisplayName?: string | undefined;
    attemptNumber?: number;
    parentRunId?: string | undefined;
    isRetry?: boolean;
    pageLoadTime?: string | undefined;
    parsingTime?: string | undefined;
    rawHtmlSnippet?: string | undefined;
    debugNotes?: string | undefined;
    mapping?: ProductSellerMappingDto;
    retryAttempts?: ScraperRunLogSummaryDto[] | undefined;
    createdAt?: Date;

    constructor(data?: IScraperRunLogDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.runId = _data["runId"];
            this.mappingId = _data["mappingId"];
            this.startedAt = _data["startedAt"] ? new Date(_data["startedAt"].toString()) : <any>undefined;
            this.completedAt = _data["completedAt"] ? new Date(_data["completedAt"].toString()) : <any>undefined;
            this.duration = _data["duration"];
            this.status = _data["status"];
            this.statusDisplayName = _data["statusDisplayName"];
            this.targetUrl = _data["targetUrl"];
            this.userAgent = _data["userAgent"];
            if (_data["additionalHeaders"]) {
                this.additionalHeaders = {} as any;
                for (let key in _data["additionalHeaders"]) {
                    if (_data["additionalHeaders"].hasOwnProperty(key))
                        (<any>this.additionalHeaders)![key] = _data["additionalHeaders"][key];
                }
            }
            this.selectors = _data["selectors"] ? ScrapingSelectorsDto.fromJS(_data["selectors"]) : <any>undefined;
            this.httpStatusCode = _data["httpStatusCode"];
            this.responseTime = _data["responseTime"];
            this.responseSizeBytes = _data["responseSizeBytes"];
            this.proxyUsed = _data["proxyUsed"];
            this.proxyId = _data["proxyId"];
            this.extractedProductName = _data["extractedProductName"];
            this.extractedPrice = _data["extractedPrice"];
            this.extractedStockStatus = _data["extractedStockStatus"];
            this.extractedSellerName = _data["extractedSellerName"];
            this.extractedPrimaryImageUrl = _data["extractedPrimaryImageUrl"];
            if (Array.isArray(_data["extractedAdditionalImageUrls"])) {
                this.extractedAdditionalImageUrls = [] as any;
                for (let item of _data["extractedAdditionalImageUrls"])
                    this.extractedAdditionalImageUrls!.push(item);
            }
            if (Array.isArray(_data["extractedOriginalImageUrls"])) {
                this.extractedOriginalImageUrls = [] as any;
                for (let item of _data["extractedOriginalImageUrls"])
                    this.extractedOriginalImageUrls!.push(item);
            }
            this.imageProcessingCount = _data["imageProcessingCount"];
            this.imageUploadCount = _data["imageUploadCount"];
            this.imageScrapingError = _data["imageScrapingError"];
            this.specificationData = _data["specificationData"];
            this.specificationMetadata = _data["specificationMetadata"];
            this.specificationCount = _data["specificationCount"];
            this.specificationParsingStrategy = _data["specificationParsingStrategy"];
            this.specificationQualityScore = _data["specificationQualityScore"];
            this.specificationParsingTime = _data["specificationParsingTime"];
            this.specificationError = _data["specificationError"];
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            this.errorStackTrace = _data["errorStackTrace"];
            this.errorCategory = _data["errorCategory"];
            this.errorCategoryDisplayName = _data["errorCategoryDisplayName"];
            this.attemptNumber = _data["attemptNumber"];
            this.parentRunId = _data["parentRunId"];
            this.isRetry = _data["isRetry"];
            this.pageLoadTime = _data["pageLoadTime"];
            this.parsingTime = _data["parsingTime"];
            this.rawHtmlSnippet = _data["rawHtmlSnippet"];
            this.debugNotes = _data["debugNotes"];
            this.mapping = _data["mapping"] ? ProductSellerMappingDto.fromJS(_data["mapping"]) : <any>undefined;
            if (Array.isArray(_data["retryAttempts"])) {
                this.retryAttempts = [] as any;
                for (let item of _data["retryAttempts"])
                    this.retryAttempts!.push(ScraperRunLogSummaryDto.fromJS(item));
            }
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ScraperRunLogDto {
        data = typeof data === 'object' ? data : {};
        let result = new ScraperRunLogDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["runId"] = this.runId;
        data["mappingId"] = this.mappingId;
        data["startedAt"] = this.startedAt ? this.startedAt.toISOString() : <any>undefined;
        data["completedAt"] = this.completedAt ? this.completedAt.toISOString() : <any>undefined;
        data["duration"] = this.duration;
        data["status"] = this.status;
        data["statusDisplayName"] = this.statusDisplayName;
        data["targetUrl"] = this.targetUrl;
        data["userAgent"] = this.userAgent;
        if (this.additionalHeaders) {
            data["additionalHeaders"] = {};
            for (let key in this.additionalHeaders) {
                if (this.additionalHeaders.hasOwnProperty(key))
                    (<any>data["additionalHeaders"])[key] = (<any>this.additionalHeaders)[key];
            }
        }
        data["selectors"] = this.selectors ? this.selectors.toJSON() : <any>undefined;
        data["httpStatusCode"] = this.httpStatusCode;
        data["responseTime"] = this.responseTime;
        data["responseSizeBytes"] = this.responseSizeBytes;
        data["proxyUsed"] = this.proxyUsed;
        data["proxyId"] = this.proxyId;
        data["extractedProductName"] = this.extractedProductName;
        data["extractedPrice"] = this.extractedPrice;
        data["extractedStockStatus"] = this.extractedStockStatus;
        data["extractedSellerName"] = this.extractedSellerName;
        data["extractedPrimaryImageUrl"] = this.extractedPrimaryImageUrl;
        if (Array.isArray(this.extractedAdditionalImageUrls)) {
            data["extractedAdditionalImageUrls"] = [];
            for (let item of this.extractedAdditionalImageUrls)
                data["extractedAdditionalImageUrls"].push(item);
        }
        if (Array.isArray(this.extractedOriginalImageUrls)) {
            data["extractedOriginalImageUrls"] = [];
            for (let item of this.extractedOriginalImageUrls)
                data["extractedOriginalImageUrls"].push(item);
        }
        data["imageProcessingCount"] = this.imageProcessingCount;
        data["imageUploadCount"] = this.imageUploadCount;
        data["imageScrapingError"] = this.imageScrapingError;
        data["specificationData"] = this.specificationData;
        data["specificationMetadata"] = this.specificationMetadata;
        data["specificationCount"] = this.specificationCount;
        data["specificationParsingStrategy"] = this.specificationParsingStrategy;
        data["specificationQualityScore"] = this.specificationQualityScore;
        data["specificationParsingTime"] = this.specificationParsingTime;
        data["specificationError"] = this.specificationError;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        data["errorStackTrace"] = this.errorStackTrace;
        data["errorCategory"] = this.errorCategory;
        data["errorCategoryDisplayName"] = this.errorCategoryDisplayName;
        data["attemptNumber"] = this.attemptNumber;
        data["parentRunId"] = this.parentRunId;
        data["isRetry"] = this.isRetry;
        data["pageLoadTime"] = this.pageLoadTime;
        data["parsingTime"] = this.parsingTime;
        data["rawHtmlSnippet"] = this.rawHtmlSnippet;
        data["debugNotes"] = this.debugNotes;
        data["mapping"] = this.mapping ? this.mapping.toJSON() : <any>undefined;
        if (Array.isArray(this.retryAttempts)) {
            data["retryAttempts"] = [];
            for (let item of this.retryAttempts)
                data["retryAttempts"].push(item ? item.toJSON() : <any>undefined);
        }
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        return data;
    }
}

export interface IScraperRunLogDto {
    runId?: string;
    mappingId?: string;
    startedAt?: Date;
    completedAt?: Date | undefined;
    duration?: string | undefined;
    status?: string | undefined;
    statusDisplayName?: string | undefined;
    targetUrl?: string | undefined;
    userAgent?: string | undefined;
    additionalHeaders?: { [key: string]: string; } | undefined;
    selectors?: ScrapingSelectorsDto;
    httpStatusCode?: number | undefined;
    responseTime?: string | undefined;
    responseSizeBytes?: number | undefined;
    proxyUsed?: string | undefined;
    proxyId?: string | undefined;
    extractedProductName?: string | undefined;
    extractedPrice?: number | undefined;
    extractedStockStatus?: string | undefined;
    extractedSellerName?: string | undefined;
    extractedPrimaryImageUrl?: string | undefined;
    extractedAdditionalImageUrls?: string[] | undefined;
    extractedOriginalImageUrls?: string[] | undefined;
    imageProcessingCount?: number | undefined;
    imageUploadCount?: number | undefined;
    imageScrapingError?: string | undefined;
    specificationData?: string | undefined;
    specificationMetadata?: string | undefined;
    specificationCount?: number | undefined;
    specificationParsingStrategy?: string | undefined;
    specificationQualityScore?: number | undefined;
    specificationParsingTime?: number | undefined;
    specificationError?: string | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errorStackTrace?: string | undefined;
    errorCategory?: string | undefined;
    errorCategoryDisplayName?: string | undefined;
    attemptNumber?: number;
    parentRunId?: string | undefined;
    isRetry?: boolean;
    pageLoadTime?: string | undefined;
    parsingTime?: string | undefined;
    rawHtmlSnippet?: string | undefined;
    debugNotes?: string | undefined;
    mapping?: ProductSellerMappingDto;
    retryAttempts?: ScraperRunLogSummaryDto[] | undefined;
    createdAt?: Date;
}

export class ScraperRunLogDtoApiResponse implements IScraperRunLogDtoApiResponse {
    success?: boolean;
    data?: ScraperRunLogDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IScraperRunLogDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"] ? ScraperRunLogDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): ScraperRunLogDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ScraperRunLogDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IScraperRunLogDtoApiResponse {
    success?: boolean;
    data?: ScraperRunLogDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class ScraperRunLogDtoIEnumerableApiResponse implements IScraperRunLogDtoIEnumerableApiResponse {
    success?: boolean;
    data?: ScraperRunLogDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IScraperRunLogDtoIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(ScraperRunLogDto.fromJS(item));
            }
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): ScraperRunLogDtoIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ScraperRunLogDtoIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : <any>undefined);
        }
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IScraperRunLogDtoIEnumerableApiResponse {
    success?: boolean;
    data?: ScraperRunLogDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class ScraperRunLogSummaryDto implements IScraperRunLogSummaryDto {
    runId?: string;
    mappingId?: string;
    startedAt?: Date;
    completedAt?: Date | undefined;
    duration?: string | undefined;
    status?: string | undefined;
    statusDisplayName?: string | undefined;
    targetUrl?: string | undefined;
    extractedPrice?: number | undefined;
    errorMessage?: string | undefined;
    errorCategory?: string | undefined;
    errorCategoryDisplayName?: string | undefined;
    attemptNumber?: number;
    isRetry?: boolean;
    responseTime?: string | undefined;
    sellerName?: string | undefined;
    productName?: string | undefined;

    constructor(data?: IScraperRunLogSummaryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.runId = _data["runId"];
            this.mappingId = _data["mappingId"];
            this.startedAt = _data["startedAt"] ? new Date(_data["startedAt"].toString()) : <any>undefined;
            this.completedAt = _data["completedAt"] ? new Date(_data["completedAt"].toString()) : <any>undefined;
            this.duration = _data["duration"];
            this.status = _data["status"];
            this.statusDisplayName = _data["statusDisplayName"];
            this.targetUrl = _data["targetUrl"];
            this.extractedPrice = _data["extractedPrice"];
            this.errorMessage = _data["errorMessage"];
            this.errorCategory = _data["errorCategory"];
            this.errorCategoryDisplayName = _data["errorCategoryDisplayName"];
            this.attemptNumber = _data["attemptNumber"];
            this.isRetry = _data["isRetry"];
            this.responseTime = _data["responseTime"];
            this.sellerName = _data["sellerName"];
            this.productName = _data["productName"];
        }
    }

    static fromJS(data: any): ScraperRunLogSummaryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ScraperRunLogSummaryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["runId"] = this.runId;
        data["mappingId"] = this.mappingId;
        data["startedAt"] = this.startedAt ? this.startedAt.toISOString() : <any>undefined;
        data["completedAt"] = this.completedAt ? this.completedAt.toISOString() : <any>undefined;
        data["duration"] = this.duration;
        data["status"] = this.status;
        data["statusDisplayName"] = this.statusDisplayName;
        data["targetUrl"] = this.targetUrl;
        data["extractedPrice"] = this.extractedPrice;
        data["errorMessage"] = this.errorMessage;
        data["errorCategory"] = this.errorCategory;
        data["errorCategoryDisplayName"] = this.errorCategoryDisplayName;
        data["attemptNumber"] = this.attemptNumber;
        data["isRetry"] = this.isRetry;
        data["responseTime"] = this.responseTime;
        data["sellerName"] = this.sellerName;
        data["productName"] = this.productName;
        return data;
    }
}

export interface IScraperRunLogSummaryDto {
    runId?: string;
    mappingId?: string;
    startedAt?: Date;
    completedAt?: Date | undefined;
    duration?: string | undefined;
    status?: string | undefined;
    statusDisplayName?: string | undefined;
    targetUrl?: string | undefined;
    extractedPrice?: number | undefined;
    errorMessage?: string | undefined;
    errorCategory?: string | undefined;
    errorCategoryDisplayName?: string | undefined;
    attemptNumber?: number;
    isRetry?: boolean;
    responseTime?: string | undefined;
    sellerName?: string | undefined;
    productName?: string | undefined;
}

export class ScraperRunLogSummaryDtoIEnumerableApiResponse implements IScraperRunLogSummaryDtoIEnumerableApiResponse {
    success?: boolean;
    data?: ScraperRunLogSummaryDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IScraperRunLogSummaryDtoIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(ScraperRunLogSummaryDto.fromJS(item));
            }
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): ScraperRunLogSummaryDtoIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ScraperRunLogSummaryDtoIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : <any>undefined);
        }
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IScraperRunLogSummaryDtoIEnumerableApiResponse {
    success?: boolean;
    data?: ScraperRunLogSummaryDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class ScraperRunLogSummaryDtoPagedResultDto implements IScraperRunLogSummaryDtoPagedResultDto {
    items?: ScraperRunLogSummaryDto[] | undefined;
    totalCount?: number;
    page?: number;
    pageSize?: number;
    readonly totalPages?: number;
    readonly hasNextPage?: boolean;
    readonly hasPreviousPage?: boolean;

    constructor(data?: IScraperRunLogSummaryDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ScraperRunLogSummaryDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            this.page = _data["page"];
            this.pageSize = _data["pageSize"];
            (<any>this).totalPages = _data["totalPages"];
            (<any>this).hasNextPage = _data["hasNextPage"];
            (<any>this).hasPreviousPage = _data["hasPreviousPage"];
        }
    }

    static fromJS(data: any): ScraperRunLogSummaryDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ScraperRunLogSummaryDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : <any>undefined);
        }
        data["totalCount"] = this.totalCount;
        data["page"] = this.page;
        data["pageSize"] = this.pageSize;
        data["totalPages"] = this.totalPages;
        data["hasNextPage"] = this.hasNextPage;
        data["hasPreviousPage"] = this.hasPreviousPage;
        return data;
    }
}

export interface IScraperRunLogSummaryDtoPagedResultDto {
    items?: ScraperRunLogSummaryDto[] | undefined;
    totalCount?: number;
    page?: number;
    pageSize?: number;
    totalPages?: number;
    hasNextPage?: boolean;
    hasPreviousPage?: boolean;
}

export class ScraperRunLogSummaryDtoPagedResultDtoApiResponse implements IScraperRunLogSummaryDtoPagedResultDtoApiResponse {
    success?: boolean;
    data?: ScraperRunLogSummaryDtoPagedResultDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IScraperRunLogSummaryDtoPagedResultDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"] ? ScraperRunLogSummaryDtoPagedResultDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): ScraperRunLogSummaryDtoPagedResultDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ScraperRunLogSummaryDtoPagedResultDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IScraperRunLogSummaryDtoPagedResultDtoApiResponse {
    success?: boolean;
    data?: ScraperRunLogSummaryDtoPagedResultDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class ScraperRunStatisticsDto implements IScraperRunStatisticsDto {
    totalRuns?: number;
    successfulRuns?: number;
    failedRuns?: number;
    inProgressRuns?: number;
    successRate?: number;
    averageResponseTime?: string | undefined;
    averageDuration?: string | undefined;
    errorCategoryCounts?: { [key: string]: number; } | undefined;
    statusCounts?: { [key: string]: number; } | undefined;
    dateFrom?: Date | undefined;
    dateTo?: Date | undefined;

    constructor(data?: IScraperRunStatisticsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalRuns = _data["totalRuns"];
            this.successfulRuns = _data["successfulRuns"];
            this.failedRuns = _data["failedRuns"];
            this.inProgressRuns = _data["inProgressRuns"];
            this.successRate = _data["successRate"];
            this.averageResponseTime = _data["averageResponseTime"];
            this.averageDuration = _data["averageDuration"];
            if (_data["errorCategoryCounts"]) {
                this.errorCategoryCounts = {} as any;
                for (let key in _data["errorCategoryCounts"]) {
                    if (_data["errorCategoryCounts"].hasOwnProperty(key))
                        (<any>this.errorCategoryCounts)![key] = _data["errorCategoryCounts"][key];
                }
            }
            if (_data["statusCounts"]) {
                this.statusCounts = {} as any;
                for (let key in _data["statusCounts"]) {
                    if (_data["statusCounts"].hasOwnProperty(key))
                        (<any>this.statusCounts)![key] = _data["statusCounts"][key];
                }
            }
            this.dateFrom = _data["dateFrom"] ? new Date(_data["dateFrom"].toString()) : <any>undefined;
            this.dateTo = _data["dateTo"] ? new Date(_data["dateTo"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ScraperRunStatisticsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ScraperRunStatisticsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalRuns"] = this.totalRuns;
        data["successfulRuns"] = this.successfulRuns;
        data["failedRuns"] = this.failedRuns;
        data["inProgressRuns"] = this.inProgressRuns;
        data["successRate"] = this.successRate;
        data["averageResponseTime"] = this.averageResponseTime;
        data["averageDuration"] = this.averageDuration;
        if (this.errorCategoryCounts) {
            data["errorCategoryCounts"] = {};
            for (let key in this.errorCategoryCounts) {
                if (this.errorCategoryCounts.hasOwnProperty(key))
                    (<any>data["errorCategoryCounts"])[key] = (<any>this.errorCategoryCounts)[key];
            }
        }
        if (this.statusCounts) {
            data["statusCounts"] = {};
            for (let key in this.statusCounts) {
                if (this.statusCounts.hasOwnProperty(key))
                    (<any>data["statusCounts"])[key] = (<any>this.statusCounts)[key];
            }
        }
        data["dateFrom"] = this.dateFrom ? this.dateFrom.toISOString() : <any>undefined;
        data["dateTo"] = this.dateTo ? this.dateTo.toISOString() : <any>undefined;
        return data;
    }
}

export interface IScraperRunStatisticsDto {
    totalRuns?: number;
    successfulRuns?: number;
    failedRuns?: number;
    inProgressRuns?: number;
    successRate?: number;
    averageResponseTime?: string | undefined;
    averageDuration?: string | undefined;
    errorCategoryCounts?: { [key: string]: number; } | undefined;
    statusCounts?: { [key: string]: number; } | undefined;
    dateFrom?: Date | undefined;
    dateTo?: Date | undefined;
}

export class ScraperRunStatisticsDtoApiResponse implements IScraperRunStatisticsDtoApiResponse {
    success?: boolean;
    data?: ScraperRunStatisticsDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IScraperRunStatisticsDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"] ? ScraperRunStatisticsDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): ScraperRunStatisticsDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ScraperRunStatisticsDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IScraperRunStatisticsDtoApiResponse {
    success?: boolean;
    data?: ScraperRunStatisticsDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class ScraperSiteConfigurationDto implements IScraperSiteConfigurationDto {
    siteConfigId?: string;
    siteDomain?: string | undefined;
    productNameSelector?: string | undefined;
    priceSelector?: string | undefined;
    stockSelector?: string | undefined;
    sellerNameOnPageSelector?: string | undefined;
    imageSelector?: string | undefined;
    defaultUserAgent?: string | undefined;
    additionalHeaders?: { [key: string]: string; } | undefined;
    isEnabled?: boolean;
    createdAt?: Date;
    updatedAt?: Date;
    requiresBrowserAutomation?: boolean;
    browserAutomationProfile?: string | undefined;
    specificationTableSelector?: string | undefined;
    specificationContainerSelector?: string | undefined;
    enableSpecificationScraping?: boolean;
    specificationOptions?: SpecificationParsingOptions;

    constructor(data?: IScraperSiteConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.siteConfigId = _data["siteConfigId"];
            this.siteDomain = _data["siteDomain"];
            this.productNameSelector = _data["productNameSelector"];
            this.priceSelector = _data["priceSelector"];
            this.stockSelector = _data["stockSelector"];
            this.sellerNameOnPageSelector = _data["sellerNameOnPageSelector"];
            this.imageSelector = _data["imageSelector"];
            this.defaultUserAgent = _data["defaultUserAgent"];
            if (_data["additionalHeaders"]) {
                this.additionalHeaders = {} as any;
                for (let key in _data["additionalHeaders"]) {
                    if (_data["additionalHeaders"].hasOwnProperty(key))
                        (<any>this.additionalHeaders)![key] = _data["additionalHeaders"][key];
                }
            }
            this.isEnabled = _data["isEnabled"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.requiresBrowserAutomation = _data["requiresBrowserAutomation"];
            this.browserAutomationProfile = _data["browserAutomationProfile"];
            this.specificationTableSelector = _data["specificationTableSelector"];
            this.specificationContainerSelector = _data["specificationContainerSelector"];
            this.enableSpecificationScraping = _data["enableSpecificationScraping"];
            this.specificationOptions = _data["specificationOptions"] ? SpecificationParsingOptions.fromJS(_data["specificationOptions"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ScraperSiteConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ScraperSiteConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["siteConfigId"] = this.siteConfigId;
        data["siteDomain"] = this.siteDomain;
        data["productNameSelector"] = this.productNameSelector;
        data["priceSelector"] = this.priceSelector;
        data["stockSelector"] = this.stockSelector;
        data["sellerNameOnPageSelector"] = this.sellerNameOnPageSelector;
        data["imageSelector"] = this.imageSelector;
        data["defaultUserAgent"] = this.defaultUserAgent;
        if (this.additionalHeaders) {
            data["additionalHeaders"] = {};
            for (let key in this.additionalHeaders) {
                if (this.additionalHeaders.hasOwnProperty(key))
                    (<any>data["additionalHeaders"])[key] = (<any>this.additionalHeaders)[key];
            }
        }
        data["isEnabled"] = this.isEnabled;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["requiresBrowserAutomation"] = this.requiresBrowserAutomation;
        data["browserAutomationProfile"] = this.browserAutomationProfile;
        data["specificationTableSelector"] = this.specificationTableSelector;
        data["specificationContainerSelector"] = this.specificationContainerSelector;
        data["enableSpecificationScraping"] = this.enableSpecificationScraping;
        data["specificationOptions"] = this.specificationOptions ? this.specificationOptions.toJSON() : <any>undefined;
        return data;
    }
}

export interface IScraperSiteConfigurationDto {
    siteConfigId?: string;
    siteDomain?: string | undefined;
    productNameSelector?: string | undefined;
    priceSelector?: string | undefined;
    stockSelector?: string | undefined;
    sellerNameOnPageSelector?: string | undefined;
    imageSelector?: string | undefined;
    defaultUserAgent?: string | undefined;
    additionalHeaders?: { [key: string]: string; } | undefined;
    isEnabled?: boolean;
    createdAt?: Date;
    updatedAt?: Date;
    requiresBrowserAutomation?: boolean;
    browserAutomationProfile?: string | undefined;
    specificationTableSelector?: string | undefined;
    specificationContainerSelector?: string | undefined;
    enableSpecificationScraping?: boolean;
    specificationOptions?: SpecificationParsingOptions;
}

export class ScraperSiteConfigurationDtoApiResponse implements IScraperSiteConfigurationDtoApiResponse {
    success?: boolean;
    data?: ScraperSiteConfigurationDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IScraperSiteConfigurationDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"] ? ScraperSiteConfigurationDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): ScraperSiteConfigurationDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ScraperSiteConfigurationDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IScraperSiteConfigurationDtoApiResponse {
    success?: boolean;
    data?: ScraperSiteConfigurationDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class ScraperSiteConfigurationDtoIEnumerableApiResponse implements IScraperSiteConfigurationDtoIEnumerableApiResponse {
    success?: boolean;
    data?: ScraperSiteConfigurationDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IScraperSiteConfigurationDtoIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(ScraperSiteConfigurationDto.fromJS(item));
            }
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): ScraperSiteConfigurationDtoIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ScraperSiteConfigurationDtoIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : <any>undefined);
        }
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IScraperSiteConfigurationDtoIEnumerableApiResponse {
    success?: boolean;
    data?: ScraperSiteConfigurationDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class ScrapingSelectorsDto implements IScrapingSelectorsDto {
    productNameSelector?: string | undefined;
    priceSelector?: string | undefined;
    stockSelector?: string | undefined;
    sellerNameOnPageSelector?: string | undefined;
    imageSelector?: string | undefined;
    specificationTableSelector?: string | undefined;
    specificationContainerSelector?: string | undefined;
    specificationOptions?: SpecificationParsingOptions;

    constructor(data?: IScrapingSelectorsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productNameSelector = _data["productNameSelector"];
            this.priceSelector = _data["priceSelector"];
            this.stockSelector = _data["stockSelector"];
            this.sellerNameOnPageSelector = _data["sellerNameOnPageSelector"];
            this.imageSelector = _data["imageSelector"];
            this.specificationTableSelector = _data["specificationTableSelector"];
            this.specificationContainerSelector = _data["specificationContainerSelector"];
            this.specificationOptions = _data["specificationOptions"] ? SpecificationParsingOptions.fromJS(_data["specificationOptions"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ScrapingSelectorsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ScrapingSelectorsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productNameSelector"] = this.productNameSelector;
        data["priceSelector"] = this.priceSelector;
        data["stockSelector"] = this.stockSelector;
        data["sellerNameOnPageSelector"] = this.sellerNameOnPageSelector;
        data["imageSelector"] = this.imageSelector;
        data["specificationTableSelector"] = this.specificationTableSelector;
        data["specificationContainerSelector"] = this.specificationContainerSelector;
        data["specificationOptions"] = this.specificationOptions ? this.specificationOptions.toJSON() : <any>undefined;
        return data;
    }
}

export interface IScrapingSelectorsDto {
    productNameSelector?: string | undefined;
    priceSelector?: string | undefined;
    stockSelector?: string | undefined;
    sellerNameOnPageSelector?: string | undefined;
    imageSelector?: string | undefined;
    specificationTableSelector?: string | undefined;
    specificationContainerSelector?: string | undefined;
    specificationOptions?: SpecificationParsingOptions;
}

export class ScreenshotCaptureDto implements IScreenshotCaptureDto {
    id?: string | undefined;
    timestamp?: Date;
    base64Data?: string | undefined;
    actionIndex?: number;
    actionType?: string | undefined;

    constructor(data?: IScreenshotCaptureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.base64Data = _data["base64Data"];
            this.actionIndex = _data["actionIndex"];
            this.actionType = _data["actionType"];
        }
    }

    static fromJS(data: any): ScreenshotCaptureDto {
        data = typeof data === 'object' ? data : {};
        let result = new ScreenshotCaptureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["base64Data"] = this.base64Data;
        data["actionIndex"] = this.actionIndex;
        data["actionType"] = this.actionType;
        return data;
    }
}

export interface IScreenshotCaptureDto {
    id?: string | undefined;
    timestamp?: Date;
    base64Data?: string | undefined;
    actionIndex?: number;
    actionType?: string | undefined;
}

export class SellerPerformanceMetricDto implements ISellerPerformanceMetricDto {
    sellerName?: string | undefined;
    totalRuns?: number;
    successfulRuns?: number;
    successRate?: number;
    averageResponseTime?: string | undefined;
    averageDuration?: string | undefined;

    constructor(data?: ISellerPerformanceMetricDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sellerName = _data["sellerName"];
            this.totalRuns = _data["totalRuns"];
            this.successfulRuns = _data["successfulRuns"];
            this.successRate = _data["successRate"];
            this.averageResponseTime = _data["averageResponseTime"];
            this.averageDuration = _data["averageDuration"];
        }
    }

    static fromJS(data: any): SellerPerformanceMetricDto {
        data = typeof data === 'object' ? data : {};
        let result = new SellerPerformanceMetricDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sellerName"] = this.sellerName;
        data["totalRuns"] = this.totalRuns;
        data["successfulRuns"] = this.successfulRuns;
        data["successRate"] = this.successRate;
        data["averageResponseTime"] = this.averageResponseTime;
        data["averageDuration"] = this.averageDuration;
        return data;
    }
}

export interface ISellerPerformanceMetricDto {
    sellerName?: string | undefined;
    totalRuns?: number;
    successfulRuns?: number;
    successRate?: number;
    averageResponseTime?: string | undefined;
    averageDuration?: string | undefined;
}

export class SellerPerformanceMetricDtoIEnumerableApiResponse implements ISellerPerformanceMetricDtoIEnumerableApiResponse {
    success?: boolean;
    data?: SellerPerformanceMetricDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: ISellerPerformanceMetricDtoIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(SellerPerformanceMetricDto.fromJS(item));
            }
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): SellerPerformanceMetricDtoIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SellerPerformanceMetricDtoIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : <any>undefined);
        }
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface ISellerPerformanceMetricDtoIEnumerableApiResponse {
    success?: boolean;
    data?: SellerPerformanceMetricDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class SellerPriceComparisonDto implements ISellerPriceComparisonDto {
    sellerName?: string | undefined;
    product1Price?: number | undefined;
    product2Price?: number | undefined;
    product1StockStatus?: string | undefined;
    product2StockStatus?: string | undefined;
    priceDifference?: number | undefined;
    availabilityAdvantage?: string | undefined;

    constructor(data?: ISellerPriceComparisonDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sellerName = _data["sellerName"];
            this.product1Price = _data["product1Price"];
            this.product2Price = _data["product2Price"];
            this.product1StockStatus = _data["product1StockStatus"];
            this.product2StockStatus = _data["product2StockStatus"];
            this.priceDifference = _data["priceDifference"];
            this.availabilityAdvantage = _data["availabilityAdvantage"];
        }
    }

    static fromJS(data: any): SellerPriceComparisonDto {
        data = typeof data === 'object' ? data : {};
        let result = new SellerPriceComparisonDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sellerName"] = this.sellerName;
        data["product1Price"] = this.product1Price;
        data["product2Price"] = this.product2Price;
        data["product1StockStatus"] = this.product1StockStatus;
        data["product2StockStatus"] = this.product2StockStatus;
        data["priceDifference"] = this.priceDifference;
        data["availabilityAdvantage"] = this.availabilityAdvantage;
        return data;
    }
}

export interface ISellerPriceComparisonDto {
    sellerName?: string | undefined;
    product1Price?: number | undefined;
    product2Price?: number | undefined;
    product1StockStatus?: string | undefined;
    product2StockStatus?: string | undefined;
    priceDifference?: number | undefined;
    availabilityAdvantage?: string | undefined;
}

export class SpecificationComparisonDto implements ISpecificationComparisonDto {
    differences?: SpecificationDifferenceDto[] | undefined;
    matches?: SpecificationMatchDto[] | undefined;
    categoryScores?: { [key: string]: CategoryScoreDto; } | undefined;

    constructor(data?: ISpecificationComparisonDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["differences"])) {
                this.differences = [] as any;
                for (let item of _data["differences"])
                    this.differences!.push(SpecificationDifferenceDto.fromJS(item));
            }
            if (Array.isArray(_data["matches"])) {
                this.matches = [] as any;
                for (let item of _data["matches"])
                    this.matches!.push(SpecificationMatchDto.fromJS(item));
            }
            if (_data["categoryScores"]) {
                this.categoryScores = {} as any;
                for (let key in _data["categoryScores"]) {
                    if (_data["categoryScores"].hasOwnProperty(key))
                        (<any>this.categoryScores)![key] = _data["categoryScores"][key] ? CategoryScoreDto.fromJS(_data["categoryScores"][key]) : new CategoryScoreDto();
                }
            }
        }
    }

    static fromJS(data: any): SpecificationComparisonDto {
        data = typeof data === 'object' ? data : {};
        let result = new SpecificationComparisonDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.differences)) {
            data["differences"] = [];
            for (let item of this.differences)
                data["differences"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.matches)) {
            data["matches"] = [];
            for (let item of this.matches)
                data["matches"].push(item ? item.toJSON() : <any>undefined);
        }
        if (this.categoryScores) {
            data["categoryScores"] = {};
            for (let key in this.categoryScores) {
                if (this.categoryScores.hasOwnProperty(key))
                    (<any>data["categoryScores"])[key] = this.categoryScores[key] ? this.categoryScores[key].toJSON() : <any>undefined;
            }
        }
        return data;
    }
}

export interface ISpecificationComparisonDto {
    differences?: SpecificationDifferenceDto[] | undefined;
    matches?: SpecificationMatchDto[] | undefined;
    categoryScores?: { [key: string]: CategoryScoreDto; } | undefined;
}

export class SpecificationDifferenceDto implements ISpecificationDifferenceDto {
    specificationKey?: string | undefined;
    displayName?: string | undefined;
    category?: string | undefined;
    product1Value?: any | undefined;
    product2Value?: any | undefined;
    product1DisplayValue?: string | undefined;
    product2DisplayValue?: string | undefined;
    comparisonResult?: ComparisonResultType;
    impactScore?: number | undefined;
    analysisNote?: string | undefined;

    constructor(data?: ISpecificationDifferenceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.specificationKey = _data["specificationKey"];
            this.displayName = _data["displayName"];
            this.category = _data["category"];
            this.product1Value = _data["product1Value"];
            this.product2Value = _data["product2Value"];
            this.product1DisplayValue = _data["product1DisplayValue"];
            this.product2DisplayValue = _data["product2DisplayValue"];
            this.comparisonResult = _data["comparisonResult"];
            this.impactScore = _data["impactScore"];
            this.analysisNote = _data["analysisNote"];
        }
    }

    static fromJS(data: any): SpecificationDifferenceDto {
        data = typeof data === 'object' ? data : {};
        let result = new SpecificationDifferenceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["specificationKey"] = this.specificationKey;
        data["displayName"] = this.displayName;
        data["category"] = this.category;
        data["product1Value"] = this.product1Value;
        data["product2Value"] = this.product2Value;
        data["product1DisplayValue"] = this.product1DisplayValue;
        data["product2DisplayValue"] = this.product2DisplayValue;
        data["comparisonResult"] = this.comparisonResult;
        data["impactScore"] = this.impactScore;
        data["analysisNote"] = this.analysisNote;
        return data;
    }
}

export interface ISpecificationDifferenceDto {
    specificationKey?: string | undefined;
    displayName?: string | undefined;
    category?: string | undefined;
    product1Value?: any | undefined;
    product2Value?: any | undefined;
    product1DisplayValue?: string | undefined;
    product2DisplayValue?: string | undefined;
    comparisonResult?: ComparisonResultType;
    impactScore?: number | undefined;
    analysisNote?: string | undefined;
}

export class SpecificationMatchDto implements ISpecificationMatchDto {
    specificationKey?: string | undefined;
    displayName?: string | undefined;
    category?: string | undefined;
    value?: any | undefined;
    displayValue?: string | undefined;

    constructor(data?: ISpecificationMatchDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.specificationKey = _data["specificationKey"];
            this.displayName = _data["displayName"];
            this.category = _data["category"];
            this.value = _data["value"];
            this.displayValue = _data["displayValue"];
        }
    }

    static fromJS(data: any): SpecificationMatchDto {
        data = typeof data === 'object' ? data : {};
        let result = new SpecificationMatchDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["specificationKey"] = this.specificationKey;
        data["displayName"] = this.displayName;
        data["category"] = this.category;
        data["value"] = this.value;
        data["displayValue"] = this.displayValue;
        return data;
    }
}

export interface ISpecificationMatchDto {
    specificationKey?: string | undefined;
    displayName?: string | undefined;
    category?: string | undefined;
    value?: any | undefined;
    displayValue?: string | undefined;
}

export class SpecificationParsingOptions implements ISpecificationParsingOptions {
    enableCaching?: boolean;
    throwOnError?: boolean;
    maxCacheEntries?: number;
    cacheExpiry?: string;
    preferredVendor?: string | undefined;

    constructor(data?: ISpecificationParsingOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.enableCaching = _data["enableCaching"];
            this.throwOnError = _data["throwOnError"];
            this.maxCacheEntries = _data["maxCacheEntries"];
            this.cacheExpiry = _data["cacheExpiry"];
            this.preferredVendor = _data["preferredVendor"];
        }
    }

    static fromJS(data: any): SpecificationParsingOptions {
        data = typeof data === 'object' ? data : {};
        let result = new SpecificationParsingOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["enableCaching"] = this.enableCaching;
        data["throwOnError"] = this.throwOnError;
        data["maxCacheEntries"] = this.maxCacheEntries;
        data["cacheExpiry"] = this.cacheExpiry;
        data["preferredVendor"] = this.preferredVendor;
        return data;
    }
}

export interface ISpecificationParsingOptions {
    enableCaching?: boolean;
    throwOnError?: boolean;
    maxCacheEntries?: number;
    cacheExpiry?: string;
    preferredVendor?: string | undefined;
}

export enum SpecificationType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
    _9 = 9,
    _10 = 10,
    _11 = 11,
    _12 = 12,
    _13 = 13,
    _14 = 14,
    _15 = 15,
    _16 = 16,
    _17 = 17,
    _18 = 18,
    _19 = 19,
    _20 = 20,
    _21 = 21,
    _22 = 22,
}

export class StringApiResponse implements IStringApiResponse {
    success?: boolean;
    data?: string | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IStringApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"];
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): StringApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new StringApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IStringApiResponse {
    success?: boolean;
    data?: string | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class StringListApiResponse implements IStringListApiResponse {
    success?: boolean;
    data?: string[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IStringListApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(item);
            }
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): StringListApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new StringListApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item);
        }
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IStringListApiResponse {
    success?: boolean;
    data?: string[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class StringNotificationChannelStatsDtoDictionaryApiResponse implements IStringNotificationChannelStatsDtoDictionaryApiResponse {
    success?: boolean;
    data?: { [key: string]: NotificationChannelStatsDto; } | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IStringNotificationChannelStatsDtoDictionaryApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (_data["data"]) {
                this.data = {} as any;
                for (let key in _data["data"]) {
                    if (_data["data"].hasOwnProperty(key))
                        (<any>this.data)![key] = _data["data"][key] ? NotificationChannelStatsDto.fromJS(_data["data"][key]) : new NotificationChannelStatsDto();
                }
            }
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): StringNotificationChannelStatsDtoDictionaryApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new StringNotificationChannelStatsDtoDictionaryApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (this.data) {
            data["data"] = {};
            for (let key in this.data) {
                if (this.data.hasOwnProperty(key))
                    (<any>data["data"])[key] = this.data[key] ? this.data[key].toJSON() : <any>undefined;
            }
        }
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IStringNotificationChannelStatsDtoDictionaryApiResponse {
    success?: boolean;
    data?: { [key: string]: NotificationChannelStatsDto; } | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class StringStringArrayDictionaryApiResponse implements IStringStringArrayDictionaryApiResponse {
    success?: boolean;
    data?: { [key: string]: string[]; } | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IStringStringArrayDictionaryApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (_data["data"]) {
                this.data = {} as any;
                for (let key in _data["data"]) {
                    if (_data["data"].hasOwnProperty(key))
                        (<any>this.data)![key] = _data["data"][key];
                }
            }
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): StringStringArrayDictionaryApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new StringStringArrayDictionaryApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (this.data) {
            data["data"] = {};
            for (let key in this.data) {
                if (this.data.hasOwnProperty(key))
                    (<any>data["data"])[key] = (<any>this.data)[key];
            }
        }
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IStringStringArrayDictionaryApiResponse {
    success?: boolean;
    data?: { [key: string]: string[]; } | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class SystemEventRequestDto implements ISystemEventRequestDto {
    eventType?: string | undefined;
    message?: string | undefined;
    component?: string | undefined;
    metadata?: { [key: string]: any; } | undefined;

    constructor(data?: ISystemEventRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.eventType = _data["eventType"];
            this.message = _data["message"];
            this.component = _data["component"];
            if (_data["metadata"]) {
                this.metadata = {} as any;
                for (let key in _data["metadata"]) {
                    if (_data["metadata"].hasOwnProperty(key))
                        (<any>this.metadata)![key] = _data["metadata"][key];
                }
            }
        }
    }

    static fromJS(data: any): SystemEventRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new SystemEventRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["eventType"] = this.eventType;
        data["message"] = this.message;
        data["component"] = this.component;
        if (this.metadata) {
            data["metadata"] = {};
            for (let key in this.metadata) {
                if (this.metadata.hasOwnProperty(key))
                    (<any>data["metadata"])[key] = (<any>this.metadata)[key];
            }
        }
        return data;
    }
}

export interface ISystemEventRequestDto {
    eventType?: string | undefined;
    message?: string | undefined;
    component?: string | undefined;
    metadata?: { [key: string]: any; } | undefined;
}

export class TestAlertRuleDto implements ITestAlertRuleDto {
    canonicalProductId!: string;
    conditionType!: string;
    alertType!: string;
    thresholdValue?: number | undefined;
    percentageValue?: number | undefined;
    specificSellerName?: string | undefined;
    notificationFrequencyMinutes?: number;

    constructor(data?: ITestAlertRuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.canonicalProductId = _data["canonicalProductId"];
            this.conditionType = _data["conditionType"];
            this.alertType = _data["alertType"];
            this.thresholdValue = _data["thresholdValue"];
            this.percentageValue = _data["percentageValue"];
            this.specificSellerName = _data["specificSellerName"];
            this.notificationFrequencyMinutes = _data["notificationFrequencyMinutes"];
        }
    }

    static fromJS(data: any): TestAlertRuleDto {
        data = typeof data === 'object' ? data : {};
        let result = new TestAlertRuleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canonicalProductId"] = this.canonicalProductId;
        data["conditionType"] = this.conditionType;
        data["alertType"] = this.alertType;
        data["thresholdValue"] = this.thresholdValue;
        data["percentageValue"] = this.percentageValue;
        data["specificSellerName"] = this.specificSellerName;
        data["notificationFrequencyMinutes"] = this.notificationFrequencyMinutes;
        return data;
    }
}

export interface ITestAlertRuleDto {
    canonicalProductId: string;
    conditionType: string;
    alertType: string;
    thresholdValue?: number | undefined;
    percentageValue?: number | undefined;
    specificSellerName?: string | undefined;
    notificationFrequencyMinutes?: number;
}

export class TestComparisonDifference implements ITestComparisonDifference {
    category?: string | undefined;
    field?: string | undefined;
    firstValue?: string | undefined;
    secondValue?: string | undefined;
    type?: DifferenceType;
    severity?: DifferenceSeverity;
    description?: string | undefined;

    constructor(data?: ITestComparisonDifference) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.category = _data["category"];
            this.field = _data["field"];
            this.firstValue = _data["firstValue"];
            this.secondValue = _data["secondValue"];
            this.type = _data["type"];
            this.severity = _data["severity"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): TestComparisonDifference {
        data = typeof data === 'object' ? data : {};
        let result = new TestComparisonDifference();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["category"] = this.category;
        data["field"] = this.field;
        data["firstValue"] = this.firstValue;
        data["secondValue"] = this.secondValue;
        data["type"] = this.type;
        data["severity"] = this.severity;
        data["description"] = this.description;
        return data;
    }
}

export interface ITestComparisonDifference {
    category?: string | undefined;
    field?: string | undefined;
    firstValue?: string | undefined;
    secondValue?: string | undefined;
    type?: DifferenceType;
    severity?: DifferenceSeverity;
    description?: string | undefined;
}

export class TestComparisonMetrics implements ITestComparisonMetrics {
    duration?: MetricComparison;
    actionsExecuted?: MetricComparison;
    errorCount?: MetricComparison;
    memoryUsage?: MetricComparison;
    networkRequests?: MetricComparison;
    pageLoadTime?: MetricComparison;

    constructor(data?: ITestComparisonMetrics) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.duration = _data["duration"] ? MetricComparison.fromJS(_data["duration"]) : <any>undefined;
            this.actionsExecuted = _data["actionsExecuted"] ? MetricComparison.fromJS(_data["actionsExecuted"]) : <any>undefined;
            this.errorCount = _data["errorCount"] ? MetricComparison.fromJS(_data["errorCount"]) : <any>undefined;
            this.memoryUsage = _data["memoryUsage"] ? MetricComparison.fromJS(_data["memoryUsage"]) : <any>undefined;
            this.networkRequests = _data["networkRequests"] ? MetricComparison.fromJS(_data["networkRequests"]) : <any>undefined;
            this.pageLoadTime = _data["pageLoadTime"] ? MetricComparison.fromJS(_data["pageLoadTime"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TestComparisonMetrics {
        data = typeof data === 'object' ? data : {};
        let result = new TestComparisonMetrics();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["duration"] = this.duration ? this.duration.toJSON() : <any>undefined;
        data["actionsExecuted"] = this.actionsExecuted ? this.actionsExecuted.toJSON() : <any>undefined;
        data["errorCount"] = this.errorCount ? this.errorCount.toJSON() : <any>undefined;
        data["memoryUsage"] = this.memoryUsage ? this.memoryUsage.toJSON() : <any>undefined;
        data["networkRequests"] = this.networkRequests ? this.networkRequests.toJSON() : <any>undefined;
        data["pageLoadTime"] = this.pageLoadTime ? this.pageLoadTime.toJSON() : <any>undefined;
        return data;
    }
}

export interface ITestComparisonMetrics {
    duration?: MetricComparison;
    actionsExecuted?: MetricComparison;
    errorCount?: MetricComparison;
    memoryUsage?: MetricComparison;
    networkRequests?: MetricComparison;
    pageLoadTime?: MetricComparison;
}

export class TestComparisonSummary implements ITestComparisonSummary {
    areEqual?: boolean;
    totalDifferences?: number;
    criticalDifferences?: number;
    warningDifferences?: number;
    infoDifferences?: number;
    similarityScore?: number;
    overallAssessment?: string | undefined;
    recommendations?: string[] | undefined;

    constructor(data?: ITestComparisonSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.areEqual = _data["areEqual"];
            this.totalDifferences = _data["totalDifferences"];
            this.criticalDifferences = _data["criticalDifferences"];
            this.warningDifferences = _data["warningDifferences"];
            this.infoDifferences = _data["infoDifferences"];
            this.similarityScore = _data["similarityScore"];
            this.overallAssessment = _data["overallAssessment"];
            if (Array.isArray(_data["recommendations"])) {
                this.recommendations = [] as any;
                for (let item of _data["recommendations"])
                    this.recommendations!.push(item);
            }
        }
    }

    static fromJS(data: any): TestComparisonSummary {
        data = typeof data === 'object' ? data : {};
        let result = new TestComparisonSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["areEqual"] = this.areEqual;
        data["totalDifferences"] = this.totalDifferences;
        data["criticalDifferences"] = this.criticalDifferences;
        data["warningDifferences"] = this.warningDifferences;
        data["infoDifferences"] = this.infoDifferences;
        data["similarityScore"] = this.similarityScore;
        data["overallAssessment"] = this.overallAssessment;
        if (Array.isArray(this.recommendations)) {
            data["recommendations"] = [];
            for (let item of this.recommendations)
                data["recommendations"].push(item);
        }
        return data;
    }
}

export interface ITestComparisonSummary {
    areEqual?: boolean;
    totalDifferences?: number;
    criticalDifferences?: number;
    warningDifferences?: number;
    infoDifferences?: number;
    similarityScore?: number;
    overallAssessment?: string | undefined;
    recommendations?: string[] | undefined;
}

export class TestDiscordWebhookDto implements ITestDiscordWebhookDto {
    discordWebhookUrl!: string;
    customBotName?: string | undefined;
    customAvatarUrl?: string | undefined;

    constructor(data?: ITestDiscordWebhookDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.discordWebhookUrl = _data["discordWebhookUrl"];
            this.customBotName = _data["customBotName"];
            this.customAvatarUrl = _data["customAvatarUrl"];
        }
    }

    static fromJS(data: any): TestDiscordWebhookDto {
        data = typeof data === 'object' ? data : {};
        let result = new TestDiscordWebhookDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["discordWebhookUrl"] = this.discordWebhookUrl;
        data["customBotName"] = this.customBotName;
        data["customAvatarUrl"] = this.customAvatarUrl;
        return data;
    }
}

export interface ITestDiscordWebhookDto {
    discordWebhookUrl: string;
    customBotName?: string | undefined;
    customAvatarUrl?: string | undefined;
}

export class TestErrorDto implements ITestErrorDto {
    code?: string | undefined;
    message?: string | undefined;
    details?: string | undefined;
    actionIndex?: number | undefined;
    timestamp?: Date;

    constructor(data?: ITestErrorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.message = _data["message"];
            this.details = _data["details"];
            this.actionIndex = _data["actionIndex"];
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): TestErrorDto {
        data = typeof data === 'object' ? data : {};
        let result = new TestErrorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        data["details"] = this.details;
        data["actionIndex"] = this.actionIndex;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        return data;
    }
}

export interface ITestErrorDto {
    code?: string | undefined;
    message?: string | undefined;
    details?: string | undefined;
    actionIndex?: number | undefined;
    timestamp?: Date;
}

export class TestExecutionTrendsDto implements ITestExecutionTrendsDto {
    overallStatistics?: TestStatistics;
    trendData?: TestTrendDataPoint[] | undefined;
    topErrors?: TopErrorDto[] | undefined;
    performanceTrends?: PerformanceTrendDto[] | undefined;
    popularTestUrls?: PopularTestUrlDto[] | undefined;
    reliability?: TestReliabilityMetrics;

    constructor(data?: ITestExecutionTrendsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.overallStatistics = _data["overallStatistics"] ? TestStatistics.fromJS(_data["overallStatistics"]) : <any>undefined;
            if (Array.isArray(_data["trendData"])) {
                this.trendData = [] as any;
                for (let item of _data["trendData"])
                    this.trendData!.push(TestTrendDataPoint.fromJS(item));
            }
            if (Array.isArray(_data["topErrors"])) {
                this.topErrors = [] as any;
                for (let item of _data["topErrors"])
                    this.topErrors!.push(TopErrorDto.fromJS(item));
            }
            if (Array.isArray(_data["performanceTrends"])) {
                this.performanceTrends = [] as any;
                for (let item of _data["performanceTrends"])
                    this.performanceTrends!.push(PerformanceTrendDto.fromJS(item));
            }
            if (Array.isArray(_data["popularTestUrls"])) {
                this.popularTestUrls = [] as any;
                for (let item of _data["popularTestUrls"])
                    this.popularTestUrls!.push(PopularTestUrlDto.fromJS(item));
            }
            this.reliability = _data["reliability"] ? TestReliabilityMetrics.fromJS(_data["reliability"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TestExecutionTrendsDto {
        data = typeof data === 'object' ? data : {};
        let result = new TestExecutionTrendsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["overallStatistics"] = this.overallStatistics ? this.overallStatistics.toJSON() : <any>undefined;
        if (Array.isArray(this.trendData)) {
            data["trendData"] = [];
            for (let item of this.trendData)
                data["trendData"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.topErrors)) {
            data["topErrors"] = [];
            for (let item of this.topErrors)
                data["topErrors"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.performanceTrends)) {
            data["performanceTrends"] = [];
            for (let item of this.performanceTrends)
                data["performanceTrends"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.popularTestUrls)) {
            data["popularTestUrls"] = [];
            for (let item of this.popularTestUrls)
                data["popularTestUrls"].push(item ? item.toJSON() : <any>undefined);
        }
        data["reliability"] = this.reliability ? this.reliability.toJSON() : <any>undefined;
        return data;
    }
}

export interface ITestExecutionTrendsDto {
    overallStatistics?: TestStatistics;
    trendData?: TestTrendDataPoint[] | undefined;
    topErrors?: TopErrorDto[] | undefined;
    performanceTrends?: PerformanceTrendDto[] | undefined;
    popularTestUrls?: PopularTestUrlDto[] | undefined;
    reliability?: TestReliabilityMetrics;
}

export class TestExecutionTrendsDtoApiResponse implements ITestExecutionTrendsDtoApiResponse {
    success?: boolean;
    data?: TestExecutionTrendsDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: ITestExecutionTrendsDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"] ? TestExecutionTrendsDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): TestExecutionTrendsDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TestExecutionTrendsDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface ITestExecutionTrendsDtoApiResponse {
    success?: boolean;
    data?: TestExecutionTrendsDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class TestHistoryEntryDto implements ITestHistoryEntryDto {
    sessionId?: string | undefined;
    savedResultId?: string | undefined;
    testUrl?: string | undefined;
    profileHash?: string | undefined;
    success?: boolean;
    executedAt?: Date;
    duration?: number;
    actionsExecuted?: number;
    errorCount?: number;
    executedBy?: string | undefined;
    sessionName?: string | undefined;
    browserEngine?: string | undefined;
    deviceType?: string | undefined;

    constructor(data?: ITestHistoryEntryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sessionId = _data["sessionId"];
            this.savedResultId = _data["savedResultId"];
            this.testUrl = _data["testUrl"];
            this.profileHash = _data["profileHash"];
            this.success = _data["success"];
            this.executedAt = _data["executedAt"] ? new Date(_data["executedAt"].toString()) : <any>undefined;
            this.duration = _data["duration"];
            this.actionsExecuted = _data["actionsExecuted"];
            this.errorCount = _data["errorCount"];
            this.executedBy = _data["executedBy"];
            this.sessionName = _data["sessionName"];
            this.browserEngine = _data["browserEngine"];
            this.deviceType = _data["deviceType"];
        }
    }

    static fromJS(data: any): TestHistoryEntryDto {
        data = typeof data === 'object' ? data : {};
        let result = new TestHistoryEntryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sessionId"] = this.sessionId;
        data["savedResultId"] = this.savedResultId;
        data["testUrl"] = this.testUrl;
        data["profileHash"] = this.profileHash;
        data["success"] = this.success;
        data["executedAt"] = this.executedAt ? this.executedAt.toISOString() : <any>undefined;
        data["duration"] = this.duration;
        data["actionsExecuted"] = this.actionsExecuted;
        data["errorCount"] = this.errorCount;
        data["executedBy"] = this.executedBy;
        data["sessionName"] = this.sessionName;
        data["browserEngine"] = this.browserEngine;
        data["deviceType"] = this.deviceType;
        return data;
    }
}

export interface ITestHistoryEntryDto {
    sessionId?: string | undefined;
    savedResultId?: string | undefined;
    testUrl?: string | undefined;
    profileHash?: string | undefined;
    success?: boolean;
    executedAt?: Date;
    duration?: number;
    actionsExecuted?: number;
    errorCount?: number;
    executedBy?: string | undefined;
    sessionName?: string | undefined;
    browserEngine?: string | undefined;
    deviceType?: string | undefined;
}

export class TestHistoryEntryDtoListApiResponse implements ITestHistoryEntryDtoListApiResponse {
    success?: boolean;
    data?: TestHistoryEntryDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: ITestHistoryEntryDtoListApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(TestHistoryEntryDto.fromJS(item));
            }
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): TestHistoryEntryDtoListApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TestHistoryEntryDtoListApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : <any>undefined);
        }
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface ITestHistoryEntryDtoListApiResponse {
    success?: boolean;
    data?: TestHistoryEntryDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class TestPricePointDto implements ITestPricePointDto {
    price!: number;
    stockStatus!: string;
    sellerName?: string | undefined;
    sourceUrl?: string | undefined;
    timestamp?: Date | undefined;

    constructor(data?: ITestPricePointDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.price = _data["price"];
            this.stockStatus = _data["stockStatus"];
            this.sellerName = _data["sellerName"];
            this.sourceUrl = _data["sourceUrl"];
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): TestPricePointDto {
        data = typeof data === 'object' ? data : {};
        let result = new TestPricePointDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["price"] = this.price;
        data["stockStatus"] = this.stockStatus;
        data["sellerName"] = this.sellerName;
        data["sourceUrl"] = this.sourceUrl;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        return data;
    }
}

export interface ITestPricePointDto {
    price: number;
    stockStatus: string;
    sellerName?: string | undefined;
    sourceUrl?: string | undefined;
    timestamp?: Date | undefined;
}

export class TestReliabilityMetrics implements ITestReliabilityMetrics {
    overallReliability?: number;
    consistencyScore?: number;
    flakeyTests?: number;
    mostReliableUrls?: string[] | undefined;
    leastReliableUrls?: string[] | undefined;
    reliabilityByBrowser?: { [key: string]: number; } | undefined;

    constructor(data?: ITestReliabilityMetrics) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.overallReliability = _data["overallReliability"];
            this.consistencyScore = _data["consistencyScore"];
            this.flakeyTests = _data["flakeyTests"];
            if (Array.isArray(_data["mostReliableUrls"])) {
                this.mostReliableUrls = [] as any;
                for (let item of _data["mostReliableUrls"])
                    this.mostReliableUrls!.push(item);
            }
            if (Array.isArray(_data["leastReliableUrls"])) {
                this.leastReliableUrls = [] as any;
                for (let item of _data["leastReliableUrls"])
                    this.leastReliableUrls!.push(item);
            }
            if (_data["reliabilityByBrowser"]) {
                this.reliabilityByBrowser = {} as any;
                for (let key in _data["reliabilityByBrowser"]) {
                    if (_data["reliabilityByBrowser"].hasOwnProperty(key))
                        (<any>this.reliabilityByBrowser)![key] = _data["reliabilityByBrowser"][key];
                }
            }
        }
    }

    static fromJS(data: any): TestReliabilityMetrics {
        data = typeof data === 'object' ? data : {};
        let result = new TestReliabilityMetrics();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["overallReliability"] = this.overallReliability;
        data["consistencyScore"] = this.consistencyScore;
        data["flakeyTests"] = this.flakeyTests;
        if (Array.isArray(this.mostReliableUrls)) {
            data["mostReliableUrls"] = [];
            for (let item of this.mostReliableUrls)
                data["mostReliableUrls"].push(item);
        }
        if (Array.isArray(this.leastReliableUrls)) {
            data["leastReliableUrls"] = [];
            for (let item of this.leastReliableUrls)
                data["leastReliableUrls"].push(item);
        }
        if (this.reliabilityByBrowser) {
            data["reliabilityByBrowser"] = {};
            for (let key in this.reliabilityByBrowser) {
                if (this.reliabilityByBrowser.hasOwnProperty(key))
                    (<any>data["reliabilityByBrowser"])[key] = (<any>this.reliabilityByBrowser)[key];
            }
        }
        return data;
    }
}

export interface ITestReliabilityMetrics {
    overallReliability?: number;
    consistencyScore?: number;
    flakeyTests?: number;
    mostReliableUrls?: string[] | undefined;
    leastReliableUrls?: string[] | undefined;
    reliabilityByBrowser?: { [key: string]: number; } | undefined;
}

export class TestResultComparisonDto implements ITestResultComparisonDto {
    firstResult?: SavedTestResultDto;
    secondResult?: SavedTestResultDto;
    metrics?: TestComparisonMetrics;
    differences?: TestComparisonDifference[] | undefined;
    summary?: TestComparisonSummary;

    constructor(data?: ITestResultComparisonDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firstResult = _data["firstResult"] ? SavedTestResultDto.fromJS(_data["firstResult"]) : <any>undefined;
            this.secondResult = _data["secondResult"] ? SavedTestResultDto.fromJS(_data["secondResult"]) : <any>undefined;
            this.metrics = _data["metrics"] ? TestComparisonMetrics.fromJS(_data["metrics"]) : <any>undefined;
            if (Array.isArray(_data["differences"])) {
                this.differences = [] as any;
                for (let item of _data["differences"])
                    this.differences!.push(TestComparisonDifference.fromJS(item));
            }
            this.summary = _data["summary"] ? TestComparisonSummary.fromJS(_data["summary"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TestResultComparisonDto {
        data = typeof data === 'object' ? data : {};
        let result = new TestResultComparisonDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstResult"] = this.firstResult ? this.firstResult.toJSON() : <any>undefined;
        data["secondResult"] = this.secondResult ? this.secondResult.toJSON() : <any>undefined;
        data["metrics"] = this.metrics ? this.metrics.toJSON() : <any>undefined;
        if (Array.isArray(this.differences)) {
            data["differences"] = [];
            for (let item of this.differences)
                data["differences"].push(item ? item.toJSON() : <any>undefined);
        }
        data["summary"] = this.summary ? this.summary.toJSON() : <any>undefined;
        return data;
    }
}

export interface ITestResultComparisonDto {
    firstResult?: SavedTestResultDto;
    secondResult?: SavedTestResultDto;
    metrics?: TestComparisonMetrics;
    differences?: TestComparisonDifference[] | undefined;
    summary?: TestComparisonSummary;
}

export class TestResultComparisonDtoApiResponse implements ITestResultComparisonDtoApiResponse {
    success?: boolean;
    data?: TestResultComparisonDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: ITestResultComparisonDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"] ? TestResultComparisonDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): TestResultComparisonDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TestResultComparisonDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface ITestResultComparisonDtoApiResponse {
    success?: boolean;
    data?: TestResultComparisonDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class TestSessionStatusDto implements ITestSessionStatusDto {
    status?: string | undefined;
    progress?: number;
    currentAction?: string | undefined;
    lastUpdated?: Date;

    constructor(data?: ITestSessionStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.progress = _data["progress"];
            this.currentAction = _data["currentAction"];
            this.lastUpdated = _data["lastUpdated"] ? new Date(_data["lastUpdated"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): TestSessionStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new TestSessionStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["progress"] = this.progress;
        data["currentAction"] = this.currentAction;
        data["lastUpdated"] = this.lastUpdated ? this.lastUpdated.toISOString() : <any>undefined;
        return data;
    }
}

export interface ITestSessionStatusDto {
    status?: string | undefined;
    progress?: number;
    currentAction?: string | undefined;
    lastUpdated?: Date;
}

export class TestSessionStatusDtoApiResponse implements ITestSessionStatusDtoApiResponse {
    success?: boolean;
    data?: TestSessionStatusDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: ITestSessionStatusDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"] ? TestSessionStatusDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): TestSessionStatusDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TestSessionStatusDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface ITestSessionStatusDtoApiResponse {
    success?: boolean;
    data?: TestSessionStatusDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class TestStatistics implements ITestStatistics {
    totalTests?: number;
    successfulTests?: number;
    failedTests?: number;
    successRate?: number;
    averageExecutionTime?: number;
    medianExecutionTime?: number;
    totalActionsExecuted?: number;
    firstTestDate?: Date | undefined;
    lastTestDate?: Date | undefined;
    uniqueUrls?: number;
    uniqueProfiles?: number;

    constructor(data?: ITestStatistics) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalTests = _data["totalTests"];
            this.successfulTests = _data["successfulTests"];
            this.failedTests = _data["failedTests"];
            this.successRate = _data["successRate"];
            this.averageExecutionTime = _data["averageExecutionTime"];
            this.medianExecutionTime = _data["medianExecutionTime"];
            this.totalActionsExecuted = _data["totalActionsExecuted"];
            this.firstTestDate = _data["firstTestDate"] ? new Date(_data["firstTestDate"].toString()) : <any>undefined;
            this.lastTestDate = _data["lastTestDate"] ? new Date(_data["lastTestDate"].toString()) : <any>undefined;
            this.uniqueUrls = _data["uniqueUrls"];
            this.uniqueProfiles = _data["uniqueProfiles"];
        }
    }

    static fromJS(data: any): TestStatistics {
        data = typeof data === 'object' ? data : {};
        let result = new TestStatistics();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalTests"] = this.totalTests;
        data["successfulTests"] = this.successfulTests;
        data["failedTests"] = this.failedTests;
        data["successRate"] = this.successRate;
        data["averageExecutionTime"] = this.averageExecutionTime;
        data["medianExecutionTime"] = this.medianExecutionTime;
        data["totalActionsExecuted"] = this.totalActionsExecuted;
        data["firstTestDate"] = this.firstTestDate ? this.firstTestDate.toISOString() : <any>undefined;
        data["lastTestDate"] = this.lastTestDate ? this.lastTestDate.toISOString() : <any>undefined;
        data["uniqueUrls"] = this.uniqueUrls;
        data["uniqueProfiles"] = this.uniqueProfiles;
        return data;
    }
}

export interface ITestStatistics {
    totalTests?: number;
    successfulTests?: number;
    failedTests?: number;
    successRate?: number;
    averageExecutionTime?: number;
    medianExecutionTime?: number;
    totalActionsExecuted?: number;
    firstTestDate?: Date | undefined;
    lastTestDate?: Date | undefined;
    uniqueUrls?: number;
    uniqueProfiles?: number;
}

export class TestStatisticsApiResponse implements ITestStatisticsApiResponse {
    success?: boolean;
    data?: TestStatistics;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: ITestStatisticsApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"] ? TestStatistics.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): TestStatisticsApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TestStatisticsApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface ITestStatisticsApiResponse {
    success?: boolean;
    data?: TestStatistics;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class TestTrendDataPoint implements ITestTrendDataPoint {
    date?: Date;
    testCount?: number;
    successRate?: number;
    averageExecutionTime?: number;
    errorCount?: number;

    constructor(data?: ITestTrendDataPoint) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.testCount = _data["testCount"];
            this.successRate = _data["successRate"];
            this.averageExecutionTime = _data["averageExecutionTime"];
            this.errorCount = _data["errorCount"];
        }
    }

    static fromJS(data: any): TestTrendDataPoint {
        data = typeof data === 'object' ? data : {};
        let result = new TestTrendDataPoint();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["testCount"] = this.testCount;
        data["successRate"] = this.successRate;
        data["averageExecutionTime"] = this.averageExecutionTime;
        data["errorCount"] = this.errorCount;
        return data;
    }
}

export interface ITestTrendDataPoint {
    date?: Date;
    testCount?: number;
    successRate?: number;
    averageExecutionTime?: number;
    errorCount?: number;
}

export class TestWarningDto implements ITestWarningDto {
    code?: string | undefined;
    message?: string | undefined;
    details?: string | undefined;
    actionIndex?: number | undefined;
    timestamp?: Date;

    constructor(data?: ITestWarningDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.message = _data["message"];
            this.details = _data["details"];
            this.actionIndex = _data["actionIndex"];
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): TestWarningDto {
        data = typeof data === 'object' ? data : {};
        let result = new TestWarningDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        data["details"] = this.details;
        data["actionIndex"] = this.actionIndex;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        return data;
    }
}

export interface ITestWarningDto {
    code?: string | undefined;
    message?: string | undefined;
    details?: string | undefined;
    actionIndex?: number | undefined;
    timestamp?: Date;
}

export class TopErrorDto implements ITopErrorDto {
    errorMessage?: string | undefined;
    occurrences?: number;
    percentage?: number;
    affectedUrls?: string[] | undefined;
    firstOccurrence?: Date | undefined;
    lastOccurrence?: Date | undefined;

    constructor(data?: ITopErrorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.errorMessage = _data["errorMessage"];
            this.occurrences = _data["occurrences"];
            this.percentage = _data["percentage"];
            if (Array.isArray(_data["affectedUrls"])) {
                this.affectedUrls = [] as any;
                for (let item of _data["affectedUrls"])
                    this.affectedUrls!.push(item);
            }
            this.firstOccurrence = _data["firstOccurrence"] ? new Date(_data["firstOccurrence"].toString()) : <any>undefined;
            this.lastOccurrence = _data["lastOccurrence"] ? new Date(_data["lastOccurrence"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): TopErrorDto {
        data = typeof data === 'object' ? data : {};
        let result = new TopErrorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["errorMessage"] = this.errorMessage;
        data["occurrences"] = this.occurrences;
        data["percentage"] = this.percentage;
        if (Array.isArray(this.affectedUrls)) {
            data["affectedUrls"] = [];
            for (let item of this.affectedUrls)
                data["affectedUrls"].push(item);
        }
        data["firstOccurrence"] = this.firstOccurrence ? this.firstOccurrence.toISOString() : <any>undefined;
        data["lastOccurrence"] = this.lastOccurrence ? this.lastOccurrence.toISOString() : <any>undefined;
        return data;
    }
}

export interface ITopErrorDto {
    errorMessage?: string | undefined;
    occurrences?: number;
    percentage?: number;
    affectedUrls?: string[] | undefined;
    firstOccurrence?: Date | undefined;
    lastOccurrence?: Date | undefined;
}

export class UpdateAiConfigurationDto implements IUpdateAiConfigurationDto {
    name?: string | undefined;
    description?: string | undefined;
    openApiCompatibleUrl?: string | undefined;
    apiKey?: string | undefined;
    model?: string | undefined;
    inputTokenLimit?: number | undefined;
    outputTokenLimit?: number | undefined;
    capabilities?: string[] | undefined;
    supportedInputTypes?: string[] | undefined;
    supportedOutputTypes?: string[] | undefined;
    rateLimitRpm?: number | undefined;
    rateLimitTpm?: number | undefined;
    rateLimitRpd?: number | undefined;
    isActive?: boolean | undefined;
    isDefault?: boolean | undefined;

    constructor(data?: IUpdateAiConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.openApiCompatibleUrl = _data["openApiCompatibleUrl"];
            this.apiKey = _data["apiKey"];
            this.model = _data["model"];
            this.inputTokenLimit = _data["inputTokenLimit"];
            this.outputTokenLimit = _data["outputTokenLimit"];
            if (Array.isArray(_data["capabilities"])) {
                this.capabilities = [] as any;
                for (let item of _data["capabilities"])
                    this.capabilities!.push(item);
            }
            if (Array.isArray(_data["supportedInputTypes"])) {
                this.supportedInputTypes = [] as any;
                for (let item of _data["supportedInputTypes"])
                    this.supportedInputTypes!.push(item);
            }
            if (Array.isArray(_data["supportedOutputTypes"])) {
                this.supportedOutputTypes = [] as any;
                for (let item of _data["supportedOutputTypes"])
                    this.supportedOutputTypes!.push(item);
            }
            this.rateLimitRpm = _data["rateLimitRpm"];
            this.rateLimitTpm = _data["rateLimitTpm"];
            this.rateLimitRpd = _data["rateLimitRpd"];
            this.isActive = _data["isActive"];
            this.isDefault = _data["isDefault"];
        }
    }

    static fromJS(data: any): UpdateAiConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAiConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["openApiCompatibleUrl"] = this.openApiCompatibleUrl;
        data["apiKey"] = this.apiKey;
        data["model"] = this.model;
        data["inputTokenLimit"] = this.inputTokenLimit;
        data["outputTokenLimit"] = this.outputTokenLimit;
        if (Array.isArray(this.capabilities)) {
            data["capabilities"] = [];
            for (let item of this.capabilities)
                data["capabilities"].push(item);
        }
        if (Array.isArray(this.supportedInputTypes)) {
            data["supportedInputTypes"] = [];
            for (let item of this.supportedInputTypes)
                data["supportedInputTypes"].push(item);
        }
        if (Array.isArray(this.supportedOutputTypes)) {
            data["supportedOutputTypes"] = [];
            for (let item of this.supportedOutputTypes)
                data["supportedOutputTypes"].push(item);
        }
        data["rateLimitRpm"] = this.rateLimitRpm;
        data["rateLimitTpm"] = this.rateLimitTpm;
        data["rateLimitRpd"] = this.rateLimitRpd;
        data["isActive"] = this.isActive;
        data["isDefault"] = this.isDefault;
        return data;
    }
}

export interface IUpdateAiConfigurationDto {
    name?: string | undefined;
    description?: string | undefined;
    openApiCompatibleUrl?: string | undefined;
    apiKey?: string | undefined;
    model?: string | undefined;
    inputTokenLimit?: number | undefined;
    outputTokenLimit?: number | undefined;
    capabilities?: string[] | undefined;
    supportedInputTypes?: string[] | undefined;
    supportedOutputTypes?: string[] | undefined;
    rateLimitRpm?: number | undefined;
    rateLimitTpm?: number | undefined;
    rateLimitRpd?: number | undefined;
    isActive?: boolean | undefined;
    isDefault?: boolean | undefined;
}

export class UpdateAlertRuleDto implements IUpdateAlertRuleDto {
    conditionType?: string | undefined;
    alertType?: string | undefined;
    thresholdValue?: number | undefined;
    percentageValue?: number | undefined;
    specificSellerName?: string | undefined;
    notificationFrequencyMinutes?: number | undefined;
    isActive?: boolean | undefined;

    constructor(data?: IUpdateAlertRuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.conditionType = _data["conditionType"];
            this.alertType = _data["alertType"];
            this.thresholdValue = _data["thresholdValue"];
            this.percentageValue = _data["percentageValue"];
            this.specificSellerName = _data["specificSellerName"];
            this.notificationFrequencyMinutes = _data["notificationFrequencyMinutes"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): UpdateAlertRuleDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAlertRuleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["conditionType"] = this.conditionType;
        data["alertType"] = this.alertType;
        data["thresholdValue"] = this.thresholdValue;
        data["percentageValue"] = this.percentageValue;
        data["specificSellerName"] = this.specificSellerName;
        data["notificationFrequencyMinutes"] = this.notificationFrequencyMinutes;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IUpdateAlertRuleDto {
    conditionType?: string | undefined;
    alertType?: string | undefined;
    thresholdValue?: number | undefined;
    percentageValue?: number | undefined;
    specificSellerName?: string | undefined;
    notificationFrequencyMinutes?: number | undefined;
    isActive?: boolean | undefined;
}

export class UpdateCategoryDto implements IUpdateCategoryDto {
    name?: string | undefined;
    slug?: string | undefined;
    description?: string | undefined;

    constructor(data?: IUpdateCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): UpdateCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["description"] = this.description;
        return data;
    }
}

export interface IUpdateCategoryDto {
    name?: string | undefined;
    slug?: string | undefined;
    description?: string | undefined;
}

export class UpdatePermissionDto implements IUpdatePermissionDto {
    description?: string | undefined;
    category?: string | undefined;

    constructor(data?: IUpdatePermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.category = _data["category"];
        }
    }

    static fromJS(data: any): UpdatePermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["category"] = this.category;
        return data;
    }
}

export interface IUpdatePermissionDto {
    description?: string | undefined;
    category?: string | undefined;
}

export class UpdateProductDto implements IUpdateProductDto {
    name?: string | undefined;
    manufacturer?: string | undefined;
    modelNumber?: string | undefined;
    sku?: string | undefined;
    categoryId?: string | undefined;
    description?: string | undefined;
    normalizedSpecifications?: { [key: string]: NormalizedSpecificationValue; } | undefined;
    uncategorizedSpecifications?: { [key: string]: string; } | undefined;
    isActive?: boolean | undefined;
    primaryImageUrl?: string | undefined;
    additionalImageUrls?: string[] | undefined;

    constructor(data?: IUpdateProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.manufacturer = _data["manufacturer"];
            this.modelNumber = _data["modelNumber"];
            this.sku = _data["sku"];
            this.categoryId = _data["categoryId"];
            this.description = _data["description"];
            if (_data["normalizedSpecifications"]) {
                this.normalizedSpecifications = {} as any;
                for (let key in _data["normalizedSpecifications"]) {
                    if (_data["normalizedSpecifications"].hasOwnProperty(key))
                        (<any>this.normalizedSpecifications)![key] = _data["normalizedSpecifications"][key] ? NormalizedSpecificationValue.fromJS(_data["normalizedSpecifications"][key]) : new NormalizedSpecificationValue();
                }
            }
            if (_data["uncategorizedSpecifications"]) {
                this.uncategorizedSpecifications = {} as any;
                for (let key in _data["uncategorizedSpecifications"]) {
                    if (_data["uncategorizedSpecifications"].hasOwnProperty(key))
                        (<any>this.uncategorizedSpecifications)![key] = _data["uncategorizedSpecifications"][key];
                }
            }
            this.isActive = _data["isActive"];
            this.primaryImageUrl = _data["primaryImageUrl"];
            if (Array.isArray(_data["additionalImageUrls"])) {
                this.additionalImageUrls = [] as any;
                for (let item of _data["additionalImageUrls"])
                    this.additionalImageUrls!.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["manufacturer"] = this.manufacturer;
        data["modelNumber"] = this.modelNumber;
        data["sku"] = this.sku;
        data["categoryId"] = this.categoryId;
        data["description"] = this.description;
        if (this.normalizedSpecifications) {
            data["normalizedSpecifications"] = {};
            for (let key in this.normalizedSpecifications) {
                if (this.normalizedSpecifications.hasOwnProperty(key))
                    (<any>data["normalizedSpecifications"])[key] = this.normalizedSpecifications[key] ? this.normalizedSpecifications[key].toJSON() : <any>undefined;
            }
        }
        if (this.uncategorizedSpecifications) {
            data["uncategorizedSpecifications"] = {};
            for (let key in this.uncategorizedSpecifications) {
                if (this.uncategorizedSpecifications.hasOwnProperty(key))
                    (<any>data["uncategorizedSpecifications"])[key] = (<any>this.uncategorizedSpecifications)[key];
            }
        }
        data["isActive"] = this.isActive;
        data["primaryImageUrl"] = this.primaryImageUrl;
        if (Array.isArray(this.additionalImageUrls)) {
            data["additionalImageUrls"] = [];
            for (let item of this.additionalImageUrls)
                data["additionalImageUrls"].push(item);
        }
        return data;
    }
}

export interface IUpdateProductDto {
    name?: string | undefined;
    manufacturer?: string | undefined;
    modelNumber?: string | undefined;
    sku?: string | undefined;
    categoryId?: string | undefined;
    description?: string | undefined;
    normalizedSpecifications?: { [key: string]: NormalizedSpecificationValue; } | undefined;
    uncategorizedSpecifications?: { [key: string]: string; } | undefined;
    isActive?: boolean | undefined;
    primaryImageUrl?: string | undefined;
    additionalImageUrls?: string[] | undefined;
}

export class UpdateProductSellerMappingDto implements IUpdateProductSellerMappingDto {
    sellerName?: string | undefined;
    exactProductUrl?: string | undefined;
    isActiveForScraping?: boolean | undefined;
    scrapingFrequencyOverride?: string | undefined;
    siteConfigId?: string | undefined;

    constructor(data?: IUpdateProductSellerMappingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sellerName = _data["sellerName"];
            this.exactProductUrl = _data["exactProductUrl"];
            this.isActiveForScraping = _data["isActiveForScraping"];
            this.scrapingFrequencyOverride = _data["scrapingFrequencyOverride"];
            this.siteConfigId = _data["siteConfigId"];
        }
    }

    static fromJS(data: any): UpdateProductSellerMappingDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductSellerMappingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sellerName"] = this.sellerName;
        data["exactProductUrl"] = this.exactProductUrl;
        data["isActiveForScraping"] = this.isActiveForScraping;
        data["scrapingFrequencyOverride"] = this.scrapingFrequencyOverride;
        data["siteConfigId"] = this.siteConfigId;
        return data;
    }
}

export interface IUpdateProductSellerMappingDto {
    sellerName?: string | undefined;
    exactProductUrl?: string | undefined;
    isActiveForScraping?: boolean | undefined;
    scrapingFrequencyOverride?: string | undefined;
    siteConfigId?: string | undefined;
}

export class UpdateProxyConfigurationDto implements IUpdateProxyConfigurationDto {
    host!: string;
    port!: number;
    proxyType!: string;
    username?: string | undefined;
    password?: string | undefined;
    description?: string | undefined;
    timeoutSeconds?: number;
    maxRetries?: number;
    isActive?: boolean;

    constructor(data?: IUpdateProxyConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.host = _data["host"];
            this.port = _data["port"];
            this.proxyType = _data["proxyType"];
            this.username = _data["username"];
            this.password = _data["password"];
            this.description = _data["description"];
            this.timeoutSeconds = _data["timeoutSeconds"];
            this.maxRetries = _data["maxRetries"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): UpdateProxyConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProxyConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["host"] = this.host;
        data["port"] = this.port;
        data["proxyType"] = this.proxyType;
        data["username"] = this.username;
        data["password"] = this.password;
        data["description"] = this.description;
        data["timeoutSeconds"] = this.timeoutSeconds;
        data["maxRetries"] = this.maxRetries;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IUpdateProxyConfigurationDto {
    host: string;
    port: number;
    proxyType: string;
    username?: string | undefined;
    password?: string | undefined;
    description?: string | undefined;
    timeoutSeconds?: number;
    maxRetries?: number;
    isActive?: boolean;
}

export class UpdateScraperSiteConfigurationDto implements IUpdateScraperSiteConfigurationDto {
    siteDomain?: string | undefined;
    productNameSelector?: string | undefined;
    priceSelector?: string | undefined;
    stockSelector?: string | undefined;
    sellerNameOnPageSelector?: string | undefined;
    imageSelector?: string | undefined;
    defaultUserAgent?: string | undefined;
    additionalHeaders?: { [key: string]: string; } | undefined;
    isEnabled?: boolean | undefined;
    requiresBrowserAutomation?: boolean | undefined;
    browserAutomationProfile?: string | undefined;
    specificationTableSelector?: string | undefined;
    specificationContainerSelector?: string | undefined;
    enableSpecificationScraping?: boolean | undefined;
    specificationOptions?: SpecificationParsingOptions;

    constructor(data?: IUpdateScraperSiteConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.siteDomain = _data["siteDomain"];
            this.productNameSelector = _data["productNameSelector"];
            this.priceSelector = _data["priceSelector"];
            this.stockSelector = _data["stockSelector"];
            this.sellerNameOnPageSelector = _data["sellerNameOnPageSelector"];
            this.imageSelector = _data["imageSelector"];
            this.defaultUserAgent = _data["defaultUserAgent"];
            if (_data["additionalHeaders"]) {
                this.additionalHeaders = {} as any;
                for (let key in _data["additionalHeaders"]) {
                    if (_data["additionalHeaders"].hasOwnProperty(key))
                        (<any>this.additionalHeaders)![key] = _data["additionalHeaders"][key];
                }
            }
            this.isEnabled = _data["isEnabled"];
            this.requiresBrowserAutomation = _data["requiresBrowserAutomation"];
            this.browserAutomationProfile = _data["browserAutomationProfile"];
            this.specificationTableSelector = _data["specificationTableSelector"];
            this.specificationContainerSelector = _data["specificationContainerSelector"];
            this.enableSpecificationScraping = _data["enableSpecificationScraping"];
            this.specificationOptions = _data["specificationOptions"] ? SpecificationParsingOptions.fromJS(_data["specificationOptions"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateScraperSiteConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateScraperSiteConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["siteDomain"] = this.siteDomain;
        data["productNameSelector"] = this.productNameSelector;
        data["priceSelector"] = this.priceSelector;
        data["stockSelector"] = this.stockSelector;
        data["sellerNameOnPageSelector"] = this.sellerNameOnPageSelector;
        data["imageSelector"] = this.imageSelector;
        data["defaultUserAgent"] = this.defaultUserAgent;
        if (this.additionalHeaders) {
            data["additionalHeaders"] = {};
            for (let key in this.additionalHeaders) {
                if (this.additionalHeaders.hasOwnProperty(key))
                    (<any>data["additionalHeaders"])[key] = (<any>this.additionalHeaders)[key];
            }
        }
        data["isEnabled"] = this.isEnabled;
        data["requiresBrowserAutomation"] = this.requiresBrowserAutomation;
        data["browserAutomationProfile"] = this.browserAutomationProfile;
        data["specificationTableSelector"] = this.specificationTableSelector;
        data["specificationContainerSelector"] = this.specificationContainerSelector;
        data["enableSpecificationScraping"] = this.enableSpecificationScraping;
        data["specificationOptions"] = this.specificationOptions ? this.specificationOptions.toJSON() : <any>undefined;
        return data;
    }
}

export interface IUpdateScraperSiteConfigurationDto {
    siteDomain?: string | undefined;
    productNameSelector?: string | undefined;
    priceSelector?: string | undefined;
    stockSelector?: string | undefined;
    sellerNameOnPageSelector?: string | undefined;
    imageSelector?: string | undefined;
    defaultUserAgent?: string | undefined;
    additionalHeaders?: { [key: string]: string; } | undefined;
    isEnabled?: boolean | undefined;
    requiresBrowserAutomation?: boolean | undefined;
    browserAutomationProfile?: string | undefined;
    specificationTableSelector?: string | undefined;
    specificationContainerSelector?: string | undefined;
    enableSpecificationScraping?: boolean | undefined;
    specificationOptions?: SpecificationParsingOptions;
}

export class UpdateUserDto implements IUpdateUserDto {
    email?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    roles?: string[] | undefined;
    isActive?: boolean | undefined;

    constructor(data?: IUpdateUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): UpdateUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IUpdateUserDto {
    email?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    roles?: string[] | undefined;
    isActive?: boolean | undefined;
}

export class UpdateUserNotificationPreferencesDto implements IUpdateUserNotificationPreferencesDto {
    discordWebhookUrl?: string | undefined;
    isDiscordNotificationEnabled?: boolean;
    notificationProductIds?: string[] | undefined;
    customBotName?: string | undefined;
    customAvatarUrl?: string | undefined;

    constructor(data?: IUpdateUserNotificationPreferencesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.discordWebhookUrl = _data["discordWebhookUrl"];
            this.isDiscordNotificationEnabled = _data["isDiscordNotificationEnabled"];
            if (Array.isArray(_data["notificationProductIds"])) {
                this.notificationProductIds = [] as any;
                for (let item of _data["notificationProductIds"])
                    this.notificationProductIds!.push(item);
            }
            this.customBotName = _data["customBotName"];
            this.customAvatarUrl = _data["customAvatarUrl"];
        }
    }

    static fromJS(data: any): UpdateUserNotificationPreferencesDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserNotificationPreferencesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["discordWebhookUrl"] = this.discordWebhookUrl;
        data["isDiscordNotificationEnabled"] = this.isDiscordNotificationEnabled;
        if (Array.isArray(this.notificationProductIds)) {
            data["notificationProductIds"] = [];
            for (let item of this.notificationProductIds)
                data["notificationProductIds"].push(item);
        }
        data["customBotName"] = this.customBotName;
        data["customAvatarUrl"] = this.customAvatarUrl;
        return data;
    }
}

export interface IUpdateUserNotificationPreferencesDto {
    discordWebhookUrl?: string | undefined;
    isDiscordNotificationEnabled?: boolean;
    notificationProductIds?: string[] | undefined;
    customBotName?: string | undefined;
    customAvatarUrl?: string | undefined;
}

export class UserDto implements IUserDto {
    userId?: string;
    email?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    fullName?: string | undefined;
    isActive?: boolean;
    createdAt?: Date;
    updatedAt?: Date;
    roles?: string[] | undefined;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.email = _data["email"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.fullName = _data["fullName"];
            this.isActive = _data["isActive"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["email"] = this.email;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["fullName"] = this.fullName;
        data["isActive"] = this.isActive;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data;
    }
}

export interface IUserDto {
    userId?: string;
    email?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    fullName?: string | undefined;
    isActive?: boolean;
    createdAt?: Date;
    updatedAt?: Date;
    roles?: string[] | undefined;
}

export class UserDtoApiResponse implements IUserDtoApiResponse {
    success?: boolean;
    data?: UserDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IUserDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"] ? UserDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): UserDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UserDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IUserDtoApiResponse {
    success?: boolean;
    data?: UserDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class UserDtoPagedResponse implements IUserDtoPagedResponse {
    success?: boolean;
    data?: UserDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
    pagination?: PaginationMeta;

    constructor(data?: IUserDtoPagedResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(UserDto.fromJS(item));
            }
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
            this.pagination = _data["pagination"] ? PaginationMeta.fromJS(_data["pagination"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UserDtoPagedResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UserDtoPagedResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : <any>undefined);
        }
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        data["pagination"] = this.pagination ? this.pagination.toJSON() : <any>undefined;
        return data;
    }
}

export interface IUserDtoPagedResponse {
    success?: boolean;
    data?: UserDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
    pagination?: PaginationMeta;
}

export class UserNotificationPreferencesDto implements IUserNotificationPreferencesDto {
    userNotificationPreferencesId?: string;
    userId?: string;
    discordWebhookUrl?: string | undefined;
    isDiscordNotificationEnabled?: boolean;
    notificationProductIds?: string[] | undefined;
    customBotName?: string | undefined;
    customAvatarUrl?: string | undefined;
    createdAt?: Date;
    updatedAt?: Date;
    notificationProducts?: ProductDto[] | undefined;

    constructor(data?: IUserNotificationPreferencesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userNotificationPreferencesId = _data["userNotificationPreferencesId"];
            this.userId = _data["userId"];
            this.discordWebhookUrl = _data["discordWebhookUrl"];
            this.isDiscordNotificationEnabled = _data["isDiscordNotificationEnabled"];
            if (Array.isArray(_data["notificationProductIds"])) {
                this.notificationProductIds = [] as any;
                for (let item of _data["notificationProductIds"])
                    this.notificationProductIds!.push(item);
            }
            this.customBotName = _data["customBotName"];
            this.customAvatarUrl = _data["customAvatarUrl"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            if (Array.isArray(_data["notificationProducts"])) {
                this.notificationProducts = [] as any;
                for (let item of _data["notificationProducts"])
                    this.notificationProducts!.push(ProductDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserNotificationPreferencesDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserNotificationPreferencesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userNotificationPreferencesId"] = this.userNotificationPreferencesId;
        data["userId"] = this.userId;
        data["discordWebhookUrl"] = this.discordWebhookUrl;
        data["isDiscordNotificationEnabled"] = this.isDiscordNotificationEnabled;
        if (Array.isArray(this.notificationProductIds)) {
            data["notificationProductIds"] = [];
            for (let item of this.notificationProductIds)
                data["notificationProductIds"].push(item);
        }
        data["customBotName"] = this.customBotName;
        data["customAvatarUrl"] = this.customAvatarUrl;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        if (Array.isArray(this.notificationProducts)) {
            data["notificationProducts"] = [];
            for (let item of this.notificationProducts)
                data["notificationProducts"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface IUserNotificationPreferencesDto {
    userNotificationPreferencesId?: string;
    userId?: string;
    discordWebhookUrl?: string | undefined;
    isDiscordNotificationEnabled?: boolean;
    notificationProductIds?: string[] | undefined;
    customBotName?: string | undefined;
    customAvatarUrl?: string | undefined;
    createdAt?: Date;
    updatedAt?: Date;
    notificationProducts?: ProductDto[] | undefined;
}

export class UserNotificationPreferencesDtoApiResponse implements IUserNotificationPreferencesDtoApiResponse {
    success?: boolean;
    data?: UserNotificationPreferencesDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IUserNotificationPreferencesDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.data = _data["data"] ? UserNotificationPreferencesDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): UserNotificationPreferencesDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UserNotificationPreferencesDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IUserNotificationPreferencesDtoApiResponse {
    success?: boolean;
    data?: UserNotificationPreferencesDto;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class UserRoleInfoDto implements IUserRoleInfoDto {
    userId?: string;
    email?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    fullName?: string | undefined;
    roleName?: string | undefined;
    assignedAt?: Date;

    constructor(data?: IUserRoleInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.email = _data["email"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.fullName = _data["fullName"];
            this.roleName = _data["roleName"];
            this.assignedAt = _data["assignedAt"] ? new Date(_data["assignedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UserRoleInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserRoleInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["email"] = this.email;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["fullName"] = this.fullName;
        data["roleName"] = this.roleName;
        data["assignedAt"] = this.assignedAt ? this.assignedAt.toISOString() : <any>undefined;
        return data;
    }
}

export interface IUserRoleInfoDto {
    userId?: string;
    email?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    fullName?: string | undefined;
    roleName?: string | undefined;
    assignedAt?: Date;
}

export class UserRoleInfoDtoIEnumerableApiResponse implements IUserRoleInfoDtoIEnumerableApiResponse {
    success?: boolean;
    data?: UserRoleInfoDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;

    constructor(data?: IUserRoleInfoDtoIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(UserRoleInfoDto.fromJS(item));
            }
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.correlationId = _data["correlationId"];
            this.statusCode = _data["statusCode"];
            if (_data["meta"]) {
                this.meta = {} as any;
                for (let key in _data["meta"]) {
                    if (_data["meta"].hasOwnProperty(key))
                        (<any>this.meta)![key] = _data["meta"][key];
                }
            }
        }
    }

    static fromJS(data: any): UserRoleInfoDtoIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UserRoleInfoDtoIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : <any>undefined);
        }
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["correlationId"] = this.correlationId;
        data["statusCode"] = this.statusCode;
        if (this.meta) {
            data["meta"] = {};
            for (let key in this.meta) {
                if (this.meta.hasOwnProperty(key))
                    (<any>data["meta"])[key] = (<any>this.meta)[key];
            }
        }
        return data;
    }
}

export interface IUserRoleInfoDtoIEnumerableApiResponse {
    success?: boolean;
    data?: UserRoleInfoDto[] | undefined;
    message?: string | undefined;
    errors?: string[] | undefined;
    timestamp?: Date;
    correlationId?: string | undefined;
    statusCode?: number;
    meta?: { [key: string]: any; } | undefined;
}

export class UtilitiesExampleRequest implements IUtilitiesExampleRequest {
    text?: string | undefined;
    email?: string | undefined;

    constructor(data?: IUtilitiesExampleRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.text = _data["text"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): UtilitiesExampleRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UtilitiesExampleRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["text"] = this.text;
        data["email"] = this.email;
        return data;
    }
}

export interface IUtilitiesExampleRequest {
    text?: string | undefined;
    email?: string | undefined;
}

export class ValidationExampleRequest implements IValidationExampleRequest {
    email?: string | undefined;
    phone?: string | undefined;
    website?: string | undefined;

    constructor(data?: IValidationExampleRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.phone = _data["phone"];
            this.website = _data["website"];
        }
    }

    static fromJS(data: any): ValidationExampleRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationExampleRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["website"] = this.website;
        return data;
    }
}

export interface IValidationExampleRequest {
    email?: string | undefined;
    phone?: string | undefined;
    website?: string | undefined;
}

export class ValueAnalysisDto implements IValueAnalysisDto {
    product1ValueScore?: number;
    product2ValueScore?: number;
    betterValueProduct?: string | undefined;
    valueAnalysisReason?: string | undefined;

    constructor(data?: IValueAnalysisDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.product1ValueScore = _data["product1ValueScore"];
            this.product2ValueScore = _data["product2ValueScore"];
            this.betterValueProduct = _data["betterValueProduct"];
            this.valueAnalysisReason = _data["valueAnalysisReason"];
        }
    }

    static fromJS(data: any): ValueAnalysisDto {
        data = typeof data === 'object' ? data : {};
        let result = new ValueAnalysisDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["product1ValueScore"] = this.product1ValueScore;
        data["product2ValueScore"] = this.product2ValueScore;
        data["betterValueProduct"] = this.betterValueProduct;
        data["valueAnalysisReason"] = this.valueAnalysisReason;
        return data;
    }
}

export interface IValueAnalysisDto {
    product1ValueScore?: number;
    product2ValueScore?: number;
    betterValueProduct?: string | undefined;
    valueAnalysisReason?: string | undefined;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    return _observableThrow(new ApiException(message, status, response, headers, result));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}